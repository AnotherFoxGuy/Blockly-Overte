function dfv(value, default_val){
    if(!value || value.length === 0){
        return  default_val.length === 0 ? "\"\"" : default_val;
    }  
    else {
        return value;
    }    
}

// Blockly namespace
Blockly.Blocks['Agent_isAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.isAvatar')       
        this.setOutput(true, '');
        this.setColour('#744605');
        this.setTooltip('<code>true</code> if the assignment client script is emulating an avatar, otherwise     <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.isAvatar');
    }
};
javascript.javascriptGenerator.forBlock['Agent_isAvatar'] = (block, generator) => {
    return [`Agent.isAvatar`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Agent_isPlayingAvatarSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.isPlayingAvatarSound')       
        this.setOutput(true, '');
        this.setColour('#744605');
        this.setTooltip('<code>true</code> if the script has a sound to play, otherwise <code>false</code>.     Sounds are played when <code>isAvatar</code> is <code>true</code>, from the position and with the orientation of the     scripted avatar\'s head. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.isPlayingAvatarSound');
    }
};
javascript.javascriptGenerator.forBlock['Agent_isPlayingAvatarSound'] = (block, generator) => {
    return [`Agent.isPlayingAvatarSound`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Agent_isListeningToAudioStream'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.isListeningToAudioStream')       
        this.setOutput(true, '');
        this.setColour('#744605');
        this.setTooltip('<code>true</code> if the agent is "listening" to the audio stream from the     domain, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.isListeningToAudioStream');
    }
};
javascript.javascriptGenerator.forBlock['Agent_isListeningToAudioStream'] = (block, generator) => {
    return [`Agent.isListeningToAudioStream`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Agent_isNoiseGateEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.isNoiseGateEnabled')       
        this.setOutput(true, '');
        this.setColour('#744605');
        this.setTooltip('<code>true</code> if the noise gate is enabled, otherwise <code>false</code>. When enabled, the input audio stream is blocked (fully attenuated) if it falls below an adaptive threshold.');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.isNoiseGateEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Agent_isNoiseGateEnabled'] = (block, generator) => {
    return [`Agent.isNoiseGateEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Agent_lastReceivedAudioLoudness'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.lastReceivedAudioLoudness')       
        this.setOutput(true, '');
        this.setColour('#744605');
        this.setTooltip('The current loudness of the audio input. Nominal range [<code>0.0</code> (no     sound) &ndash; <code>1.0</code> (the onset of clipping)]. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.lastReceivedAudioLoudness');
    }
};
javascript.javascriptGenerator.forBlock['Agent_lastReceivedAudioLoudness'] = (block, generator) => {
    return [`Agent.lastReceivedAudioLoudness`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Agent_sessionUUID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.sessionUUID')       
        this.setOutput(true, '');
        this.setColour('#744605');
        this.setTooltip('The unique ID associated with the agent\'s current session in the domain. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.sessionUUID');
    }
};
javascript.javascriptGenerator.forBlock['Agent_sessionUUID'] = (block, generator) => {
    return [`Agent.sessionUUID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Agent_setIsAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.setIsAvatar')
        // Returns data

        // Params data
        this.appendValueInput('isAvatar') 
            .setCheck('Boolean')
            .appendField('isAvatar');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#744605');
        this.setTooltip('Sets whether the script should emulate an avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.setIsAvatar');
    }
};
javascript.javascriptGenerator.forBlock['Agent_setIsAvatar'] = (block, generator) => {
    const _isAvatar = dfv(generator.valueToCode(block, 'isAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Agent.setIsAvatar(${_isAvatar});\n`;};


// Blockly function
Blockly.Blocks['Agent_getIsAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.getIsAvatar')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#744605');
        this.setTooltip('Checks whether the script is emulating an avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.getIsAvatar');
    }
};
javascript.javascriptGenerator.forBlock['Agent_getIsAvatar'] = (block, generator) => {

return [`Agent.getIsAvatar()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Agent_playAvatarSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Agent.playAvatarSound')
        // Returns data

        // Params data
        this.appendValueInput('avatarSound') 
            .setCheck('SoundObject')
            .appendField('avatarSound');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#744605');
        this.setTooltip('Plays a sound from the position and with the orientation of the emulated avatar\'s head. No sound is played unless <code>isAvatar == true</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Agent.html#.playAvatarSound');
    }
};
javascript.javascriptGenerator.forBlock['Agent_playAvatarSound'] = (block, generator) => {
    const _avatarSound = dfv(generator.valueToCode(block, 'avatarSound', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Agent.playAvatarSound(${_avatarSound});\n`;};


// Blockly namespace
Blockly.Blocks['Avatar_position'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.position')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The position of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.position');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_position'] = (block, generator) => {
    return [`Avatar.position`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_scale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.scale')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The scale of the avatar. The value can be set to anything between <code>0.005</code> and     <code>1000.0</code>. When the scale value is fetched, it may temporarily be further limited by the domain\'s settings.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.scale');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_scale'] = (block, generator) => {
    return [`Avatar.scale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_density'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.density')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The density of the avatar in kg/m<sup>3</sup>. The density is used to work out its mass in    the application of physics. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.density');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_density'] = (block, generator) => {
    return [`Avatar.density`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_handPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.handPosition')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('A user-defined hand position, in world coordinates. The position moves with the avatar   but is otherwise not used or changed by Interface.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.handPosition');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_handPosition'] = (block, generator) => {
    return [`Avatar.handPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_bodyYaw'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.bodyYaw')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The left or right rotation about an axis running from the head to the feet of the avatar.    Yaw is sometimes called "heading".');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.bodyYaw');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_bodyYaw'] = (block, generator) => {
    return [`Avatar.bodyYaw`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_bodyPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.bodyPitch')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation about an axis running from shoulder to shoulder of the avatar. Pitch is    sometimes called "elevation".');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.bodyPitch');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_bodyPitch'] = (block, generator) => {
    return [`Avatar.bodyPitch`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_bodyRoll'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.bodyRoll')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation about an axis running from the chest to the back of the avatar. Roll is    sometimes called "bank".');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.bodyRoll');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_bodyRoll'] = (block, generator) => {
    return [`Avatar.bodyRoll`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_orientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.orientation')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The orientation of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.orientation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_orientation'] = (block, generator) => {
    return [`Avatar.orientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_headOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.headOrientation')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The orientation of the avatar\'s head.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.headOrientation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_headOrientation'] = (block, generator) => {
    return [`Avatar.headOrientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_headPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.headPitch')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation about an axis running from ear to ear of the avatar\'s head. Pitch is    sometimes called "elevation".');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.headPitch');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_headPitch'] = (block, generator) => {
    return [`Avatar.headPitch`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_headYaw'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.headYaw')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation left or right about an axis running from the base to the crown of the avatar\'s    head. Yaw is sometimes called "heading".');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.headYaw');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_headYaw'] = (block, generator) => {
    return [`Avatar.headYaw`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_headRoll'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.headRoll')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation about an axis running from the nose to the back of the avatar\'s head. Roll is    sometimes called "bank".');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.headRoll');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_headRoll'] = (block, generator) => {
    return [`Avatar.headRoll`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_velocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.velocity')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The current velocity of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.velocity');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_velocity'] = (block, generator) => {
    return [`Avatar.velocity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_angularVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.angularVelocity')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The current angular velocity of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.angularVelocity');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_angularVelocity'] = (block, generator) => {
    return [`Avatar.angularVelocity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_audioLoudness'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.audioLoudness')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The instantaneous loudness of the audio input that the avatar is injecting into the    domain.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.audioLoudness');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_audioLoudness'] = (block, generator) => {
    return [`Avatar.audioLoudness`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_audioAverageLoudness'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.audioAverageLoudness')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rolling average loudness of the audio input that the avatar is injecting    into the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.audioAverageLoudness');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_audioAverageLoudness'] = (block, generator) => {
    return [`Avatar.audioAverageLoudness`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_displayName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.displayName')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The avatar\'s display name.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.displayName');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_displayName'] = (block, generator) => {
    return [`Avatar.displayName`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_sessionDisplayName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.sessionDisplayName')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>displayName\'s</code> sanitized and default version defined by the avatar mixer     rather than Interface clients. The result is unique among all avatars present in the domain at the time.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.sessionDisplayName');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_sessionDisplayName'] = (block, generator) => {
    return [`Avatar.sessionDisplayName`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_lookAtSnappingEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.lookAtSnappingEnabled')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>true</code> if the avatar\'s eyes snap to look at another avatar\'s    eyes when the other avatar is in the line of sight and also has <code>lookAtSnappingEnabled == true</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.lookAtSnappingEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_lookAtSnappingEnabled'] = (block, generator) => {
    return [`Avatar.lookAtSnappingEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_skeletonModelURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.skeletonModelURL')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The avatar\'s FST file.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.skeletonModelURL');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_skeletonModelURL'] = (block, generator) => {
    return [`Avatar.skeletonModelURL`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_attachmentData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.attachmentData')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('Information on the avatar\'s attachments.     <p class="important">Deprecated: This property is deprecated and will be removed. Use avatar entities instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.attachmentData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_attachmentData'] = (block, generator) => {
    return [`Avatar.attachmentData`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_jointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.jointNames')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The list of joints in the current avatar model. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.jointNames');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_jointNames'] = (block, generator) => {
    return [`Avatar.jointNames`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_sessionUUID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.sessionUUID')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('Unique ID of the avatar in the domain. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.sessionUUID');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_sessionUUID'] = (block, generator) => {
    return [`Avatar.sessionUUID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_sensorToWorldMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.sensorToWorldMatrix')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The scale, rotation, and translation transform from the user\'s real world to the    avatar\'s size, orientation, and position in the virtual world. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.sensorToWorldMatrix');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_sensorToWorldMatrix'] = (block, generator) => {
    return [`Avatar.sensorToWorldMatrix`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_controllerLeftHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.controllerLeftHandMatrix')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation and translation of the left hand controller relative to the    avatar. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.controllerLeftHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_controllerLeftHandMatrix'] = (block, generator) => {
    return [`Avatar.controllerLeftHandMatrix`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_controllerRightHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.controllerRightHandMatrix')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The rotation and translation of the right hand controller relative to the    avatar. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.controllerRightHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_controllerRightHandMatrix'] = (block, generator) => {
    return [`Avatar.controllerRightHandMatrix`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_sensorToWorldScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.sensorToWorldScale')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('The scale that transforms dimensions in the user\'s real world to the avatar\'s    size in the virtual world. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.sensorToWorldScale');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_sensorToWorldScale'] = (block, generator) => {
    return [`Avatar.sensorToWorldScale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_hasPriority'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.hasPriority')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>true</code> if the avatar is in a "hero" zone, <code>false</code> if it isn\'t.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.hasPriority');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_hasPriority'] = (block, generator) => {
    return [`Avatar.hasPriority`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_hasScriptedBlendshapes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.hasScriptedBlendshapes')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>true</code> if blend shapes are controlled by scripted actions,     otherwise <code>false</code>. Set this to <code>true</code> before using the {@link MyAvatar.setBlendshape} method,     and set back to <code>false</code> after you no longer want scripted control over the blend shapes.    <p><strong>Note:</strong> This property will automatically be set to true if the Controller system has valid facial     blend shape actions.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.hasScriptedBlendshapes');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_hasScriptedBlendshapes'] = (block, generator) => {
    return [`Avatar.hasScriptedBlendshapes`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_hasProceduralBlinkFaceMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.hasProceduralBlinkFaceMovement')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>true</code> if avatars blink automatically by animating     facial blend shapes, <code>false</code> if automatic blinking is disabled. Set to <code>false</code> to fully control     the blink facial blend shapes via the {@link MyAvatar.setBlendshape} method.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.hasProceduralBlinkFaceMovement');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_hasProceduralBlinkFaceMovement'] = (block, generator) => {
    return [`Avatar.hasProceduralBlinkFaceMovement`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_hasProceduralEyeFaceMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.hasProceduralEyeFaceMovement')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>true</code> if the facial blend shapes for an avatar\'s eyes     adjust automatically as the eyes move, <code>false</code> if this automatic movement is disabled. Set this property     to <code>true</code> to prevent the iris from being obscured by the upper or lower lids. Set to <code>false</code> to     fully control the eye blend shapes via the {@link MyAvatar.setBlendshape} method.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.hasProceduralEyeFaceMovement');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_hasProceduralEyeFaceMovement'] = (block, generator) => {
    return [`Avatar.hasProceduralEyeFaceMovement`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Avatar_hasAudioEnabledFaceMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.hasAudioEnabledFaceMovement')       
        this.setOutput(true, '');
        this.setColour('#320360');
        this.setTooltip('<code>true</code> if the avatar\'s mouth blend shapes animate     automatically based on detected microphone input, <code>false</code> if this automatic movement is disabled. Set     this property to <code>false</code> to fully control the mouth facial blend shapes via the     {@link MyAvatar.setBlendshape} method.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.hasAudioEnabledFaceMovement');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_hasAudioEnabledFaceMovement'] = (block, generator) => {
    return [`Avatar.hasAudioEnabledFaceMovement`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Avatar_startAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.startAnimation')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('fps') 
            .setCheck('Number')
            .appendField('fps');
        this.appendValueInput('priority') 
            .setCheck('Number')
            .appendField('priority');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('hold') 
            .setCheck('Boolean')
            .appendField('hold');
        this.appendValueInput('firstFrame') 
            .setCheck('Number')
            .appendField('firstFrame');
        this.appendValueInput('lastFrame') 
            .setCheck('Number')
            .appendField('lastFrame');
        this.appendValueInput('maskedJoints') 
            .setCheck('Array')
            .appendField('maskedJoints');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Starts playing an animation on the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.startAnimation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_startAnimation'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fps = dfv(generator.valueToCode(block, 'fps', javascript.javascriptGenerator.ORDER_ATOMIC), `30`);
    const _priority = dfv(generator.valueToCode(block, 'priority', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _hold = dfv(generator.valueToCode(block, 'hold', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _firstFrame = dfv(generator.valueToCode(block, 'firstFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastFrame = dfv(generator.valueToCode(block, 'lastFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `3.403E+38`);
    const _maskedJoints = dfv(generator.valueToCode(block, 'maskedJoints', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);


    return `Avatar.startAnimation(${_url},${_fps},${_priority},${_loop},${_hold},${_firstFrame},${_lastFrame},${_maskedJoints});\n`;};


// Blockly function
Blockly.Blocks['Avatar_stopAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.stopAnimation')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Stops playing the current animation.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.stopAnimation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_stopAnimation'] = (block, generator) => {


    return `Avatar.stopAnimation();\n`;};


// Blockly function
Blockly.Blocks['Avatar_getAnimationDetails'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getAnimationDetails')
        // Returns data
        this.setOutput(true, '["Avatar.AnimationDetails"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the details of the current avatar animation that is being or was recently played.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getAnimationDetails');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getAnimationDetails'] = (block, generator) => {

return [`Avatar.getAnimationDetails()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getAvatarEntityData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getAvatarEntityData')
        // Returns data
        this.setOutput(true, '["AvatarEntityMap"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets details of all avatar entities.<p><strong>Warning:</strong> Potentially an expensive call. Do not use if possible.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getAvatarEntityData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getAvatarEntityData'] = (block, generator) => {

return [`Avatar.getAvatarEntityData()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setAvatarEntityData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setAvatarEntityData')
        // Returns data

        // Params data
        this.appendValueInput('avatarEntityData') 
            .setCheck('AvatarEntityMap')
            .appendField('avatarEntityData');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets all avatar entities from an object.<p><strong>Warning:</strong> Potentially an expensive call. Do not use if possible.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setAvatarEntityData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setAvatarEntityData'] = (block, generator) => {
    const _avatarEntityData = dfv(generator.valueToCode(block, 'avatarEntityData', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setAvatarEntityData(${_avatarEntityData});\n`;};


// Blockly function
Blockly.Blocks['EntityViewer_queryOctree'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.queryOctree')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3BF2B7');
        this.setTooltip('Updates the entities currently in view.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.queryOctree');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_queryOctree'] = (block, generator) => {


    return `EntityViewer.queryOctree();\n`;};


// Blockly function
Blockly.Blocks['EntityViewer_setPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3BF2B7');
        this.setTooltip('Sets the position of the view frustum.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_setPosition'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `EntityViewer.setPosition(${_position});\n`;};


// Blockly function
Blockly.Blocks['EntityViewer_setOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.setOrientation')
        // Returns data

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3BF2B7');
        this.setTooltip('Sets the orientation of the view frustum.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.setOrientation');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_setOrientation'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `EntityViewer.setOrientation(${_orientation});\n`;};


// Blockly function
Blockly.Blocks['EntityViewer_setCenterRadius'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.setCenterRadius')
        // Returns data

        // Params data
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3BF2B7');
        this.setTooltip('Sets the radius of the center "keyhole" in the view frustum.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.setCenterRadius');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_setCenterRadius'] = (block, generator) => {
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `EntityViewer.setCenterRadius(${_radius});\n`;};


// Blockly function
Blockly.Blocks['EntityViewer_setMaxPacketsPerSecond'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.setMaxPacketsPerSecond')
        // Returns data

        // Params data
        this.appendValueInput('maxPacketsPerSecond') 
            .setCheck('Number')
            .appendField('maxPacketsPerSecond');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3BF2B7');
        this.setTooltip('Sets the maximum number of entity packets to receive from the domain server per second.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.setMaxPacketsPerSecond');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_setMaxPacketsPerSecond'] = (block, generator) => {
    const _maxPacketsPerSecond = dfv(generator.valueToCode(block, 'maxPacketsPerSecond', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `EntityViewer.setMaxPacketsPerSecond(${_maxPacketsPerSecond});\n`;};


// Blockly function
Blockly.Blocks['EntityViewer_getPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.getPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#3BF2B7');
        this.setTooltip('Gets the position of the view frustum.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.getPosition');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_getPosition'] = (block, generator) => {

return [`EntityViewer.getPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['EntityViewer_getOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.getOrientation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#3BF2B7');
        this.setTooltip('Gets the orientation of the view frustum.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.getOrientation');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_getOrientation'] = (block, generator) => {

return [`EntityViewer.getOrientation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['EntityViewer_getMaxPacketsPerSecond'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.getMaxPacketsPerSecond')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#3BF2B7');
        this.setTooltip('Gets the maximum number of entity packets to receive from the domain server per second.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.getMaxPacketsPerSecond');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_getMaxPacketsPerSecond'] = (block, generator) => {

return [`EntityViewer.getMaxPacketsPerSecond()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['EntityViewer_getOctreeElementsCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityViewer.getOctreeElementsCount')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#3BF2B7');
        this.setTooltip('Gets the number of nodes in the octree.');
        this.setHelpUrl('https://apidocs.overte.org/EntityViewer.html#.getOctreeElementsCount');
    }
};
javascript.javascriptGenerator.forBlock['EntityViewer_getOctreeElementsCount'] = (block, generator) => {

return [`EntityViewer.getOctreeElementsCount()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['About_platform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.platform')       
        this.setOutput(true, '');
        this.setColour('#8F7F4C');
        this.setTooltip('The name of the Interface platform running, e,g., <code>"Overte"</code> for the Overte.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.platform');
    }
};
javascript.javascriptGenerator.forBlock['About_platform'] = (block, generator) => {
    return [`About.platform`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['About_buildDate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.buildDate')       
        this.setOutput(true, '');
        this.setColour('#8F7F4C');
        this.setTooltip('The build date of Interface that is currently running. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.buildDate');
    }
};
javascript.javascriptGenerator.forBlock['About_buildDate'] = (block, generator) => {
    return [`About.buildDate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['About_buildVersion'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.buildVersion')       
        this.setOutput(true, '');
        this.setColour('#8F7F4C');
        this.setTooltip('The build version of Interface that is currently running. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.buildVersion');
    }
};
javascript.javascriptGenerator.forBlock['About_buildVersion'] = (block, generator) => {
    return [`About.buildVersion`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['About_qtVersion'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.qtVersion')       
        this.setOutput(true, '');
        this.setColour('#8F7F4C');
        this.setTooltip('The Qt version used in Interface that is currently running. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.qtVersion');
    }
};
javascript.javascriptGenerator.forBlock['About_qtVersion'] = (block, generator) => {
    return [`About.qtVersion`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['About_qtWebEngineVersion'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.qtWebEngineVersion')       
        this.setOutput(true, '');
        this.setColour('#8F7F4C');
        this.setTooltip('The Qt WebEngine version used in Interface that is currently running. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.qtWebEngineVersion');
    }
};
javascript.javascriptGenerator.forBlock['About_qtWebEngineVersion'] = (block, generator) => {
    return [`About.qtWebEngineVersion`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['About_qtChromiumVersion'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.qtChromiumVersion')       
        this.setOutput(true, '');
        this.setColour('#8F7F4C');
        this.setTooltip('The Qt Chromium version used in Interface that is currently running. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.qtChromiumVersion');
    }
};
javascript.javascriptGenerator.forBlock['About_qtChromiumVersion'] = (block, generator) => {
    return [`About.qtChromiumVersion`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['About_openUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('About.openUrl')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8F7F4C');
        this.setTooltip('Display a web page in an Interface browser window or the tablet.');
        this.setHelpUrl('https://apidocs.overte.org/About.html#.openUrl');
    }
};
javascript.javascriptGenerator.forBlock['About_openUrl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `About.openUrl(${_url});\n`;};


// Blockly typedef
Blockly.Blocks['Controller_Hardware-Application'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hardware-Application')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Hardware.Application</code> object has properties representing Interface\'s state. The propertyvalues are integer IDs, uniquely identifying each output. <em>Read-only.</em></p><p>These states can be mapped to actions or functions or <code>Controller.Standard</code> items in a {@link RouteObject}mapping (e.g., using the {@link RouteObject#when} method). Each data value is either <code>1.0</code> for "true" or<code>0.0</code> for "false".</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Data</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>CameraFirstPerson</code></td><td>number</td><td>number</td><td>The camera is in first-person mode.      <em>Legacy first person camera mode.</em></td></tr>    <tr><td><code>CameraFirstPersonLookAt</code></td><td>number</td><td>number</td><td>The camera is in first-person mode.      <em>Default first person camera mode.</em></td></tr>    <tr><td><code>CameraThirdPerson</code></td><td>number</td><td>number</td><td>The camera is in third-person mode.      <em>Legacy third person camera mode.</em></td></tr>    <tr><td><code>CameraLookAt</code></td><td>number</td><td>number</td><td>The camera is in third-person mode.      <em>Default third person camera mode.</em></td></tr>    <tr><td><code>CameraFSM</code></td><td>number</td><td>number</td><td>The camera is in full screen mirror mode.      <em>Legacy "look at myself" behavior.</em></td></tr>    <tr><td><code>CameraSelfie</code></td><td>number</td><td>number</td><td>The camera is in selfie mode.      <em>Default "look at myself" camera mode.</em></td></tr>    <tr><td><code>CameraIndependent</code></td><td>number</td><td>number</td><td>The camera is in independent mode.</td></tr>    <tr><td><code>CameraEntity</code></td><td>number</td><td>number</td><td>The camera is in entity mode.</td></tr>    <tr><td><code>InHMD</code></td><td>number</td><td>number</td><td>The user is in HMD mode.</td></tr>    <tr><td><code>CaptureMouse</code></td><td>number</td><td>number</td><td>The mouse is captured.  In this mode,      the mouse is invisible and cannot leave the bounds of Interface, as long as Interface is the active window and      no menu item is selected.</td></tr>    <tr><td><code>AdvancedMovement</code></td><td>number</td><td>number</td><td>Advanced movement (walking) controls are      enabled.</td></tr>    <tr><td><code>StrafeEnabled</code></td><td>number</td><td>number</td><td>Strafing is enabled</td></tr>    <tr><td><code>LeftHandDominant</code></td><td>number</td><td>number</td><td>Dominant hand set to left.</td></tr>    <tr><td><code>RightHandDominant</code></td><td>number</td><td>number</td><td>Dominant hand set to right.</td></tr>    <tr><td><code>SnapTurn</code></td><td>number</td><td>number</td><td>Snap turn is enabled.</td></tr>    <tr><td><code>Grounded</code></td><td>number</td><td>number</td><td>The user\'s avatar is on the ground.</td></tr>    <tr><td><code>NavigationFocused</code></td><td>number</td><td>number</td><td><em>Not used.</em></td></tr>    <tr><td><code>PlatformWindows</code></td><td>number</td><td>number</td><td>The operating system is Windows.</td></tr>    <tr><td><code>PlatformMac</code></td><td>number</td><td>number</td><td>The operating system is Mac.</td></tr>    <tr><td><code>PlatformAndroid</code></td><td>number</td><td>number</td><td>The operating system is Android.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hardware-Application');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hardware-Application'] = (block, generator) => {

    return [`new Controller.Hardware-Application()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AvatarBookmarks_BookmarkData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.BookmarkData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('version') 
            .setCheck('Number')
            .appendField('version');
        this.appendValueInput('avatarUrl') 
            .setCheck('String')
            .appendField('avatarUrl');
        this.appendValueInput('avatarScale') 
            .setCheck('Number')
            .appendField('avatarScale');
        this.appendValueInput('avatarEntites') 
            .setCheck('Array')
            .appendField('avatarEntites');
        this.appendValueInput('attachments') 
            .setCheck('Array')
            .appendField('attachments');
        this.setColour('#58D755');
        this.setTooltip('Details of an avatar bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.BookmarkData');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_BookmarkData'] = (block, generator) => {
    const _version = dfv(generator.valueToCode(block, 'version', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _avatarUrl = dfv(generator.valueToCode(block, 'avatarUrl', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _avatarScale = dfv(generator.valueToCode(block, 'avatarScale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _avatarEntites = dfv(generator.valueToCode(block, 'avatarEntites', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _attachments = dfv(generator.valueToCode(block, 'attachments', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new AvatarBookmarks.BookmarkData(${_version},${_avatarUrl},${_avatarScale},${_avatarEntites},${_attachments})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['AvatarBookmarks_getBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.getBookmark')
        // Returns data
        this.setOutput(true, '["AvatarBookmarks.BookmarkData"]');

        // Params data
        this.appendValueInput('bookmarkName') 
            .setCheck('String')
            .appendField('bookmarkName');

        this.setColour('#58D755');
        this.setTooltip('Gets the details of an avatar bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.getBookmark');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_getBookmark'] = (block, generator) => {
    const _bookmarkName = dfv(generator.valueToCode(block, 'bookmarkName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AvatarBookmarks.getBookmark(${_bookmarkName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarBookmarks_addBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.addBookmark')
        // Returns data

        // Params data
        this.appendValueInput('bookmarkName') 
            .setCheck('String')
            .appendField('bookmarkName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#58D755');
        this.setTooltip('Adds a new (or updates an existing) avatar bookmark with your current avatar model, scale, and avatar entities.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.addBookmark');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_addBookmark'] = (block, generator) => {
    const _bookmarkName = dfv(generator.valueToCode(block, 'bookmarkName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `AvatarBookmarks.addBookmark(${_bookmarkName});\n`;};


// Blockly function
Blockly.Blocks['AvatarBookmarks_saveBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.saveBookmark')
        // Returns data

        // Params data
        this.appendValueInput('bookmarkName') 
            .setCheck('String')
            .appendField('bookmarkName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#58D755');
        this.setTooltip('Updates an existing bookmark with your current avatar model, scale, and wearables. No action is taken if the bookmark doesn\'t exist.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.saveBookmark');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_saveBookmark'] = (block, generator) => {
    const _bookmarkName = dfv(generator.valueToCode(block, 'bookmarkName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `AvatarBookmarks.saveBookmark(${_bookmarkName});\n`;};


// Blockly function
Blockly.Blocks['AvatarBookmarks_loadBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.loadBookmark')
        // Returns data

        // Params data
        this.appendValueInput('bookmarkName') 
            .setCheck('String')
            .appendField('bookmarkName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#58D755');
        this.setTooltip('Loads an avatar bookmark, setting your avatar model, scale, and avatar entities (or attachments if an old bookmark) to those in the bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.loadBookmark');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_loadBookmark'] = (block, generator) => {
    const _bookmarkName = dfv(generator.valueToCode(block, 'bookmarkName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `AvatarBookmarks.loadBookmark(${_bookmarkName});\n`;};


// Blockly function
Blockly.Blocks['AvatarBookmarks_removeBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.removeBookmark')
        // Returns data

        // Params data
        this.appendValueInput('bookmarkName') 
            .setCheck('String')
            .appendField('bookmarkName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#58D755');
        this.setTooltip('Deletes an avatar bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.removeBookmark');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_removeBookmark'] = (block, generator) => {
    const _bookmarkName = dfv(generator.valueToCode(block, 'bookmarkName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `AvatarBookmarks.removeBookmark(${_bookmarkName});\n`;};


// Blockly function
Blockly.Blocks['AvatarBookmarks_getBookmarks'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarBookmarks.getBookmarks')
        // Returns data
        this.setOutput(true, '["Object.<string, AvatarBookmarks.BookmarkData>"]');

        // Params data

        this.setColour('#58D755');
        this.setTooltip('Gets the details of all avatar bookmarks.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.getBookmarks');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_getBookmarks'] = (block, generator) => {

return [`AvatarBookmarks.getBookmarks()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['AvatarBookmarks_bookmarkLoaded'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarBookmarks.bookmarkLoaded');

        this.appendDummyInput('bookmarkName')
            .appendField('bookmarkName:')
            .appendField(new Blockly.FieldVariable('bookmarkLoaded_bookmarkName'), 'bookmarkName');

        this.setColour('#58D755');
        this.setTooltip('Triggered when an avatar bookmark is loaded, setting your avatar model, scale, and avatar entities (or attachments if an old bookmark) to those in the bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.bookmarkLoaded');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_bookmarkLoaded'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const bookmarkName = generator.getVariableName(block.getFieldValue('bookmarkName'));

return `AvatarBookmarks.bookmarkLoaded.connect((_bookmarkName) => { 
  ${bookmarkName} = _bookmarkName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarBookmarks_bookmarkDeleted'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarBookmarks.bookmarkDeleted');

        this.appendDummyInput('bookmarkName')
            .appendField('bookmarkName:')
            .appendField(new Blockly.FieldVariable('bookmarkDeleted_bookmarkName'), 'bookmarkName');

        this.setColour('#58D755');
        this.setTooltip('Triggered when an avatar bookmark is deleted.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.bookmarkDeleted');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_bookmarkDeleted'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const bookmarkName = generator.getVariableName(block.getFieldValue('bookmarkName'));

return `AvatarBookmarks.bookmarkDeleted.connect((_bookmarkName) => { 
  ${bookmarkName} = _bookmarkName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarBookmarks_bookmarkAdded'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarBookmarks.bookmarkAdded');

        this.appendDummyInput('bookmarkName')
            .appendField('bookmarkName:')
            .appendField(new Blockly.FieldVariable('bookmarkAdded_bookmarkName'), 'bookmarkName');

        this.setColour('#58D755');
        this.setTooltip('Triggered when a new avatar bookmark is added or an existing avatar bookmark is updated, using {@link AvatarBookmarks.addBookmark|addBookmark}.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarBookmarks.html#.bookmarkAdded');
    }
};
javascript.javascriptGenerator.forBlock['AvatarBookmarks_bookmarkAdded'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const bookmarkName = generator.getVariableName(block.getFieldValue('bookmarkName'));

return `AvatarBookmarks.bookmarkAdded.connect((_bookmarkName) => { 
  ${bookmarkName} = _bookmarkName;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['LocationBookmarks_deleteBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LocationBookmarks.deleteBookmark')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BD59DA');
        this.setTooltip('Prompts the user to delete a bookmark. The user can select the bookmark to delete in the dialog that is opened.');
        this.setHelpUrl('https://apidocs.overte.org/LocationBookmarks.html#.deleteBookmark');
    }
};
javascript.javascriptGenerator.forBlock['LocationBookmarks_deleteBookmark'] = (block, generator) => {


    return `LocationBookmarks.deleteBookmark();\n`;};


// Blockly namespace
Blockly.Blocks['Camera_position'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.position')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The position of the camera. You can set this value only when the camera is in independent     mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.position');
    }
};
javascript.javascriptGenerator.forBlock['Camera_position'] = (block, generator) => {
    return [`Camera.position`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Camera_orientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.orientation')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The orientation of the camera. You can set this value only when the camera is in     independent mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.orientation');
    }
};
javascript.javascriptGenerator.forBlock['Camera_orientation'] = (block, generator) => {
    return [`Camera.orientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Camera_mode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.mode')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The camera mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.mode');
    }
};
javascript.javascriptGenerator.forBlock['Camera_mode'] = (block, generator) => {
    return [`Camera.mode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Camera_frustum'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.frustum')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The camera frustum.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.frustum');
    }
};
javascript.javascriptGenerator.forBlock['Camera_frustum'] = (block, generator) => {
    return [`Camera.frustum`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Camera_cameraEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.cameraEntity')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The ID of the entity that is used for the camera position and orientation when the     camera is in entity mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.cameraEntity');
    }
};
javascript.javascriptGenerator.forBlock['Camera_cameraEntity'] = (block, generator) => {
    return [`Camera.cameraEntity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Camera_captureMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.captureMouse')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The mouse capture state.  When <code>true</code>, the mouse is invisible and cannot leave the bounds ofInterface, as long as Interface is the active window and no menu item is selected.  When <code>false</code>, the mousebehaves normally.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.captureMouse');
    }
};
javascript.javascriptGenerator.forBlock['Camera_captureMouse'] = (block, generator) => {
    return [`Camera.captureMouse`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Camera_sensitivity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.sensitivity')       
        this.setOutput(true, '');
        this.setColour('#967D35');
        this.setTooltip('The current camera sensitivity.  Must be positive.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.sensitivity');
    }
};
javascript.javascriptGenerator.forBlock['Camera_sensitivity'] = (block, generator) => {
    return [`Camera.sensitivity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Camera_getCameraEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getCameraEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the ID of the entity that the camera is set to follow (i.e., use the position and orientation from) when it\'s in entity mode. You can also get the entity ID using the {@link Camera|Camera.cameraEntity} property.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getCameraEntity');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getCameraEntity'] = (block, generator) => {

return [`Camera.getCameraEntity()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setCameraEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setCameraEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the entity that the camera should follow (i.e., use the position and orientation from) when it\'s in entity mode. You can also set the entity using the {@link Camera|Camera.cameraEntity} property.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setCameraEntity');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setCameraEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Camera.setCameraEntity(${_entityID});\n`;};


// Blockly typedef
Blockly.Blocks['LODManager_WorldDetailQuality'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.WorldDetailQuality')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9B7645');
        this.setTooltip('<p>The balance between target framerate and world detail quality rendered.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>High frame rate / Low detail quality.</td></tr>    <tr><td><code>1</code></td><td>Medium frame rate / Medium detail quality.</td></tr>    <tr><td><code>2</code></td><td>Low frame rate / High detail quality.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.WorldDetailQuality');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_WorldDetailQuality'] = (block, generator) => {

    return [`new LODManager.WorldDetailQuality()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['LODManager_worldDetailQuality'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.worldDetailQuality')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The quality of the rendered world detail.    <p>Setting this value updates the current desktop or HMD target LOD FPS.</p>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.worldDetailQuality');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_worldDetailQuality'] = (block, generator) => {
    return [`LODManager.worldDetailQuality`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodQualityLevel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodQualityLevel')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em>    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodQualityLevel');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodQualityLevel'] = (block, generator) => {
    return [`LODManager.lodQualityLevel`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_automaticLODAdjust'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.automaticLODAdjust')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<code>true</code> to automatically adjust the LOD, <code>false</code> to manually     adjust it.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.automaticLODAdjust');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_automaticLODAdjust'] = (block, generator) => {
    return [`LODManager.automaticLODAdjust`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_engineRunTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.engineRunTime')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The time spent in the "render" thread to produce the most recent frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.engineRunTime');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_engineRunTime'] = (block, generator) => {
    return [`LODManager.engineRunTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_batchTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.batchTime')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The time spent in the "present" thread processing the batches of the most recent frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.batchTime');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_batchTime'] = (block, generator) => {
    return [`LODManager.batchTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_presentTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.presentTime')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The time spent in the "present" thread between the last buffer swap, i.e., the total time     to submit the most recent frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.presentTime');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_presentTime'] = (block, generator) => {
    return [`LODManager.presentTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_gpuTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.gpuTime')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The time spent in the GPU executing the most recent frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.gpuTime');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_gpuTime'] = (block, generator) => {
    return [`LODManager.gpuTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_nowRenderTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.nowRenderTime')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The current, instantaneous time spend to produce frames, in ms. This is the worst of     <code>engineRunTime</code>, <code>batchTime</code>, <code>presentTime</code>, and <code>gpuTime</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.nowRenderTime');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_nowRenderTime'] = (block, generator) => {
    return [`LODManager.nowRenderTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_nowRenderFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.nowRenderFPS')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The current, instantaneous frame rate, in Hz.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.nowRenderFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_nowRenderFPS'] = (block, generator) => {
    return [`LODManager.nowRenderFPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_smoothScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.smoothScale')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The amount of smoothing applied to calculate <code>smoothRenderTime</code> and     <code>smoothRenderFPS</code>.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.smoothScale');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_smoothScale'] = (block, generator) => {
    return [`LODManager.smoothScale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_smoothRenderTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.smoothRenderTime')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The average time spend to produce frames, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.smoothRenderTime');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_smoothRenderTime'] = (block, generator) => {
    return [`LODManager.smoothRenderTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_smoothRenderFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.smoothRenderFPS')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The average frame rate, in Hz.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.smoothRenderFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_smoothRenderFPS'] = (block, generator) => {
    return [`LODManager.smoothRenderFPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodTargetFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodTargetFPS')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The target LOD FPS per the current desktop or HMD display mode, capped by the target     refresh rate set by the {@link Performance} API.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodTargetFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodTargetFPS'] = (block, generator) => {
    return [`LODManager.lodTargetFPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodAngleDeg'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodAngleDeg')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The minimum angular dimension (relative to the camera position) of an entity in order for     it to be rendered, in degrees. The angular dimension is calculated as a sphere of radius half the diagonal of the     entity\'s AA box.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodAngleDeg');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodAngleDeg'] = (block, generator) => {
    return [`LODManager.lodAngleDeg`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodFarMaxAngleDeg'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodFarMaxAngleDeg')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The maximum angular size (relative to the camera position)    of an entity that is allowed to be culled by LOD Manager, in degrees at distance specified by lodFarDistance. The angular dimension is    calculated as a sphere of radius half the diagonal of the entity\'s AA box.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodFarMaxAngleDeg');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodFarMaxAngleDeg'] = (block, generator) => {
    return [`LODManager.lodFarMaxAngleDeg`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodNearMaxAngleDeg'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodNearMaxAngleDeg')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('The maximum angular size (relative to the camera position)    of an entity that is allowed to be culled by LOD Manager, in degrees at distance specified by lodNearDistance. The angular dimension is    calculated as a sphere of radius half the diagonal of the entity\'s AA box.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodNearMaxAngleDeg');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodNearMaxAngleDeg'] = (block, generator) => {
    return [`LODManager.lodNearMaxAngleDeg`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodFarDistance'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodFarDistance')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('Distance for which lodFarMaxAngleDeg limit is applied');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodFarDistance');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodFarDistance'] = (block, generator) => {
    return [`LODManager.lodFarDistance`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_lodNearDistance'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.lodNearDistance')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('Distance for which lodNearMaxAngleDeg limit is applied');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.lodNearDistance');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_lodNearDistance'] = (block, generator) => {
    return [`LODManager.lodNearDistance`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidKp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidKp')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidKp');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidKp'] = (block, generator) => {
    return [`LODManager.pidKp`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidKi'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidKi')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidKi');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidKi'] = (block, generator) => {
    return [`LODManager.pidKi`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidKd'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidKd')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidKd');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidKd'] = (block, generator) => {
    return [`LODManager.pidKd`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidKv'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidKv')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidKv');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidKv'] = (block, generator) => {
    return [`LODManager.pidKv`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidOp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidOp')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em> <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidOp');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidOp'] = (block, generator) => {
    return [`LODManager.pidOp`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidOi'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidOi')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em> <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidOi');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidOi'] = (block, generator) => {
    return [`LODManager.pidOi`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidOd'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidOd')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em> <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidOd');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidOd'] = (block, generator) => {
    return [`LODManager.pidOd`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['LODManager_pidO'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.pidO')       
        this.setOutput(true, '');
        this.setColour('#9B7645');
        this.setTooltip('<em>Not used.</em> <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.pidO');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_pidO'] = (block, generator) => {
    return [`LODManager.pidO`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['LODManager_setAutomaticLODAdjust'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.setAutomaticLODAdjust')
        // Returns data

        // Params data
        this.appendValueInput('value') 
            .setCheck('Boolean')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9B7645');
        this.setTooltip('Sets whether the LOD should be automatically adjusted.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.setAutomaticLODAdjust');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_setAutomaticLODAdjust'] = (block, generator) => {
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `LODManager.setAutomaticLODAdjust(${_value});\n`;};


// Blockly function
Blockly.Blocks['LODManager_getAutomaticLODAdjust'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.getAutomaticLODAdjust')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#9B7645');
        this.setTooltip('Gets whether the LOD is being automatically adjusted.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.getAutomaticLODAdjust');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_getAutomaticLODAdjust'] = (block, generator) => {

return [`LODManager.getAutomaticLODAdjust()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['LODManager_setDesktopLODTargetFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.setDesktopLODTargetFPS')
        // Returns data

        // Params data
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9B7645');
        this.setTooltip('Sets the target desktop LOD FPS.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.setDesktopLODTargetFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_setDesktopLODTargetFPS'] = (block, generator) => {
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `LODManager.setDesktopLODTargetFPS(${_value});\n`;};


// Blockly function
Blockly.Blocks['LODManager_getDesktopLODTargetFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.getDesktopLODTargetFPS')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#9B7645');
        this.setTooltip('Gets the target desktop LOD FPS.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.getDesktopLODTargetFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_getDesktopLODTargetFPS'] = (block, generator) => {

return [`LODManager.getDesktopLODTargetFPS()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['LODManager_setHMDLODTargetFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.setHMDLODTargetFPS')
        // Returns data

        // Params data
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9B7645');
        this.setTooltip('Sets the target HMD LOD FPS.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.setHMDLODTargetFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_setHMDLODTargetFPS'] = (block, generator) => {
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `LODManager.setHMDLODTargetFPS(${_value});\n`;};


// Blockly function
Blockly.Blocks['LODManager_getHMDLODTargetFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.getHMDLODTargetFPS')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#9B7645');
        this.setTooltip('Gets the target HMD LOD FPS.The target FPS in HMD mode. The LOD is adjusted to ...');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.getHMDLODTargetFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_getHMDLODTargetFPS'] = (block, generator) => {

return [`LODManager.getHMDLODTargetFPS()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['LODManager_getLODFeedbackText'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.getLODFeedbackText')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#9B7645');
        this.setTooltip('Gets a text description of the current level of detail rendered.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.getLODFeedbackText');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_getLODFeedbackText'] = (block, generator) => {

return [`LODManager.getLODFeedbackText()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['LODManager_getLODTargetFPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LODManager.getLODTargetFPS')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#9B7645');
        this.setTooltip('The target LOD FPS per the current desktop or HMD display mode, capped by the target refresh rate.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.getLODTargetFPS');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_getLODTargetFPS'] = (block, generator) => {

return [`LODManager.getLODTargetFPS()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['LODManager_autoLODChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('LODManager.autoLODChanged');


        this.setColour('#9B7645');
        this.setTooltip('Triggered when whether or not the LOD is being automatically adjusted changes.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.autoLODChanged');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_autoLODChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `LODManager.autoLODChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['LODManager_worldDetailQualityChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('LODManager.worldDetailQualityChanged');


        this.setColour('#9B7645');
        this.setTooltip('Triggered when the world detail quality changes.');
        this.setHelpUrl('https://apidocs.overte.org/LODManager.html#.worldDetailQualityChanged');
    }
};
javascript.javascriptGenerator.forBlock['LODManager_worldDetailQualityChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `LODManager.worldDetailQualityChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['LocationBookmarks_getAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LocationBookmarks.getAddress')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('bookmarkName') 
            .setCheck('String')
            .appendField('bookmarkName');

        this.setColour('#BD59DA');
        this.setTooltip('Gets the directory services address associated with a bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/LocationBookmarks.html#.getAddress');
    }
};
javascript.javascriptGenerator.forBlock['LocationBookmarks_getAddress'] = (block, generator) => {
    const _bookmarkName = dfv(generator.valueToCode(block, 'bookmarkName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`LocationBookmarks.getAddress(${_bookmarkName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['LocationBookmarks_addBookmark'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LocationBookmarks.addBookmark')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BD59DA');
        this.setTooltip('Prompts the user to bookmark their current location. The user can specify the name of the bookmark in the dialog that is opened.');
        this.setHelpUrl('https://apidocs.overte.org/LocationBookmarks.html#.addBookmark');
    }
};
javascript.javascriptGenerator.forBlock['LocationBookmarks_addBookmark'] = (block, generator) => {


    return `LocationBookmarks.addBookmark();\n`;};


// Blockly function
Blockly.Blocks['LocationBookmarks_setHomeLocationToAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LocationBookmarks.setHomeLocationToAddress')
        // Returns data

        // Params data
        this.appendValueInput('address') 
            .setCheck('String')
            .appendField('address');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BD59DA');
        this.setTooltip('Sets the directory services address associated with the "Home" bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/LocationBookmarks.html#.setHomeLocationToAddress');
    }
};
javascript.javascriptGenerator.forBlock['LocationBookmarks_setHomeLocationToAddress'] = (block, generator) => {
    const _address = dfv(generator.valueToCode(block, 'address', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `LocationBookmarks.setHomeLocationToAddress(${_address});\n`;};


// Blockly function
Blockly.Blocks['LocationBookmarks_getHomeLocationAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('LocationBookmarks.getHomeLocationAddress')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#BD59DA');
        this.setTooltip('Gets the directory services address associated with the "Home" bookmark.');
        this.setHelpUrl('https://apidocs.overte.org/LocationBookmarks.html#.getHomeLocationAddress');
    }
};
javascript.javascriptGenerator.forBlock['LocationBookmarks_getHomeLocationAddress'] = (block, generator) => {

return [`LocationBookmarks.getHomeLocationAddress()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['RefreshRateProfileName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RefreshRateProfileName')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#E009D1');
        this.setTooltip('<p>Refresh rate profile.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"Eco"</code></td><td>Low refresh rate, which is reduced when Interface doesn\'t have focus or is         minimized.</td></tr>    <tr><td><code>"Interactive"</code></td><td>Medium refresh rate, which is reduced when Interface doesn\'t have focus or is         minimized.</td></tr>    <tr><td><code>"Realtime"</code></td><td>High refresh rate, even when Interface doesn\'t have focus or is minimized.    <tr><td><code>"Custom"</code></td><td>Custom refresh rate for full control over the refresh rate in all states.  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/RefreshRateProfileName');
    }
};
javascript.javascriptGenerator.forBlock['RefreshRateProfileName'] = (block, generator) => {

    return [`new RefreshRateProfileName()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['RefreshRateRegimeName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RefreshRateRegimeName')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#49D40A');
        this.setTooltip('<p>Interface states that affect the refresh rate.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"FocusActive"</code></td><td>Interface has focus and the user is active or is in VR.</td></tr>    <tr><td><code>"FocusInactive"</code></td><td>Interface has focus and the user is inactive.</td></tr>    <tr><td><code>"Unfocus"</code></td><td>Interface doesn\'t have focus.</td></tr>    <tr><td><code>"Minimized"</code></td><td>Interface is minimized.</td></tr>    <tr><td><code>"StartUp"</code></td><td>Interface is starting up.</td></tr>    <tr><td><code>"ShutDown"</code></td><td>Interface is shutting down.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/RefreshRateRegimeName');
    }
};
javascript.javascriptGenerator.forBlock['RefreshRateRegimeName'] = (block, generator) => {

    return [`new RefreshRateRegimeName()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['UXModeName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('UXModeName')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#CF973F');
        this.setTooltip('<p>User experience (UX) modes.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"Desktop"</code></td><td>Desktop user experience.</td></tr>    <tr><td><code>"VR"</code></td><td>VR user experience.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/UXModeName');
    }
};
javascript.javascriptGenerator.forBlock['UXModeName'] = (block, generator) => {

    return [`new UXModeName()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['RefreshRateRegime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RefreshRateRegime')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#D186ED');
        this.setTooltip('<p>Interface states that affect the refresh rate.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>FOCUS_ACTIVE</td><td>Interface has focus and the user is active or is in VR.</td></tr>    <tr><td><code>1</code></td><td>FOCUS_INACTIVE</td><td>Interface has focus and the user is inactive.</td></tr>    <tr><td><code>2</code></td><td>UNFOCUS</td><td>Interface doesn\'t have focus.</td></tr>    <tr><td><code>3</code></td><td>MINIMIZED</td><td>Interface is minimized.</td></tr>    <tr><td><code>4</code></td><td>STARTUP</td><td>Interface is starting up.</td></tr>    <tr><td><code>5</code></td><td>SHUTDOWN</td><td>Interface is shutting down.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/RefreshRateRegime');
    }
};
javascript.javascriptGenerator.forBlock['RefreshRateRegime'] = (block, generator) => {

    return [`new RefreshRateRegime()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['UXMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('UXMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#CFA4D1');
        this.setTooltip('<p>User experience (UX) modes.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>DESKTOP</td><td>Desktop user experience.</td></tr>    <tr><td><code>1</code></td><td>VR</td><td>VR use experience.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/UXMode');
    }
};
javascript.javascriptGenerator.forBlock['UXMode'] = (block, generator) => {

    return [`new UXMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['SpeechRecognizer_setEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SpeechRecognizer.setEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#46258B');
        this.setTooltip('Enables or disables speech recognition.');
        this.setHelpUrl('https://apidocs.overte.org/SpeechRecognizer.html#.setEnabled');
    }
};
javascript.javascriptGenerator.forBlock['SpeechRecognizer_setEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `SpeechRecognizer.setEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['SpeechRecognizer_addCommand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SpeechRecognizer.addCommand')
        // Returns data

        // Params data
        this.appendValueInput('command') 
            .setCheck('String')
            .appendField('command');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#46258B');
        this.setTooltip('Adds a voice command to the speech recognizer.');
        this.setHelpUrl('https://apidocs.overte.org/SpeechRecognizer.html#.addCommand');
    }
};
javascript.javascriptGenerator.forBlock['SpeechRecognizer_addCommand'] = (block, generator) => {
    const _command = dfv(generator.valueToCode(block, 'command', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `SpeechRecognizer.addCommand(${_command});\n`;};


// Blockly function
Blockly.Blocks['SpeechRecognizer_removeCommand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SpeechRecognizer.removeCommand')
        // Returns data

        // Params data
        this.appendValueInput('command') 
            .setCheck('String')
            .appendField('command');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#46258B');
        this.setTooltip('Removes a voice command from the speech recognizer.');
        this.setHelpUrl('https://apidocs.overte.org/SpeechRecognizer.html#.removeCommand');
    }
};
javascript.javascriptGenerator.forBlock['SpeechRecognizer_removeCommand'] = (block, generator) => {
    const _command = dfv(generator.valueToCode(block, 'command', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `SpeechRecognizer.removeCommand(${_command});\n`;};


// Blockly signal
Blockly.Blocks['SpeechRecognizer_commandRecognized'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('SpeechRecognizer.commandRecognized');

        this.appendDummyInput('command')
            .appendField('command:')
            .appendField(new Blockly.FieldVariable('commandRecognized_command'), 'command');

        this.setColour('#46258B');
        this.setTooltip('Triggered when a voice command has been recognized.');
        this.setHelpUrl('https://apidocs.overte.org/SpeechRecognizer.html#.commandRecognized');
    }
};
javascript.javascriptGenerator.forBlock['SpeechRecognizer_commandRecognized'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const command = generator.getVariableName(block.getFieldValue('command'));

return `SpeechRecognizer.commandRecognized.connect((_command) => { 
  ${command} = _command;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['SpeechRecognizer_enabledUpdated'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('SpeechRecognizer.enabledUpdated');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('enabledUpdated_enabled'), 'enabled');

        this.setColour('#46258B');
        this.setTooltip('Triggered when speech recognition is enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/SpeechRecognizer.html#.enabledUpdated');
    }
};
javascript.javascriptGenerator.forBlock['SpeechRecognizer_enabledUpdated'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `SpeechRecognizer.enabledUpdated.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-FarGrab'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-FarGrab')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('otherID') 
            .setCheck('Uuid')
            .appendField('otherID');
        this.appendValueInput('otherJointIndex') 
            .setCheck('Uuid')
            .appendField('otherJointIndex');
        this.appendValueInput('targetPosition') 
            .setCheck('Vec3')
            .appendField('targetPosition');
        this.appendValueInput('targetRotation') 
            .setCheck('Quat')
            .appendField('targetRotation');
        this.appendValueInput('linearTimeScale') 
            .setCheck('Number')
            .appendField('linearTimeScale');
        this.appendValueInput('angularTimeScale') 
            .setCheck('Number')
            .appendField('angularTimeScale');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"far-grab"</code> {@link Entities.ActionType|ActionType} moves and rotates an entity to a target position and orientation, optionally relative to another entity. Collisions between the entity and the user\'s avatar are disabled during the far-grab.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-FarGrab');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-FarGrab'] = (block, generator) => {
    const _otherID = dfv(generator.valueToCode(block, 'otherID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _otherJointIndex = dfv(generator.valueToCode(block, 'otherJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _targetPosition = dfv(generator.valueToCode(block, 'targetPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _targetRotation = dfv(generator.valueToCode(block, 'targetRotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _linearTimeScale = dfv(generator.valueToCode(block, 'linearTimeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `3.4E+38`);
    const _angularTimeScale = dfv(generator.valueToCode(block, 'angularTimeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `3.4E+38`);

    return [`new Entities.ActionArguments-FarGrab(${_otherID},${_otherJointIndex},${_targetPosition},${_targetRotation},${_linearTimeScale},${_angularTimeScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-Hold'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-Hold')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('holderID') 
            .setCheck('Uuid')
            .appendField('holderID');
        this.appendValueInput('hand') 
            .setCheck('String')
            .appendField('hand');
        this.appendValueInput('relativePosition') 
            .setCheck('Vec3')
            .appendField('relativePosition');
        this.appendValueInput('relativeRotation') 
            .setCheck('Vec3')
            .appendField('relativeRotation');
        this.appendValueInput('timeScale') 
            .setCheck('Number')
            .appendField('timeScale');
        this.appendValueInput('kinematic') 
            .setCheck('Boolean')
            .appendField('kinematic');
        this.appendValueInput('kinematicSetVelocity') 
            .setCheck('Boolean')
            .appendField('kinematicSetVelocity');
        this.appendValueInput('ignoreIK') 
            .setCheck('Boolean')
            .appendField('ignoreIK');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"hold"</code> {@link Entities.ActionType|ActionType} positions and rotates an entity relative to an avatar\'s hand. Collisions between the entity and the user\'s avatar are disabled during the hold.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-Hold');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-Hold'] = (block, generator) => {
    const _holderID = dfv(generator.valueToCode(block, 'holderID', javascript.javascriptGenerator.ORDER_ATOMIC), `MyAvatar.sessionUUID`);
    const _hand = dfv(generator.valueToCode(block, 'hand', javascript.javascriptGenerator.ORDER_ATOMIC), `right`);
    const _relativePosition = dfv(generator.valueToCode(block, 'relativePosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _relativeRotation = dfv(generator.valueToCode(block, 'relativeRotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _timeScale = dfv(generator.valueToCode(block, 'timeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `3.4E+38`);
    const _kinematic = dfv(generator.valueToCode(block, 'kinematic', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _kinematicSetVelocity = dfv(generator.valueToCode(block, 'kinematicSetVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _ignoreIK = dfv(generator.valueToCode(block, 'ignoreIK', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.ActionArguments-Hold(${_holderID},${_hand},${_relativePosition},${_relativeRotation},${_timeScale},${_kinematic},${_kinematicSetVelocity},${_ignoreIK})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AvatarManager_PalData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.PalData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('sessionUUID') 
            .setCheck('Uuid')
            .appendField('sessionUUID');
        this.appendValueInput('sessionDisplayName') 
            .setCheck('String')
            .appendField('sessionDisplayName');
        this.appendValueInput('audioLoudness') 
            .setCheck('Number')
            .appendField('audioLoudness');
        this.appendValueInput('isReplicated') 
            .setCheck('Boolean')
            .appendField('isReplicated');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('palOrbOffset') 
            .setCheck('Number')
            .appendField('palOrbOffset');
        this.setColour('#956F41');
        this.setTooltip('PAL (People Access List) data for an avatar.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.PalData');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_PalData'] = (block, generator) => {
    const _sessionUUID = dfv(generator.valueToCode(block, 'sessionUUID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _sessionDisplayName = dfv(generator.valueToCode(block, 'sessionDisplayName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _audioLoudness = dfv(generator.valueToCode(block, 'audioLoudness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _isReplicated = dfv(generator.valueToCode(block, 'isReplicated', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _palOrbOffset = dfv(generator.valueToCode(block, 'palOrbOffset', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new AvatarManager.PalData(${_sessionUUID},${_sessionDisplayName},${_audioLoudness},${_isReplicated},${_position},${_palOrbOffset})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['AvatarManager_getAvatarIdentifiers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getAvatarIdentifiers')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#956F41');
        this.setTooltip('Gets the IDs of all avatars known about in the domain.Your own avatar is included in the list as a <code>null</code> value.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getAvatarIdentifiers');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getAvatarIdentifiers'] = (block, generator) => {

return [`AvatarManager.getAvatarIdentifiers()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_getAvatarsInRange'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getAvatarsInRange')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('range') 
            .setCheck('Number')
            .appendField('range');

        this.setColour('#956F41');
        this.setTooltip('Gets the IDs of all avatars known about within a specified distance from a point.Your own avatar\'s ID is included in the list if it is in range.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getAvatarsInRange');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getAvatarsInRange'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _range = dfv(generator.valueToCode(block, 'range', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`AvatarManager.getAvatarsInRange(${_position},${_range})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_getAvatarDataRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getAvatarDataRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');
        this.appendValueInput('rateName') 
            .setCheck('AvatarDataRate')
            .appendField('rateName');

        this.setColour('#956F41');
        this.setTooltip('Gets the amount of avatar mixer data being generated by an avatar other than your own.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getAvatarDataRate');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getAvatarDataRate'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`AvatarManager.getAvatarDataRate(${_sessionID},${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_getAvatarUpdateRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getAvatarUpdateRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');
        this.appendValueInput('rateName') 
            .setCheck('AvatarUpdateRate')
            .appendField('rateName');

        this.setColour('#956F41');
        this.setTooltip('Gets the update rate of avatar mixer data being generated by an avatar other than your own.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getAvatarUpdateRate');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getAvatarUpdateRate'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`AvatarManager.getAvatarUpdateRate(${_sessionID},${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_getAvatarSimulationRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getAvatarSimulationRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');
        this.appendValueInput('rateName') 
            .setCheck('AvatarSimulationRate')
            .appendField('rateName');

        this.setColour('#956F41');
        this.setTooltip('Gets the simulation rate of an avatar other than your own.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getAvatarSimulationRate');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getAvatarSimulationRate'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`AvatarManager.getAvatarSimulationRate(${_sessionID},${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_findRayIntersection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.findRayIntersection')
        // Returns data
        this.setOutput(true, '["RayToAvatarIntersectionResult"]');

        // Params data
        this.appendValueInput('ray') 
            .setCheck('PickRay')
            .appendField('ray');
        this.appendValueInput('avatarsToInclude') 
            .setCheck('Array')
            .appendField('avatarsToInclude');
        this.appendValueInput('avatarsToDiscard') 
            .setCheck('Array')
            .appendField('avatarsToDiscard');
        this.appendValueInput('pickAgainstMesh') 
            .setCheck('Boolean')
            .appendField('pickAgainstMesh');

        this.setColour('#956F41');
        this.setTooltip('Find the first avatar intersected by a {@link PickRay}.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.findRayIntersection');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_findRayIntersection'] = (block, generator) => {
    const _ray = dfv(generator.valueToCode(block, 'ray', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _avatarsToInclude = dfv(generator.valueToCode(block, 'avatarsToInclude', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _avatarsToDiscard = dfv(generator.valueToCode(block, 'avatarsToDiscard', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _pickAgainstMesh = dfv(generator.valueToCode(block, 'pickAgainstMesh', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

return [`AvatarManager.findRayIntersection(${_ray},${_avatarsToInclude},${_avatarsToDiscard},${_pickAgainstMesh})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_getPalData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getPalData')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('avatarIDs') 
            .setCheck('Array')
            .appendField('avatarIDs');

        this.setColour('#956F41');
        this.setTooltip('Gets PAL (People Access List) data for one or more avatars. Using this method is faster than iterating over each avatar and obtaining data about each individually.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getPalData');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getPalData'] = (block, generator) => {
    const _avatarIDs = dfv(generator.valueToCode(block, 'avatarIDs', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);

return [`AvatarManager.getPalData(${_avatarIDs})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarManager_setEnableDebugDrawOtherSkeletons'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.setEnableDebugDrawOtherSkeletons')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#956F41');
        this.setTooltip('Displays other avatars skeletons debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.setEnableDebugDrawOtherSkeletons');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_setEnableDebugDrawOtherSkeletons'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `AvatarManager.setEnableDebugDrawOtherSkeletons(${_enabled});\n`;};


// Blockly typedef
Blockly.Blocks['MyAvatar_AvatarEntityData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.AvatarEntityData')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>Information about an avatar entity.</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>id</code></td><td>Uuid</td><td>Entity ID.</td></tr>    <tr><td><code>properties</code></td><td>{@link Entities.EntityProperties}</td><td>Entity properties.</td></tr>   </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.AvatarEntityData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_AvatarEntityData'] = (block, generator) => {

    return [`new MyAvatar.AvatarEntityData()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_GoToProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.GoToProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.setColour('#DC476E');
        this.setTooltip('A teleport target.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.GoToProperties');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_GoToProperties'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new MyAvatar.GoToProperties(${_position},${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_CollisionCapsule'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.CollisionCapsule')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('start') 
            .setCheck('Vec3')
            .appendField('start');
        this.appendValueInput('end') 
            .setCheck('Vec3')
            .appendField('end');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.setColour('#DC476E');
        this.setTooltip('A collision capsule is a cylinder with hemispherical ends. It is often used to approximate the extents of an avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.CollisionCapsule');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_CollisionCapsule'] = (block, generator) => {
    const _start = dfv(generator.valueToCode(block, 'start', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _end = dfv(generator.valueToCode(block, 'end', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new MyAvatar.CollisionCapsule(${_start},${_end},${_radius})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_FlowPhysicsOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.FlowPhysicsOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('active') 
            .setCheck('Boolean')
            .appendField('active');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('gravity') 
            .setCheck('Number')
            .appendField('gravity');
        this.appendValueInput('inertia') 
            .setCheck('Number')
            .appendField('inertia');
        this.appendValueInput('damping') 
            .setCheck('Number')
            .appendField('damping');
        this.appendValueInput('stiffness') 
            .setCheck('Number')
            .appendField('stiffness');
        this.appendValueInput('delta') 
            .setCheck('Number')
            .appendField('delta');
        this.setColour('#DC476E');
        this.setTooltip('Physics options to use in the flow simulation of a joint.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.FlowPhysicsOptions');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_FlowPhysicsOptions'] = (block, generator) => {
    const _active = dfv(generator.valueToCode(block, 'active', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0.01`);
    const _gravity = dfv(generator.valueToCode(block, 'gravity', javascript.javascriptGenerator.ORDER_ATOMIC), `-0.0096`);
    const _inertia = dfv(generator.valueToCode(block, 'inertia', javascript.javascriptGenerator.ORDER_ATOMIC), `0.8`);
    const _damping = dfv(generator.valueToCode(block, 'damping', javascript.javascriptGenerator.ORDER_ATOMIC), `0.85`);
    const _stiffness = dfv(generator.valueToCode(block, 'stiffness', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _delta = dfv(generator.valueToCode(block, 'delta', javascript.javascriptGenerator.ORDER_ATOMIC), `0.55`);

    return [`new MyAvatar.FlowPhysicsOptions(${_active},${_radius},${_gravity},${_inertia},${_damping},${_stiffness},${_delta})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_FlowCollisionsOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.FlowCollisionsOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('String')
            .appendField('type');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('offset') 
            .setCheck('Number')
            .appendField('offset');
        this.setColour('#DC476E');
        this.setTooltip('Collision options to use in the flow simulation of a joint.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.FlowCollisionsOptions');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_FlowCollisionsOptions'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), `"sphere"`);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0.05`);
    const _offset = dfv(generator.valueToCode(block, 'offset', javascript.javascriptGenerator.ORDER_ATOMIC), `Vec3.ZERO`);

    return [`new MyAvatar.FlowCollisionsOptions(${_type},${_radius},${_offset})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_FlowData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.FlowData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('initialized') 
            .setCheck('Boolean')
            .appendField('initialized');
        this.appendValueInput('active') 
            .setCheck('Boolean')
            .appendField('active');
        this.appendValueInput('colliding') 
            .setCheck('Boolean')
            .appendField('colliding');
        this.appendValueInput('physicsData') 
            .setCheck('Object.<GroupName, MyAvatar.FlowPhysicsData>')
            .appendField('physicsData');
        this.appendValueInput('collisions') 
            .setCheck('Object.<JointName, MyAvatar.FlowCollisionsData>')
            .appendField('collisions');
        this.appendValueInput('threads') 
            .setCheck('Array')
            .appendField('threads');
        this.setColour('#DC476E');
        this.setTooltip('Flow options currently used in flow simulation.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.FlowData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_FlowData'] = (block, generator) => {
    const _initialized = dfv(generator.valueToCode(block, 'initialized', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _active = dfv(generator.valueToCode(block, 'active', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _colliding = dfv(generator.valueToCode(block, 'colliding', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _physicsData = dfv(generator.valueToCode(block, 'physicsData', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _collisions = dfv(generator.valueToCode(block, 'collisions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _threads = dfv(generator.valueToCode(block, 'threads', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new MyAvatar.FlowData(${_initialized},${_active},${_colliding},${_physicsData},${_collisions},${_threads})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_FlowPhysicsData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.FlowPhysicsData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('active') 
            .setCheck('Boolean')
            .appendField('active');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('gravity') 
            .setCheck('Number')
            .appendField('gravity');
        this.appendValueInput('inertia') 
            .setCheck('Number')
            .appendField('inertia');
        this.appendValueInput('damping') 
            .setCheck('Number')
            .appendField('damping');
        this.appendValueInput('stiffness') 
            .setCheck('Number')
            .appendField('stiffness');
        this.appendValueInput('delta') 
            .setCheck('Number')
            .appendField('delta');
        this.appendValueInput('jointIndices') 
            .setCheck('Array')
            .appendField('jointIndices');
        this.setColour('#DC476E');
        this.setTooltip('A set of physics options currently used in flow simulation.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.FlowPhysicsData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_FlowPhysicsData'] = (block, generator) => {
    const _active = dfv(generator.valueToCode(block, 'active', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _gravity = dfv(generator.valueToCode(block, 'gravity', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _inertia = dfv(generator.valueToCode(block, 'inertia', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _damping = dfv(generator.valueToCode(block, 'damping', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _stiffness = dfv(generator.valueToCode(block, 'stiffness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _delta = dfv(generator.valueToCode(block, 'delta', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _jointIndices = dfv(generator.valueToCode(block, 'jointIndices', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new MyAvatar.FlowPhysicsData(${_active},${_radius},${_gravity},${_inertia},${_damping},${_stiffness},${_delta},${_jointIndices})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_FlowCollisionsData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.FlowCollisionsData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('offset') 
            .setCheck('Number')
            .appendField('offset');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');
        this.setColour('#DC476E');
        this.setTooltip('A set of collision options currently used in flow simulation.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.FlowCollisionsData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_FlowCollisionsData'] = (block, generator) => {
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _offset = dfv(generator.valueToCode(block, 'offset', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new MyAvatar.FlowCollisionsData(${_radius},${_offset},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_LocomotionControlsMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.LocomotionControlsMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>Locomotion control types.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>Default</td><td>Your walking speed is constant; it doesn\'t change depending on how far      forward you push your controller\'s joystick. Fully pushing your joystick forward makes your avatar run.</td></tr>    <tr><td><code>1</code></td><td>Analog</td><td>Your walking speed changes in steps based on how far forward you push your      controller\'s joystick. Fully pushing your joystick forward makes your avatar run.</td></tr>    <tr><td><code>2</code></td><td>AnalogPlus</td><td>Your walking speed changes proportionally to how far forward you push      your controller\'s joystick. Fully pushing your joystick forward makes your avatar run.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.LocomotionControlsMode');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_LocomotionControlsMode'] = (block, generator) => {

    return [`new MyAvatar.LocomotionControlsMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['MyAvatar_position'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.position')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The position of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.position');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_position'] = (block, generator) => {
    return [`MyAvatar.position`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_scale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.scale')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The scale of the avatar. The value can be set to anything between <code>0.005</code> and    <code>1000.0</code>. When the scale value is fetched, it may temporarily be further limited by the domain\'s settings.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.scale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_scale'] = (block, generator) => {
    return [`MyAvatar.scale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_density'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.density')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The density of the avatar in kg/m<sup>3</sup>. The density is used to work out its mass in    the application of physics. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.density');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_density'] = (block, generator) => {
    return [`MyAvatar.density`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_handPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.handPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('A user-defined hand position, in world coordinates. The position moves with the avatar   but is otherwise not used or changed by Interface.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.handPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_handPosition'] = (block, generator) => {
    return [`MyAvatar.handPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_bodyYaw'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.bodyYaw')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The left or right rotation about an axis running from the head to the feet of the avatar.    Yaw is sometimes called "heading".');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.bodyYaw');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_bodyYaw'] = (block, generator) => {
    return [`MyAvatar.bodyYaw`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_bodyPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.bodyPitch')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation about an axis running from shoulder to shoulder of the avatar. Pitch is    sometimes called "elevation".');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.bodyPitch');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_bodyPitch'] = (block, generator) => {
    return [`MyAvatar.bodyPitch`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_bodyRoll'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.bodyRoll')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation about an axis running from the chest to the back of the avatar. Roll is    sometimes called "bank".');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.bodyRoll');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_bodyRoll'] = (block, generator) => {
    return [`MyAvatar.bodyRoll`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_orientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.orientation')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The orientation of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.orientation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_orientation'] = (block, generator) => {
    return [`MyAvatar.orientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_headOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.headOrientation')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The orientation of the avatar\'s head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.headOrientation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_headOrientation'] = (block, generator) => {
    return [`MyAvatar.headOrientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_headPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.headPitch')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation about an axis running from ear to ear of the avatar\'s head. Pitch is    sometimes called "elevation".');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.headPitch');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_headPitch'] = (block, generator) => {
    return [`MyAvatar.headPitch`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_headYaw'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.headYaw')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation left or right about an axis running from the base to the crown of the avatar\'s    head. Yaw is sometimes called "heading".');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.headYaw');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_headYaw'] = (block, generator) => {
    return [`MyAvatar.headYaw`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_headRoll'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.headRoll')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation about an axis running from the nose to the back of the avatar\'s head. Roll is    sometimes called "bank".');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.headRoll');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_headRoll'] = (block, generator) => {
    return [`MyAvatar.headRoll`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_velocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.velocity')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The current velocity of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.velocity');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_velocity'] = (block, generator) => {
    return [`MyAvatar.velocity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_angularVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.angularVelocity')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The current angular velocity of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.angularVelocity');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_angularVelocity'] = (block, generator) => {
    return [`MyAvatar.angularVelocity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_audioLoudness'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.audioLoudness')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The instantaneous loudness of the audio input that the avatar is injecting into the    domain.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioLoudness');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioLoudness'] = (block, generator) => {
    return [`MyAvatar.audioLoudness`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_audioAverageLoudness'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.audioAverageLoudness')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rolling average loudness of the audio input that the avatar is injecting    into the domain.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioAverageLoudness');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioAverageLoudness'] = (block, generator) => {
    return [`MyAvatar.audioAverageLoudness`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_displayName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.displayName')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The avatar\'s display name.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.displayName');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_displayName'] = (block, generator) => {
    return [`MyAvatar.displayName`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_sessionDisplayName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.sessionDisplayName')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>displayName\'s</code> sanitized and default version defined by the avatar    mixer rather than Interface clients. The result is unique among all avatars present in the domain at the time.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sessionDisplayName');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sessionDisplayName'] = (block, generator) => {
    return [`MyAvatar.sessionDisplayName`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_lookAtSnappingEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.lookAtSnappingEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if the avatar\'s eyes snap to look at another avatar\'s    eyes when the other avatar is in the line of sight and also has <code>lookAtSnappingEnabled == true</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.lookAtSnappingEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_lookAtSnappingEnabled'] = (block, generator) => {
    return [`MyAvatar.lookAtSnappingEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_skeletonModelURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.skeletonModelURL')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The avatar\'s FST file.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.skeletonModelURL');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_skeletonModelURL'] = (block, generator) => {
    return [`MyAvatar.skeletonModelURL`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_attachmentData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.attachmentData')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Information on the avatar\'s attachments.    <p class="important">Deprecated: This property is deprecated and will be removed. Use avatar entities instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.attachmentData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_attachmentData'] = (block, generator) => {
    return [`MyAvatar.attachmentData`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_jointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.jointNames')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The list of joints in the current avatar model. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.jointNames');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_jointNames'] = (block, generator) => {
    return [`MyAvatar.jointNames`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_sessionUUID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.sessionUUID')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Unique ID of the avatar in the domain. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sessionUUID');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sessionUUID'] = (block, generator) => {
    return [`MyAvatar.sessionUUID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_sensorToWorldMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.sensorToWorldMatrix')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The scale, rotation, and translation transform from the user\'s real world to the    avatar\'s size, orientation, and position in the virtual world. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sensorToWorldMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sensorToWorldMatrix'] = (block, generator) => {
    return [`MyAvatar.sensorToWorldMatrix`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_controllerLeftHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.controllerLeftHandMatrix')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation and translation of the left hand controller relative to the    avatar. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.controllerLeftHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_controllerLeftHandMatrix'] = (block, generator) => {
    return [`MyAvatar.controllerLeftHandMatrix`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_controllerRightHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.controllerRightHandMatrix')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The rotation and translation of the right hand controller relative to the    avatar. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.controllerRightHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_controllerRightHandMatrix'] = (block, generator) => {
    return [`MyAvatar.controllerRightHandMatrix`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_sensorToWorldScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.sensorToWorldScale')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The scale that transforms dimensions in the user\'s real world to the avatar\'s    size in the virtual world. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sensorToWorldScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sensorToWorldScale'] = (block, generator) => {
    return [`MyAvatar.sensorToWorldScale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hasPriority'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hasPriority')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if the avatar is in a "hero" zone, <code>false</code> if it isn\'t.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hasPriority');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hasPriority'] = (block, generator) => {
    return [`MyAvatar.hasPriority`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hasScriptedBlendshapes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hasScriptedBlendshapes')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if blend shapes are controlled by scripted actions,    otherwise <code>false</code>. Set this to <code>true</code> before using the {@link MyAvatar.setBlendshape} method,    and set back to <code>false</code> after you no longer want scripted control over the blend shapes.    <p><strong>Note:</strong> This property will automatically be set to <code>true</code> if the controller system has    valid facial blend shape actions.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hasScriptedBlendshapes');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hasScriptedBlendshapes'] = (block, generator) => {
    return [`MyAvatar.hasScriptedBlendshapes`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hasProceduralBlinkFaceMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hasProceduralBlinkFaceMovement')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if avatars blink automatically by animating    facial blend shapes, <code>false</code> if automatic blinking is disabled. Set to <code>false</code> to fully control    the blink facial blend shapes via the {@link MyAvatar.setBlendshape} method.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hasProceduralBlinkFaceMovement');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hasProceduralBlinkFaceMovement'] = (block, generator) => {
    return [`MyAvatar.hasProceduralBlinkFaceMovement`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hasProceduralEyeFaceMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hasProceduralEyeFaceMovement')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if the facial blend shapes for an avatar\'s eyes    adjust automatically as the eyes move, <code>false</code> if this automatic movement is disabled. Set this property    to <code>true</code> to prevent the iris from being obscured by the upper or lower lids. Set to <code>false</code> to    fully control the eye blend shapes via the {@link MyAvatar.setBlendshape} method.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hasProceduralEyeFaceMovement');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hasProceduralEyeFaceMovement'] = (block, generator) => {
    return [`MyAvatar.hasProceduralEyeFaceMovement`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hasAudioEnabledFaceMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hasAudioEnabledFaceMovement')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if the avatar\'s mouth blend shapes animate    automatically based on detected microphone input, <code>false</code> if this automatic movement is disabled. Set    this property to <code>false</code> to fully control the mouth facial blend shapes via the    {@link MyAvatar.setBlendshape} method.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hasAudioEnabledFaceMovement');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hasAudioEnabledFaceMovement'] = (block, generator) => {
    return [`MyAvatar.hasAudioEnabledFaceMovement`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_skeletonOffset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.skeletonOffset')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Can be used to apply a translation offset between the avatar\'s position and the    registration point of the 3D model.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.skeletonOffset');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_skeletonOffset'] = (block, generator) => {
    return [`MyAvatar.skeletonOffset`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_qmlPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.qmlPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('A synonym for <code>position</code> for use by QML.    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.qmlPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_qmlPosition'] = (block, generator) => {
    return [`MyAvatar.qmlPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_feetPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.feetPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The position of the avatar\'s feet.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.feetPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_feetPosition'] = (block, generator) => {
    return [`MyAvatar.feetPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_shouldRenderLocally'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.shouldRenderLocally')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('If <code>true</code> then your avatar is rendered for you in Interface,    otherwise it is not rendered for you (but it is still rendered for other users).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.shouldRenderLocally');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_shouldRenderLocally'] = (block, generator) => {
    return [`MyAvatar.shouldRenderLocally`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_motorVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.motorVelocity')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The target velocity of your avatar to be achieved by a scripted motor.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.motorVelocity');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_motorVelocity'] = (block, generator) => {
    return [`MyAvatar.motorVelocity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_motorTimescale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.motorTimescale')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The timescale for the scripted motor to achieve the target    <code>motorVelocity</code> avatar velocity. Smaller values result in higher acceleration.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.motorTimescale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_motorTimescale'] = (block, generator) => {
    return [`MyAvatar.motorTimescale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_motorReferenceFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.motorReferenceFrame')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Reference frame of the <code>motorVelocity</code>. Must be one of the    following: <code>"camera"</code>, <code>"avatar"</code>, and <code>"world"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.motorReferenceFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_motorReferenceFrame'] = (block, generator) => {
    return [`MyAvatar.motorReferenceFrame`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_motorMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.motorMode')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The Type of scripted motor behavior: <code>"simple"</code> to use the    <code>motorTimescale</code> time scale; <code>"dynamic"</code> to use character controller timescales.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.motorMode');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_motorMode'] = (block, generator) => {
    return [`MyAvatar.motorMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_collisionSoundURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.collisionSoundURL')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The sound that\'s played when the avatar experiences a    collision. It can be a mono or stereo 16-bit WAV file running at either 24kHz or 48kHz. The latter is down-sampled    by the audio mixer, so all audio effectively plays back at a 24khz. 48kHz RAW files are also supported.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.collisionSoundURL');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_collisionSoundURL'] = (block, generator) => {
    return [`MyAvatar.collisionSoundURL`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_audioListenerMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.audioListenerMode')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Specifies the listening position when hearing spatialized audio. Must be one    of the following property values:    <ul>        <li><code>MyAvatar.audioListenerModeHead</code></li>        <li><code>MyAvatar.audioListenerModeCamera</code></li>        <li><code>MyAvatar.audioListenerModeCustom</code></li>    </ul>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioListenerMode');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioListenerMode'] = (block, generator) => {
    return [`MyAvatar.audioListenerMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_audioListenerModeHead'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.audioListenerModeHead')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The audio listening position is at the avatar\'s head. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioListenerModeHead');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioListenerModeHead'] = (block, generator) => {
    return [`MyAvatar.audioListenerModeHead`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_audioListenerModeCamera'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.audioListenerModeCamera')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The audio listening position is at the camera. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioListenerModeCamera');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioListenerModeCamera'] = (block, generator) => {
    return [`MyAvatar.audioListenerModeCamera`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_audioListenerModeCustom'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.audioListenerModeCustom')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The audio listening position is at a the position specified by set by the    <code>customListenPosition</code> and <code>customListenOrientation</code> property values. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioListenerModeCustom');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioListenerModeCustom'] = (block, generator) => {
    return [`MyAvatar.audioListenerModeCustom`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_customListenPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.customListenPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The listening position used when the <code>audioListenerMode</code>    property value is <code>audioListenerModeCustom</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.customListenPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_customListenPosition'] = (block, generator) => {
    return [`MyAvatar.customListenPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_customListenOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.customListenOrientation')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The listening orientation used when the    <code>audioListenerMode</code> property value is <code>audioListenerModeCustom</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.customListenOrientation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_customListenOrientation'] = (block, generator) => {
    return [`MyAvatar.customListenOrientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_rotationRecenterFilterLength'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.rotationRecenterFilterLength')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Configures how quickly the avatar root rotates to recenter its facing    direction to match that of the user\'s torso based on head and hands orientation. A smaller value makes the    recentering happen more quickly. The minimum value is <code>0.01</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.rotationRecenterFilterLength');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_rotationRecenterFilterLength'] = (block, generator) => {
    return [`MyAvatar.rotationRecenterFilterLength`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_rotationThreshold'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.rotationThreshold')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The angle in radians that the user\'s torso facing direction (based on head and    hands orientation) can differ from that of the avatar before the avatar\'s root is rotated to match the user\'s torso.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.rotationThreshold');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_rotationThreshold'] = (block, generator) => {
    return [`MyAvatar.rotationThreshold`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_enableStepResetRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.enableStepResetRotation')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('If <code>true</code> then after the user\'s avatar takes a step, the    avatar\'s root immediately rotates to recenter its facing direction to match that of the user\'s torso based on head    and hands orientation.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.enableStepResetRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_enableStepResetRotation'] = (block, generator) => {
    return [`MyAvatar.enableStepResetRotation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_enableDrawAverageFacing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.enableDrawAverageFacing')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('If <code>true</code>, debug graphics are drawn that show the average    facing direction of the user\'s torso (based on head and hands orientation). This can be useful if you want to try    out different filter lengths and thresholds.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.enableDrawAverageFacing');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_enableDrawAverageFacing'] = (block, generator) => {
    return [`MyAvatar.enableDrawAverageFacing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_leftHandPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.leftHandPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The position of the left hand in avatar coordinates if it\'s being positioned by    controllers, otherwise {@link Vec3|Vec3.ZERO}. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.leftHandPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_leftHandPosition'] = (block, generator) => {
    return [`MyAvatar.leftHandPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_rightHandPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.rightHandPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The position of the right hand in avatar coordinates if it\'s being positioned by    controllers, otherwise {@link Vec3|Vec3.ZERO}. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.rightHandPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_rightHandPosition'] = (block, generator) => {
    return [`MyAvatar.rightHandPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_leftHandTipPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.leftHandTipPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The position 0.3m in front of the left hand\'s position, in the direction along the    palm, in avatar coordinates. If the hand isn\'t being positioned by a controller, the value is    {@link Vec3|Vec3.ZERO}. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.leftHandTipPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_leftHandTipPosition'] = (block, generator) => {
    return [`MyAvatar.leftHandTipPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_rightHandTipPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.rightHandTipPosition')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The position 0.3m in front of the right hand\'s position, in the direction along    the palm, in avatar coordinates. If the hand isn\'t being positioned by a controller, the value is    {@link Vec3|Vec3.ZERO}. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.rightHandTipPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_rightHandTipPosition'] = (block, generator) => {
    return [`MyAvatar.rightHandTipPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_leftHandPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.leftHandPose')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The left hand\'s pose as determined by the hand controllers, relative to the avatar.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.leftHandPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_leftHandPose'] = (block, generator) => {
    return [`MyAvatar.leftHandPose`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_rightHandPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.rightHandPose')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The right hand\'s pose as determined by the hand controllers, relative to the avatar.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.rightHandPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_rightHandPose'] = (block, generator) => {
    return [`MyAvatar.rightHandPose`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_leftHandTipPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.leftHandTipPose')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The left hand\'s pose as determined by the hand controllers, relative to the avatar,    with the position adjusted by 0.3m along the direction of the palm. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.leftHandTipPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_leftHandTipPose'] = (block, generator) => {
    return [`MyAvatar.leftHandTipPose`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_rightHandTipPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.rightHandTipPose')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The right hand\'s pose as determined by the hand controllers, relative to the avatar,    with the position adjusted by 0.3m along the direction of the palm. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.rightHandTipPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_rightHandTipPose'] = (block, generator) => {
    return [`MyAvatar.rightHandTipPose`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_energy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.energy')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<span class="important">Deprecated: This property will be removed.</span>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.energy');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_energy'] = (block, generator) => {
    return [`MyAvatar.energy`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_isAway'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isAway')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if your avatar is away (i.e., inactive), <code>false</code> if it is    active.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isAway');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isAway'] = (block, generator) => {
    return [`MyAvatar.isAway`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_centerOfGravityModelEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.centerOfGravityModelEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if the avatar hips are placed according to    the center of gravity model that balances the center of gravity over the base of support of the feet. Set the    value to <code>false</code> for default behavior where the hips are positioned under the head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.centerOfGravityModelEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_centerOfGravityModelEnabled'] = (block, generator) => {
    return [`MyAvatar.centerOfGravityModelEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hmdLeanRecenterEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hmdLeanRecenterEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> IF the avatar is re-centered to be under the    head\'s position. In room-scale VR, this behavior is what causes your avatar to follow your HMD as you walk around    the room. Setting the value <code>false</code> is useful if you want to pin the avatar to a fixed position.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hmdLeanRecenterEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hmdLeanRecenterEnabled'] = (block, generator) => {
    return [`MyAvatar.hmdLeanRecenterEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_collisionsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.collisionsEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Set to <code>true</code> to enable the avatar to collide with the environment,    <code>false</code> to disable collisions with the environment. May return <code>true</code> even though the value    was set <code>false</code> because the zone may disallow collisionless avatars.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.collisionsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_collisionsEnabled'] = (block, generator) => {
    return [`MyAvatar.collisionsEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_otherAvatarsCollisionsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.otherAvatarsCollisionsEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Set to <code>true</code> to enable the avatar to collide with other    avatars, <code>false</code> to disable collisions with other avatars.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.otherAvatarsCollisionsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_otherAvatarsCollisionsEnabled'] = (block, generator) => {
    return [`MyAvatar.otherAvatarsCollisionsEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_characterControllerEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.characterControllerEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Synonym of <code>collisionsEnabled</code>.    <p class="important">Deprecated: This property is deprecated and will be removed. Use <code>collisionsEnabled</code>    instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.characterControllerEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_characterControllerEnabled'] = (block, generator) => {
    return [`MyAvatar.characterControllerEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_useAdvancedMovementControls'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.useAdvancedMovementControls')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Returns and sets the value of the Interface setting, Settings >    Controls > Walking. Note: Setting the value has no effect unless Interface is restarted.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.useAdvancedMovementControls');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_useAdvancedMovementControls'] = (block, generator) => {
    return [`MyAvatar.useAdvancedMovementControls`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_showPlayArea'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.showPlayArea')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Returns and sets the value of the Interface setting, Settings > Controls > Show room    boundaries while teleporting.    <p><strong>Note:</strong> Setting the value has no effect unless Interface is restarted.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.showPlayArea');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_showPlayArea'] = (block, generator) => {
    return [`MyAvatar.showPlayArea`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_yawSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.yawSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The mouse X sensitivity value in Settings > General. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.yawSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_yawSpeed'] = (block, generator) => {
    return [`MyAvatar.yawSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_pitchSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.pitchSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The mouse Y sensitivity value in Settings > General. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.pitchSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_pitchSpeed'] = (block, generator) => {
    return [`MyAvatar.pitchSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hmdRollControlEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hmdRollControlEnabled')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('If <code>true</code>, the roll angle of your HMD turns your avatar    while flying.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hmdRollControlEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hmdRollControlEnabled'] = (block, generator) => {
    return [`MyAvatar.hmdRollControlEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hmdRollControlDeadZone'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hmdRollControlDeadZone')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The amount of HMD roll, in degrees, required before your avatar turns if   <code>hmdRollControlEnabled</code> is enabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hmdRollControlDeadZone');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hmdRollControlDeadZone'] = (block, generator) => {
    return [`MyAvatar.hmdRollControlDeadZone`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_hmdRollControlRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hmdRollControlRate')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('If <code>MyAvatar.hmdRollControlEnabled</code> is true, this value determines the    maximum turn rate of your avatar when rolling your HMD in degrees per second.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hmdRollControlRate');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hmdRollControlRate'] = (block, generator) => {
    return [`MyAvatar.hmdRollControlRate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_userHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.userHeight')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The height of the user in sensor space.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.userHeight');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_userHeight'] = (block, generator) => {
    return [`MyAvatar.userHeight`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_userEyeHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.userEyeHeight')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The estimated height of the user\'s eyes in sensor space. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.userEyeHeight');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_userEyeHeight'] = (block, generator) => {
    return [`MyAvatar.userEyeHeight`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_SELF_ID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.SELF_ID')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('UUID representing "my avatar". Only use for local-only entities in situations    where MyAvatar.sessionUUID is not available (e.g., if not connected to a domain). Note: Likely to be deprecated.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.SELF_ID');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_SELF_ID'] = (block, generator) => {
    return [`MyAvatar.SELF_ID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_walkSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.walkSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The walk speed of your avatar for the current control scheme (see    {@link MyAvatar.getControlScheme|getControlScheme}).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.walkSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_walkSpeed'] = (block, generator) => {
    return [`MyAvatar.walkSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_walkBackwardSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.walkBackwardSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The walk backward speed of your avatar for the current control scheme (see    {@link MyAvatar.getControlScheme|getControlScheme}).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.walkBackwardSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_walkBackwardSpeed'] = (block, generator) => {
    return [`MyAvatar.walkBackwardSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_sprintSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.sprintSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The sprint (run) speed of your avatar for the current control scheme (see    {@link MyAvatar.getControlScheme|getControlScheme}).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sprintSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sprintSpeed'] = (block, generator) => {
    return [`MyAvatar.sprintSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_analogPlusWalkSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.analogPlusWalkSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The walk speed of your avatar for the "AnalogPlus" control scheme.    <p><strong>Warning:</strong> Setting this value also sets the value of <code>analogPlusSprintSpeed</code> to twice    the value.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.analogPlusWalkSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_analogPlusWalkSpeed'] = (block, generator) => {
    return [`MyAvatar.analogPlusWalkSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_analogPlusSprintSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.analogPlusSprintSpeed')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('The sprint (run) speed of your avatar for the "AnalogPlus" control scheme.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.analogPlusSprintSpeed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_analogPlusSprintSpeed'] = (block, generator) => {
    return [`MyAvatar.analogPlusSprintSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_userRecenterModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.userRecenterModel')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('Controls avatar leaning and recentering behavior.    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.userRecenterModel');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_userRecenterModel'] = (block, generator) => {
    return [`MyAvatar.userRecenterModel`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_isInSittingState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isInSittingState')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if the user wearing the HMD is determined to be sitting;    <code>false</code> if the user wearing the HMD is determined to be standing.  This can affect whether the avatar    is allowed to stand, lean or recenter its footing, depending on user preferences.    The property value automatically updates as the user sits or stands. Setting the property value overrides the current    sitting / standing state, which is updated when the user next sits or stands.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isInSittingState');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isInSittingState'] = (block, generator) => {
    return [`MyAvatar.isInSittingState`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_isSitStandStateLocked'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isSitStandStateLocked')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> to lock the avatar sitting/standing state, i.e., use this    to disable automatically changing state.    <p class="important">Deprecated: This property is deprecated and will be removed.    See also: <code>getUserRecenterModel</code> and <code>setUserRecenterModel</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isSitStandStateLocked');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isSitStandStateLocked'] = (block, generator) => {
    return [`MyAvatar.isSitStandStateLocked`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MyAvatar_allowTeleporting'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.allowTeleporting')       
        this.setOutput(true, '');
        this.setColour('#DC476E');
        this.setTooltip('<code>true</code> if teleporting is enabled in the Interface settings,    <code>false</code> if it isn\'t. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.allowTeleporting');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_allowTeleporting'] = (block, generator) => {
    return [`MyAvatar.allowTeleporting`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_TRANSLATE_X'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.TRANSLATE_X')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Move the user\'s avatar in the direction of its x-axis, if the camera isn\'t in    independent or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.TRANSLATE_X');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_TRANSLATE_X'] = (block, generator) => {
    return [`DriveKeys.TRANSLATE_X`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_TRANSLATE_Y'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.TRANSLATE_Y')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Move the user\'s avatar in the direction of its y-axis, if the camera isn\'t in    independent or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.TRANSLATE_Y');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_TRANSLATE_Y'] = (block, generator) => {
    return [`DriveKeys.TRANSLATE_Y`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_TRANSLATE_Z'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.TRANSLATE_Z')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Move the user\'s avatar in the direction of its z-axis, if the camera isn\'t in    independent or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.TRANSLATE_Z');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_TRANSLATE_Z'] = (block, generator) => {
    return [`DriveKeys.TRANSLATE_Z`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_YAW'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.YAW')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Rotate the user\'s avatar about its y-axis at a rate proportional to the control value, if the    camera isn\'t in independent or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.YAW');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_YAW'] = (block, generator) => {
    return [`DriveKeys.YAW`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_STEP_TRANSLATE_X'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.STEP_TRANSLATE_X')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('No action.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.STEP_TRANSLATE_X');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_STEP_TRANSLATE_X'] = (block, generator) => {
    return [`DriveKeys.STEP_TRANSLATE_X`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_STEP_TRANSLATE_Y'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.STEP_TRANSLATE_Y')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('No action.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.STEP_TRANSLATE_Y');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_STEP_TRANSLATE_Y'] = (block, generator) => {
    return [`DriveKeys.STEP_TRANSLATE_Y`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_STEP_TRANSLATE_Z'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.STEP_TRANSLATE_Z')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('No action.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.STEP_TRANSLATE_Z');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_STEP_TRANSLATE_Z'] = (block, generator) => {
    return [`DriveKeys.STEP_TRANSLATE_Z`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_STEP_YAW'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.STEP_YAW')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Rotate the user\'s avatar about its y-axis in a step increment, if the camera isn\'t in    independent or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.STEP_YAW');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_STEP_YAW'] = (block, generator) => {
    return [`DriveKeys.STEP_YAW`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_PITCH'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.PITCH')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Rotate the user\'s avatar head and attached camera about its negative x-axis (i.e., positive    values pitch down) at a rate proportional to the control value, if the camera isn\'t in HMD, independent, or mirror    modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.PITCH');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_PITCH'] = (block, generator) => {
    return [`DriveKeys.PITCH`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_ZOOM'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.ZOOM')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Zoom the camera in or out.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.ZOOM');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_ZOOM'] = (block, generator) => {
    return [`DriveKeys.ZOOM`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_DELTA_YAW'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.DELTA_YAW')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Rotate the user\'s avatar about its y-axis by an amount proportional to the control value,    if the camera isn\'t in independent or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.DELTA_YAW');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_DELTA_YAW'] = (block, generator) => {
    return [`DriveKeys.DELTA_YAW`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['DriveKeys_DELTA_PITCH'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKeys.DELTA_PITCH')       
        this.setOutput(true, '');
        this.setColour('#FF45A0');
        this.setTooltip('Rotate the user\'s avatar head and attached camera about its negative x-axis (i.e.,    positive values pitch down) by an amount proportional to the control value, if the camera isn\'t in HMD, independent,    or mirror modes.');
        this.setHelpUrl('https://apidocs.overte.org/DriveKeys.html#.DELTA_PITCH');
    }
};
javascript.javascriptGenerator.forBlock['DriveKeys_DELTA_PITCH'] = (block, generator) => {
    return [`DriveKeys.DELTA_PITCH`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly typedef
Blockly.Blocks['DriveKey'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DriveKey')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F49F1E');
        this.setTooltip('<p>Logical keys that drive your avatar and camera.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>{@link DriveKeys|DriveKeys.TRANSLATE_X}</code></td><td>Move the user\'s avatar in the direction of its      x-axis, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.TRANSLATE_Y}</code></td><td>Move the user\'s avatar in the direction of its      -axis, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.TRANSLATE_Z}</code></td><td>Move the user\'s avatar in the direction of its      z-axis, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.YAW}</code></td><td>Rotate the user\'s avatar about its y-axis at a rate      proportional to the control value, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.STEP_TRANSLATE_X}</code></td><td>No action.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.STEP_TRANSLATE_Y}</code></td><td>No action.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.STEP_TRANSLATE_Z}</code></td><td>No action.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.STEP_YAW}</code></td><td>Rotate the user\'s avatar about its y-axis in a      step increment, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.PITCH}</code></td><td>Rotate the user\'s avatar head and attached camera      about its negative x-axis (i.e., positive values pitch down) at a rate proportional to the control value, if the      camera isn\'t in HMD, independent, or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.ZOOM}</code></td><td>Zoom the camera in or out.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.DELTA_YAW}</code></td><td>Rotate the user\'s avatar about its y-axis by an      amount proportional to the control value, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>{@link DriveKeys|DriveKeys.DELTA_PITCH}</code></td><td>Rotate the user\'s avatar head and attached      camera about its negative x-axis (i.e., positive values pitch down) by an amount proportional to the control      value, if the camera isn\'t in HMD, independent, or mirror modes.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/DriveKey');
    }
};
javascript.javascriptGenerator.forBlock['DriveKey'] = (block, generator) => {

    return [`new DriveKey()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_SitStandModelType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.SitStandModelType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>Specifies different avatar leaning and recentering behaviors.</p><p class="important">Deprecated: This type is deprecated and will be removed.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>ForceSit</td><td>Assumes the user is seated in the real world. Disables avatar      leaning regardless of what the avatar is doing in the virtual world (i.e., avatar always recenters).</td></tr>    <tr><td><code>1</code></td><td>ForceStand</td><td>Assumes the user is standing in the real world. Enables avatar      leaning regardless of what the avatar is doing in the virtual world (i.e., avatar leans, then if leans too far it      recenters).</td></tr>    <tr><td><code>2</code></td><td>Auto</td><td>Interface detects when the user is standing or seated in the real world.      Avatar leaning is disabled when the user is sitting (i.e., avatar always recenters), and avatar leaning is enabled      when the user is standing (i.e., avatar leans, then if leans too far it recenters).</td></tr>    <tr><td><code>3</code></td><td>DisableHMDLean</td><td><p>Both avatar leaning and recentering are disabled regardless of      what the user is doing in the real world and no matter what their avatar is doing in the virtual world. Enables      the avatar to sit on the floor when the user sits on the floor.</p>      <p><strong>Note:</strong> Experimental.</p></td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.SitStandModelType');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_SitStandModelType'] = (block, generator) => {

    return [`new MyAvatar.SitStandModelType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['MyAvatar_resetSensorsAndBody'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.resetSensorsAndBody')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Resets the sensor positioning of your HMD (if in use) and recenters your avatar body and head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.resetSensorsAndBody');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_resetSensorsAndBody'] = (block, generator) => {


    return `MyAvatar.resetSensorsAndBody();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_centerBody'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.centerBody')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Moves and orients the avatar, such that it is directly underneath the HMD, with toes pointed forward in the direction ofthe HMD.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.centerBody');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_centerBody'] = (block, generator) => {


    return `MyAvatar.centerBody();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_clearIKJointLimitHistory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.clearIKJointLimitHistory')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Clears inverse kinematics joint limit history.<p>The internal inverse-kinematics system maintains a record of which joints are "locked". Sometimes it is useful toforget this history to prevent contorted joints, e.g., after finishing with an override animation.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.clearIKJointLimitHistory');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_clearIKJointLimitHistory'] = (block, generator) => {


    return `MyAvatar.clearIKJointLimitHistory();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setOrientationVar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setOrientationVar')
        // Returns data

        // Params data
        this.appendValueInput('newOrientationVar') 
            .setCheck('object')
            .appendField('newOrientationVar');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Gets the avatar orientation. Suitable for use in QML.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setOrientationVar');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setOrientationVar'] = (block, generator) => {
    const _newOrientationVar = dfv(generator.valueToCode(block, 'newOrientationVar', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setOrientationVar(${_newOrientationVar});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getOrientationVar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getOrientationVar')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the avatar orientation. Suitable for use in QML.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getOrientationVar');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getOrientationVar'] = (block, generator) => {

return [`MyAvatar.getOrientationVar()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getDefaultEyePosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDefaultEyePosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position in world coordinates of the point directly between your avatar\'s eyes assuming your avatar was in itsdefault pose. This is a reference position; it does not change as your avatar\'s head moves relative to the avatarposition.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDefaultEyePosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDefaultEyePosition'] = (block, generator) => {

return [`MyAvatar.getDefaultEyePosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_overrideAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.overrideAnimation')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('fps') 
            .setCheck('Number')
            .appendField('fps');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('firstFrame') 
            .setCheck('Number')
            .appendField('firstFrame');
        this.appendValueInput('lastFrame') 
            .setCheck('Number')
            .appendField('lastFrame');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Overrides the default avatar animations.<p>The avatar animation system includes a set of default animations along with rules for how those animations are blendedtogether with procedural data (such as look at vectors, hand sensors etc.). <code>overrideAnimation()</code> is used tocompletely override all motion from the default animation system (including inverse kinematics for hand and headcontrollers) and play a set of specified animations. To end these animations and restore the default animations, use{@link MyAvatar.restoreAnimation}.</p><p>Note: When using pre-built animation data, it\'s critical that the joint orientation of the source animation and targetrig are equivalent, since the animation data applies absolute values onto the joints. If the orientations are different,the avatar will move in unpredictable ways. For more information about avatar joint orientation standards, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.overrideAnimation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_overrideAnimation'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fps = dfv(generator.valueToCode(block, 'fps', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _firstFrame = dfv(generator.valueToCode(block, 'firstFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastFrame = dfv(generator.valueToCode(block, 'lastFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.overrideAnimation(${_url},${_fps},${_loop},${_firstFrame},${_lastFrame});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_overrideHandAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.overrideHandAnimation')
        // Returns data

        // Params data
        this.appendValueInput('isLeft') 
            .setCheck('Boolean')
            .appendField('isLeft');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('fps') 
            .setCheck('Number')
            .appendField('fps');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('firstFrame') 
            .setCheck('Number')
            .appendField('firstFrame');
        this.appendValueInput('lastFrame') 
            .setCheck('Number')
            .appendField('lastFrame');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Overrides the default hand poses that are triggered with controller buttons.Use {@link MyAvatar.restoreHandAnimation} to restore the default poses.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.overrideHandAnimation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_overrideHandAnimation'] = (block, generator) => {
    const _isLeft = dfv(generator.valueToCode(block, 'isLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fps = dfv(generator.valueToCode(block, 'fps', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _firstFrame = dfv(generator.valueToCode(block, 'firstFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastFrame = dfv(generator.valueToCode(block, 'lastFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.overrideHandAnimation(${_isLeft},${_url},${_fps},${_loop},${_firstFrame},${_lastFrame});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_restoreAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.restoreAnimation')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Restores the default animations.<p>The avatar animation system includes a set of default animations along with rules for how those animations are blendedtogether with procedural data (such as look at vectors, hand sensors etc.). Playing your own custom animations willoverride the  default animations. <code>restoreAnimation()</code> is used to restore all motion from the defaultanimation system including inverse kinematics for hand and head controllers. If you aren\'t currently playing an overrideanimation, this function has no effect.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.restoreAnimation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_restoreAnimation'] = (block, generator) => {


    return `MyAvatar.restoreAnimation();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_restoreHandAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.restoreHandAnimation')
        // Returns data

        // Params data
        this.appendValueInput('isLeft') 
            .setCheck('Boolean')
            .appendField('isLeft');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Restores the default hand animation state machine that is driven by the state machine in the avatar-animation JSON.<p>The avatar animation system includes a set of default animations along with rules for how those animations are blendedtogether with procedural data (such as look at vectors, hand sensors etc.). Playing your own custom animations willoverride the  default animations. <code>restoreHandAnimation()</code> is used to restore the default hand poses.If you aren\'t currently playing an override hand animation, this function has no effect.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.restoreHandAnimation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_restoreHandAnimation'] = (block, generator) => {
    const _isLeft = dfv(generator.valueToCode(block, 'isLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.restoreHandAnimation(${_isLeft});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getAnimationRoles'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAnimationRoles')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current animation roles.<p>Each avatar has an avatar-animation.json file that defines which animations are used and how they are blended togetherwith procedural data (such as look at vectors, hand sensors etc.). Each animation specified in the avatar-animation.jsonfile is known as an animation role. Animation roles map to easily understandable actions that the avatar can perform,such as <code>"idleStand"</code>, <code>"idleTalk"</code>, or <code>"walkFwd"</code>. <code>getAnimationRoles()</code>is used get the list of animation roles defined in the avatar-animation.json.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAnimationRoles');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAnimationRoles'] = (block, generator) => {

return [`MyAvatar.getAnimationRoles()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_overrideRoleAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.overrideRoleAnimation')
        // Returns data

        // Params data
        this.appendValueInput('role') 
            .setCheck('String')
            .appendField('role');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('fps') 
            .setCheck('Number')
            .appendField('fps');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('firstFrame') 
            .setCheck('Number')
            .appendField('firstFrame');
        this.appendValueInput('lastFrame') 
            .setCheck('Number')
            .appendField('lastFrame');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Overrides a specific animation role.<p>Each avatar has an avatar-animation.json file that defines a set of animation roles. Animation roles map to easilyunderstandable actions that the avatar can perform, such as <code>"idleStand"</code>, <code>"idleTalk"</code>, or<code>"walkFwd"</code>. To get the full list of roles, use {@ link MyAvatar.getAnimationRoles}.For each role, the avatar-animation.json defines when the animation is used, the animation clip (glTF or FBX) used, andhow animations are blended together with procedural data (such as look at vectors, hand sensors etc.).<code>overrideRoleAnimation()</code> is used to change the animation clip (glTF or FBX) associated with a specifiedanimation role. To end the role animation and restore the default, use {@link MyAvatar.restoreRoleAnimation}.</p><p>Note: Hand roles only affect the hand. Other "main" roles, like "idleStand", "idleTalk", and "takeoffStand", are fullbody.</p><p>Note: When using pre-built animation data, it\'s critical that the joint orientation of the source animation and targetrig are equivalent, since the animation data applies absolute values onto the joints. If the orientations are different,the avatar will move in unpredictable ways. For more information about avatar joint orientation standards, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.overrideRoleAnimation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_overrideRoleAnimation'] = (block, generator) => {
    const _role = dfv(generator.valueToCode(block, 'role', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fps = dfv(generator.valueToCode(block, 'fps', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _firstFrame = dfv(generator.valueToCode(block, 'firstFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastFrame = dfv(generator.valueToCode(block, 'lastFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.overrideRoleAnimation(${_role},${_url},${_fps},${_loop},${_firstFrame},${_lastFrame});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_restoreRoleAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.restoreRoleAnimation')
        // Returns data

        // Params data
        this.appendValueInput('role') 
            .setCheck('String')
            .appendField('role');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Restores a default role animation.<p>Each avatar has an avatar-animation.json file that defines a set of animation roles. Animation roles map to easilyunderstandable actions that the avatar can perform, such as <code>"idleStand"</code>, <code>"idleTalk"</code>, or<code>"walkFwd"</code>. To get the full list of roles, use {@link MyAvatar.getAnimationRoles}. For each role,the avatar-animation.json defines when the animation is used, the animation clip (glTF or FBX) used, and how animationsare blended together with procedural data (such as look-at vectors, hand sensors etc.). You can change the animationclip (glTF or FBX) associated with a specified animation role using {@link MyAvatar.overrideRoleAnimation}.<code>restoreRoleAnimation()</code> is used to restore a specified animation role\'s default animation clip. If you havenot specified an override animation for the specified role, this function has no effect.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.restoreRoleAnimation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_restoreRoleAnimation'] = (block, generator) => {
    const _role = dfv(generator.valueToCode(block, 'role', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.restoreRoleAnimation(${_role});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_addAnimationStateHandler'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.addAnimationStateHandler')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendStatementInput('handler')
            .appendField('handler');
        this.appendValueInput('propertiesList') 
            .setCheck('Array')
            .appendField('propertiesList');

        this.setColour('#DC476E');
        this.setTooltip('Adds an animation state handler function that is invoked just before each animation graph update. More than oneanimation state handler function may be added by calling <code>addAnimationStateHandler</code> multiple times. It is notspecified in what order multiple handlers are called.<p>The animation state handler function is called with an {@link MyAvatar.AnimStateDictionary|AnimStateDictionary}"<code>animStateDictionaryIn</code>" parameter and is expected to return an{@link MyAvatar.AnimStateDictionary|AnimStateDictionary} "<code>animStateDictionaryOut</code>" object. The<code>animStateDictionaryOut</code> object can be the same object as <code>animStateDictionaryIn</code>, or it can be adifferent object. The <code>animStateDictionaryIn</code> may be shared among multiple handlers and thus may containadditional properties specified when adding the different handlers.</p><p>A handler may change a value from <code>animStateDictionaryIn</code> or add different values in the<code>animStateDictionaryOut</code> returned. Any property values set in <code>animStateDictionaryOut</code> willoverride those of the internal animation machinery.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.addAnimationStateHandler');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_addAnimationStateHandler'] = (block, generator) => {
    const _handler = generator.statementToCode(block, 'handler');
    const _propertiesList = dfv(generator.valueToCode(block, 'propertiesList', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.addAnimationStateHandler(() => { \n ${_handler} },${_propertiesList})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_removeAnimationStateHandler'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.removeAnimationStateHandler')
        // Returns data

        // Params data
        this.appendValueInput('handler') 
            .setCheck('Number')
            .appendField('handler');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Removes an animation state handler function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.removeAnimationStateHandler');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_removeAnimationStateHandler'] = (block, generator) => {
    const _handler = dfv(generator.valueToCode(block, 'handler', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.removeAnimationStateHandler(${_handler});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getSnapTurn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getSnapTurn')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether you do snap turns in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getSnapTurn');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getSnapTurn'] = (block, generator) => {

return [`MyAvatar.getSnapTurn()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setSnapTurn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setSnapTurn')
        // Returns data

        // Params data
        this.appendValueInput('on') 
            .setCheck('Boolean')
            .appendField('on');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether you do snap turns or smooth turns in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setSnapTurn');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setSnapTurn'] = (block, generator) => {
    const _on = dfv(generator.valueToCode(block, 'on', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setSnapTurn(${_on});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getControlScheme'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getControlScheme')
        // Returns data
        this.setOutput(true, '["MyAvatar.LocomotionControlsMode"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the control scheme that is in use.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getControlScheme');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getControlScheme'] = (block, generator) => {

return [`MyAvatar.getControlScheme()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setControlScheme'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setControlScheme')
        // Returns data

        // Params data
        this.appendValueInput('controlScheme') 
            .setCheck('MyAvatar.LocomotionControlsMode')
            .appendField('controlScheme');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the control scheme to use.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setControlScheme');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setControlScheme'] = (block, generator) => {
    const _controlScheme = dfv(generator.valueToCode(block, 'controlScheme', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setControlScheme(${_controlScheme});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_hoverWhenUnsupported'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.hoverWhenUnsupported')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether your avatar hovers when its feet are not on the ground.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hoverWhenUnsupported');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hoverWhenUnsupported'] = (block, generator) => {

return [`MyAvatar.hoverWhenUnsupported()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setHoverWhenUnsupported'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setHoverWhenUnsupported')
        // Returns data

        // Params data
        this.appendValueInput('hover') 
            .setCheck('Boolean')
            .appendField('hover');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether your avatar hovers when its feet are not on the ground.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setHoverWhenUnsupported');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setHoverWhenUnsupported'] = (block, generator) => {
    const _hover = dfv(generator.valueToCode(block, 'hover', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setHoverWhenUnsupported(${_hover});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setDominantHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDominantHand')
        // Returns data

        // Params data
        this.appendValueInput('hand') 
            .setCheck('String')
            .appendField('hand');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the avatar\'s dominant hand.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDominantHand');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDominantHand'] = (block, generator) => {
    const _hand = dfv(generator.valueToCode(block, 'hand', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setDominantHand(${_hand});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getDominantHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDominantHand')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the avatar\'s dominant hand.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDominantHand');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDominantHand'] = (block, generator) => {

return [`MyAvatar.getDominantHand()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setStrafeEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setStrafeEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether strafing is enabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setStrafeEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setStrafeEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setStrafeEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getStrafeEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getStrafeEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether strafing is enabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getStrafeEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getStrafeEnabled'] = (block, generator) => {

return [`MyAvatar.getStrafeEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setHmdAvatarAlignmentType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setHmdAvatarAlignmentType')
        // Returns data

        // Params data
        this.appendValueInput('type') 
            .setCheck('String')
            .appendField('type');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the HMD alignment relative to your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setHmdAvatarAlignmentType');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setHmdAvatarAlignmentType'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setHmdAvatarAlignmentType(${_type});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getHmdAvatarAlignmentType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHmdAvatarAlignmentType')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the HMD alignment relative to your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHmdAvatarAlignmentType');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHmdAvatarAlignmentType'] = (block, generator) => {

return [`MyAvatar.getHmdAvatarAlignmentType()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setCenterOfGravityModelEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setCenterOfGravityModelEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether the avatar\'s hips are balanced over the feet or positioned under the head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setCenterOfGravityModelEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setCenterOfGravityModelEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setCenterOfGravityModelEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getCenterOfGravityModelEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getCenterOfGravityModelEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether the avatar hips are being balanced over the feet or placed under the head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getCenterOfGravityModelEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getCenterOfGravityModelEnabled'] = (block, generator) => {

return [`MyAvatar.getCenterOfGravityModelEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setHMDLeanRecenterEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setHMDLeanRecenterEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether the avatar\'s position updates to recenter the avatar under the head. In room-scale VR, recenteringcauses your avatar to follow your HMD as you walk around the room. Disabling recentering is useful if you want to pinthe avatar to a fixed position.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setHMDLeanRecenterEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setHMDLeanRecenterEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setHMDLeanRecenterEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getHMDLeanRecenterEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHMDLeanRecenterEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether the avatar\'s position updates to recenter the avatar under the head. In room-scale VR, recenteringcauses your avatar to follow your HMD as you walk around the room.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHMDLeanRecenterEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHMDLeanRecenterEnabled'] = (block, generator) => {

return [`MyAvatar.getHMDLeanRecenterEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_requestEnableHandTouch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.requestEnableHandTouch')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Requests that the hand touch effect is disabled for your avatar. Any resulting change in the status of the hand toucheffect will be signaled by {@link MyAvatar.shouldDisableHandTouchChanged}.<p>The hand touch effect makes the avatar\'s fingers adapt to the shape of any object grabbed, creating the effect thatit is really touching that object.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.requestEnableHandTouch');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_requestEnableHandTouch'] = (block, generator) => {


    return `MyAvatar.requestEnableHandTouch();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_requestDisableHandTouch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.requestDisableHandTouch')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Requests that the hand touch effect is enabled for your avatar. Any resulting change in the status of the hand toucheffect will be signaled by {@link MyAvatar.shouldDisableHandTouchChanged}.<p>The hand touch effect makes the avatar\'s fingers adapt to the shape of any object grabbed, creating the effect thatit is really touching that object.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.requestDisableHandTouch');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_requestDisableHandTouch'] = (block, generator) => {


    return `MyAvatar.requestDisableHandTouch();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_disableHandTouchForID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.disableHandTouchForID')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Disables the hand touch effect on a specific entity.<p>The hand touch effect makes the avatar\'s fingers adapt to the shape of any object grabbed, creating the effect thatit is really touching that object.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.disableHandTouchForID');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_disableHandTouchForID'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.disableHandTouchForID(${_entityID});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_enableHandTouchForID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.enableHandTouchForID')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Enables the hand touch effect on a specific entity.<p>The hand touch effect makes the avatar\'s fingers adapt to the shape of any object grabbed, creating the effect thatit is really touching that object.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.enableHandTouchForID');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_enableHandTouchForID'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.enableHandTouchForID(${_entityID});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getRawDriveKey'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRawDriveKey')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('key') 
            .setCheck('DriveKey')
            .appendField('key');

        this.setColour('#DC476E');
        this.setTooltip('Gets the value of a drive key, regardless of whether it is disabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRawDriveKey');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRawDriveKey'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.getRawDriveKey(${_key})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_disableDriveKey'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.disableDriveKey')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('DriveKey')
            .appendField('key');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Disables the action associated with a drive key.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.disableDriveKey');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_disableDriveKey'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.disableDriveKey(${_key});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_enableDriveKey'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.enableDriveKey')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('DriveKey')
            .appendField('key');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Enables the action associated with a drive key. The action may have been disabled with{@link MyAvatar.disableDriveKey|disableDriveKey}.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.enableDriveKey');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_enableDriveKey'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.enableDriveKey(${_key});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_isDriveKeyDisabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isDriveKeyDisabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('key') 
            .setCheck('DriveKey')
            .appendField('key');

        this.setColour('#DC476E');
        this.setTooltip('Checks whether a drive key is disabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isDriveKeyDisabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isDriveKeyDisabled'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.isDriveKeyDisabled(${_key})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_triggerVerticalRecenter'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.triggerVerticalRecenter')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Recenter the avatar in the vertical direction, if <code>{@link MyAvatar|MyAvatar.hmdLeanRecenterEnabled}</code> is<code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.triggerVerticalRecenter');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_triggerVerticalRecenter'] = (block, generator) => {


    return `MyAvatar.triggerVerticalRecenter();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_triggerHorizontalRecenter'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.triggerHorizontalRecenter')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Recenter the avatar in the horizontal direction, if <code>{@link MyAvatar|MyAvatar.hmdLeanRecenterEnabled}</code> is<code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.triggerHorizontalRecenter');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_triggerHorizontalRecenter'] = (block, generator) => {


    return `MyAvatar.triggerHorizontalRecenter();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_triggerRotationRecenter'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.triggerRotationRecenter')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Recenter the avatar\'s rotation, if <code>{@link MyAvatar|MyAvatar.hmdLeanRecenterEnabled}</code> is <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.triggerRotationRecenter');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_triggerRotationRecenter'] = (block, generator) => {


    return `MyAvatar.triggerRotationRecenter();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_isRecenteringHorizontally'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isRecenteringHorizontally')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether the avatar is configured to keep its center of gravity under its head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isRecenteringHorizontally');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isRecenteringHorizontally'] = (block, generator) => {

return [`MyAvatar.isRecenteringHorizontally()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getHeadPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeadPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current position of the avatar\'s "Head" joint.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeadPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeadPosition'] = (block, generator) => {

return [`MyAvatar.getHeadPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getHeadFinalYaw'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeadFinalYaw')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the yaw of the avatar\'s head relative to its body.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeadFinalYaw');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeadFinalYaw'] = (block, generator) => {

return [`MyAvatar.getHeadFinalYaw()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getHeadFinalRoll'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeadFinalRoll')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the roll of the avatar\'s head relative to its body.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeadFinalRoll');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeadFinalRoll'] = (block, generator) => {

return [`MyAvatar.getHeadFinalRoll()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getHeadFinalPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeadFinalPitch')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the pitch of the avatar\'s head relative to its body.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeadFinalPitch');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeadFinalPitch'] = (block, generator) => {

return [`MyAvatar.getHeadFinalPitch()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getHeadDeltaPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeadDeltaPitch')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('If a face tracker is connected and being used, gets the estimated pitch of the user\'s head scaled. This is scale suchthat the avatar looks at the edge of the view frustum when the user looks at the edge of their screen.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeadDeltaPitch');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeadDeltaPitch'] = (block, generator) => {

return [`MyAvatar.getHeadDeltaPitch()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getEyePosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getEyePosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current position of the point directly between the avatar\'s eyes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getEyePosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getEyePosition'] = (block, generator) => {

return [`MyAvatar.getEyePosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getTargetAvatarPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getTargetAvatarPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the avatar your avatar is currently looking at.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getTargetAvatarPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getTargetAvatarPosition'] = (block, generator) => {

return [`MyAvatar.getTargetAvatarPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getTargetAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getTargetAvatar')
        // Returns data
        this.setOutput(true, '["ScriptAvatar"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets information on the avatar your avatar is currently looking at.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getTargetAvatar');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getTargetAvatar'] = (block, generator) => {

return [`MyAvatar.getTargetAvatar()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getLeftHandPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getLeftHandPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the avatar\'s left hand, relative to the avatar, as positioned by a hand controller (e.g., OculusTouch or Vive).<p>Note: The Leap Motion isn\'t part of the hand controller input system. (Instead, it manipulates the avatar\'s jointsfor hand animation.)</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getLeftHandPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getLeftHandPosition'] = (block, generator) => {

return [`MyAvatar.getLeftHandPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getRightHandPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRightHandPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the avatar\'s right hand, relative to the avatar, as positioned by a hand controller (e.g., OculusTouch or Vive).<p>Note: The Leap Motion isn\'t part of the hand controller input system. (Instead, it manipulates the avatar\'s jointsfor hand animation.)</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRightHandPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRightHandPosition'] = (block, generator) => {

return [`MyAvatar.getRightHandPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getLeftHandTipPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getLeftHandTipPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position 0.3m in front of the left hand\'s position in the direction along the palm, in avatar coordinates, aspositioned by a hand controller.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getLeftHandTipPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getLeftHandTipPosition'] = (block, generator) => {

return [`MyAvatar.getLeftHandTipPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getRightHandTipPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRightHandTipPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position 0.3m in front of the right hand\'s position in the direction along the palm, in avatar coordinates, aspositioned by a hand controller.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRightHandTipPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRightHandTipPosition'] = (block, generator) => {

return [`MyAvatar.getRightHandTipPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getLeftHandPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getLeftHandPose')
        // Returns data
        this.setOutput(true, '["Pose"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the pose (position, rotation, velocity, and angular velocity) of the avatar\'s left hand as positioned by ahand controller (e.g., Oculus Touch or Vive).<p>Note: The Leap Motion isn\'t part of the hand controller input system. (Instead, it manipulates the avatar\'s jointsfor hand animation.) If you are using the Leap Motion, the return value\'s <code>valid</code> property will be<code>false</code> and any pose values returned will not be meaningful.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getLeftHandPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getLeftHandPose'] = (block, generator) => {

return [`MyAvatar.getLeftHandPose()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getRightHandPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRightHandPose')
        // Returns data
        this.setOutput(true, '["Pose"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the pose (position, rotation, velocity, and angular velocity) of the avatar\'s left hand as positioned by ahand controller (e.g., Oculus Touch or Vive).<p>Note: The Leap Motion isn\'t part of the hand controller input system. (Instead, it manipulates the avatar\'s jointsfor hand animation.) If you are using the Leap Motion, the return value\'s <code>valid</code> property will be<code>false</code> and any pose values returned will not be meaningful.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRightHandPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRightHandPose'] = (block, generator) => {

return [`MyAvatar.getRightHandPose()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getLeftHandTipPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getLeftHandTipPose')
        // Returns data
        this.setOutput(true, '["Pose"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the pose (position, rotation, velocity, and angular velocity) of the avatar\'s left hand, relative to the avatar, aspositioned by a hand controller (e.g., Oculus Touch or Vive), and translated 0.3m along the palm.<p>Note: Leap Motion isn\'t part of the hand controller input system. (Instead, it manipulates the avatar\'s jointsfor hand animation.) If you are using Leap Motion, the return value\'s <code>valid</code> property will be<code>false</code> and any pose values returned will not be meaningful.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getLeftHandTipPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getLeftHandTipPose'] = (block, generator) => {

return [`MyAvatar.getLeftHandTipPose()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getRightHandTipPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRightHandTipPose')
        // Returns data
        this.setOutput(true, '["Pose"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the pose (position, rotation, velocity, and angular velocity) of the avatar\'s right hand, relative to the avatar, aspositioned by a hand controller (e.g., Oculus Touch or Vive), and translated 0.3m along the palm.<p>Note: Leap Motion isn\'t part of the hand controller input system. (Instead, it manipulates the avatar\'s jointsfor hand animation.) If you are using Leap Motion, the return value\'s <code>valid</code> property will be<code>false</code> and any pose values returned will not be meaningful.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRightHandTipPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRightHandTipPose'] = (block, generator) => {

return [`MyAvatar.getRightHandTipPose()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_pinJoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.pinJoint')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#DC476E');
        this.setTooltip('Sets and locks a joint\'s position and orientation.<p><strong>Note:</strong> Only works on the hips joint.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.pinJoint');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_pinJoint'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.pinJoint(${_index},${_position},${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_clearPinOnJoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.clearPinOnJoint')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Clears a lock on a joint\'s position and orientation, as set by {@link MyAvatar.pinJoint|pinJoint}.<p><strong>Note:</strong> Only works on the hips joint.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.clearPinOnJoint');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_clearPinOnJoint'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.clearPinOnJoint(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getIKErrorOnLastSolve'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getIKErrorOnLastSolve')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the maximum error distance from the most recent inverse kinematics (IK) solution.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getIKErrorOnLastSolve');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getIKErrorOnLastSolve'] = (block, generator) => {

return [`MyAvatar.getIKErrorOnLastSolve()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_useFullAvatarURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.useFullAvatarURL')
        // Returns data

        // Params data
        this.appendValueInput('fullAvatarURL') 
            .setCheck('String')
            .appendField('fullAvatarURL');
        this.appendValueInput('modelName') 
            .setCheck('String')
            .appendField('modelName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Changes the user\'s avatar and associated descriptive name.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.useFullAvatarURL');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_useFullAvatarURL'] = (block, generator) => {
    const _fullAvatarURL = dfv(generator.valueToCode(block, 'fullAvatarURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _modelName = dfv(generator.valueToCode(block, 'modelName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `MyAvatar.useFullAvatarURL(${_fullAvatarURL},${_modelName});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getFullAvatarURLFromPreferences'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getFullAvatarURLFromPreferences')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the complete URL for the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getFullAvatarURLFromPreferences');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getFullAvatarURLFromPreferences'] = (block, generator) => {

return [`MyAvatar.getFullAvatarURLFromPreferences()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getFullAvatarModelName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getFullAvatarModelName')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the full avatar model name for the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getFullAvatarModelName');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getFullAvatarModelName'] = (block, generator) => {

return [`MyAvatar.getFullAvatarModelName()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAvatarEntitiesVariant'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAvatarEntitiesVariant')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current avatar entity IDs and their properties.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAvatarEntitiesVariant');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAvatarEntitiesVariant'] = (block, generator) => {

return [`MyAvatar.getAvatarEntitiesVariant()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_isFlying'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isFlying')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Checks whether your avatar is flying.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isFlying');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isFlying'] = (block, generator) => {

return [`MyAvatar.isFlying()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_isInAir'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isInAir')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Checks whether your avatar is in the air.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isInAir');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isInAir'] = (block, generator) => {

return [`MyAvatar.isInAir()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setFlyingEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setFlyingEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets your preference for flying in your current desktop or HMD display mode. Note that your ability to fly also dependson whether the domain you\'re in allows you to fly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setFlyingEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setFlyingEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setFlyingEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getFlyingEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getFlyingEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets your preference for flying in your current desktop or HMD display mode. Note that your ability to fly also dependson whether the domain you\'re in allows you to fly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getFlyingEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getFlyingEnabled'] = (block, generator) => {

return [`MyAvatar.getFlyingEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setFlyingDesktopPref'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setFlyingDesktopPref')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets your preference for flying in desktop display mode. Note that your ability to fly also depends on whether the domainyou\'re in allows you to fly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setFlyingDesktopPref');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setFlyingDesktopPref'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setFlyingDesktopPref(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getFlyingDesktopPref'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getFlyingDesktopPref')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets your preference for flying in desktop display mode. Note that your ability to fly also depends on whether the domainyou\'re in allows you to fly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getFlyingDesktopPref');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getFlyingDesktopPref'] = (block, generator) => {

return [`MyAvatar.getFlyingDesktopPref()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setFlyingHMDPref'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setFlyingHMDPref')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets your preference for flying in HMD display mode. Note that your ability to fly also depends on whether the domainyou\'re in allows you to fly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setFlyingHMDPref');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setFlyingHMDPref'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setFlyingHMDPref(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getFlyingHMDPref'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getFlyingHMDPref')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets your preference for flying in HMD display mode. Note that your ability to fly also depends on whether the domainyou\'re in allows you to fly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getFlyingHMDPref');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getFlyingHMDPref'] = (block, generator) => {

return [`MyAvatar.getFlyingHMDPref()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setHandRelativeMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setHandRelativeMovement')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Number')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Set your preference for hand-relative movement.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setHandRelativeMovement');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setHandRelativeMovement'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setHandRelativeMovement(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getHandRelativeMovement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHandRelativeMovement')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get your preference for hand-relative movement.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHandRelativeMovement');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHandRelativeMovement'] = (block, generator) => {

return [`MyAvatar.getHandRelativeMovement()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setDriveGear1'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDriveGear1')
        // Returns data

        // Params data
        this.appendValueInput('shiftPoint') 
            .setCheck('Number')
            .appendField('shiftPoint');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Set the first \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDriveGear1');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDriveGear1'] = (block, generator) => {
    const _shiftPoint = dfv(generator.valueToCode(block, 'shiftPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setDriveGear1(${_shiftPoint});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getDriveGear1'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDriveGear1')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get the first \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDriveGear1');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDriveGear1'] = (block, generator) => {

return [`MyAvatar.getDriveGear1()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setDriveGear2'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDriveGear2')
        // Returns data

        // Params data
        this.appendValueInput('shiftPoint') 
            .setCheck('Number')
            .appendField('shiftPoint');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Set the second \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDriveGear2');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDriveGear2'] = (block, generator) => {
    const _shiftPoint = dfv(generator.valueToCode(block, 'shiftPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setDriveGear2(${_shiftPoint});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getDriveGear2'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDriveGear2')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get the second \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDriveGear2');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDriveGear2'] = (block, generator) => {

return [`MyAvatar.getDriveGear2()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setDriveGear3'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDriveGear3')
        // Returns data

        // Params data
        this.appendValueInput('shiftPoint') 
            .setCheck('Number')
            .appendField('shiftPoint');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Set the third \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDriveGear3');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDriveGear3'] = (block, generator) => {
    const _shiftPoint = dfv(generator.valueToCode(block, 'shiftPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setDriveGear3(${_shiftPoint});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getDriveGear3'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDriveGear3')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get the third \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDriveGear3');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDriveGear3'] = (block, generator) => {

return [`MyAvatar.getDriveGear3()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setDriveGear4'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDriveGear4')
        // Returns data

        // Params data
        this.appendValueInput('shiftPoint') 
            .setCheck('Number')
            .appendField('shiftPoint');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Set the fourth \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDriveGear4');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDriveGear4'] = (block, generator) => {
    const _shiftPoint = dfv(generator.valueToCode(block, 'shiftPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setDriveGear4(${_shiftPoint});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getDriveGear4'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDriveGear4')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get the fourth \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDriveGear4');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDriveGear4'] = (block, generator) => {

return [`MyAvatar.getDriveGear4()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setDriveGear5'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDriveGear5')
        // Returns data

        // Params data
        this.appendValueInput('shiftPoint') 
            .setCheck('Number')
            .appendField('shiftPoint');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Set the fifth \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDriveGear5');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDriveGear5'] = (block, generator) => {
    const _shiftPoint = dfv(generator.valueToCode(block, 'shiftPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setDriveGear5(${_shiftPoint});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getDriveGear5'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDriveGear5')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get the fifth \'shifting point\' for acceleration step function.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDriveGear5');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDriveGear5'] = (block, generator) => {

return [`MyAvatar.getDriveGear5()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAvatarScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAvatarScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the target scale of the avatar. The target scale is the desired scale of the avatar without any restrictions onpermissible scale values imposed by the domain.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAvatarScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAvatarScale'] = (block, generator) => {

return [`MyAvatar.getAvatarScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setAvatarScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setAvatarScale')
        // Returns data

        // Params data
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the target scale of the avatar. The target scale is the desired scale of the avatar without any restrictions onpermissible scale values imposed by the domain.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setAvatarScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setAvatarScale'] = (block, generator) => {
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setAvatarScale(${_scale});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setCollisionsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setCollisionsEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether the avatar should collide with entities.<p><strong>Note:</strong> A <code>false</code> value won\'t disable collisions if the avatar is in a zone that disallowscollisionless avatars. However, the <code>false</code> value will be set so that collisions are disabled as soon as theavatar moves to a position where collisionless avatars are allowed.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setCollisionsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setCollisionsEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setCollisionsEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getCollisionsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getCollisionsEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether the avatar will currently collide with entities.<p><strong>Note:</strong> The avatar will always collide with entities if in a zone that disallows collisionless avatars.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getCollisionsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getCollisionsEnabled'] = (block, generator) => {

return [`MyAvatar.getCollisionsEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setOtherAvatarsCollisionsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setOtherAvatarsCollisionsEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether the avatar should collide with other avatars.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setOtherAvatarsCollisionsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setOtherAvatarsCollisionsEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setOtherAvatarsCollisionsEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getOtherAvatarsCollisionsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getOtherAvatarsCollisionsEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether the avatar will collide with other avatars.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getOtherAvatarsCollisionsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getOtherAvatarsCollisionsEnabled'] = (block, generator) => {

return [`MyAvatar.getOtherAvatarsCollisionsEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getCollisionCapsule'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getCollisionCapsule')
        // Returns data
        this.setOutput(true, '["MyAvatar.CollisionCapsule"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the avatar\'s collision capsule: a cylinder with hemispherical ends that approximates the extents or the avatar.<p><strong>Warning:</strong> The values returned are in world coordinates but aren\'t necessarily up to date with theavatar\'s current position.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getCollisionCapsule');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getCollisionCapsule'] = (block, generator) => {

return [`MyAvatar.getCollisionCapsule()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotation of a joint relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getAbsoluteJointRotationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the translation of a joint relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getAbsoluteJointTranslationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_isUp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isUp')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');

        this.setColour('#DC476E');
        this.setTooltip('Tests whether a vector is pointing in the general direction of the avatar\'s "up" direction (i.e., dot product of vectors    is <code>&gt; 0</code>).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isUp');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isUp'] = (block, generator) => {
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.isUp(${_direction})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_isDown'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isDown')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');

        this.setColour('#DC476E');
        this.setTooltip('Tests whether a vector is pointing in the general direction of the avatar\'s "down" direction (i.e., dot product of    vectors is  <code>&lt; 0</code>).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isDown');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isDown'] = (block, generator) => {
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.isDown(${_direction})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setHeadLookAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setHeadLookAt')
        // Returns data

        // Params data
        this.appendValueInput('lookAtTarget') 
            .setCheck('Vec3')
            .appendField('lookAtTarget');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Turns the avatar\'s head until it faces the target point within a +90/-90 degree range.Once this method is called, API calls have full control of the head for a limited time.If this method is not called for 2 seconds, the engine regains control of the head.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setHeadLookAt');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setHeadLookAt'] = (block, generator) => {
    const _lookAtTarget = dfv(generator.valueToCode(block, 'lookAtTarget', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setHeadLookAt(${_lookAtTarget});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getHeadLookAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeadLookAt')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current target point of the head\'s look direction in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeadLookAt');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeadLookAt'] = (block, generator) => {

return [`MyAvatar.getHeadLookAt()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_releaseHeadLookAtControl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.releaseHeadLookAtControl')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Returns control of the avatar\'s head to the engine, and releases control from API calls.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.releaseHeadLookAtControl');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_releaseHeadLookAtControl'] = (block, generator) => {


    return `MyAvatar.releaseHeadLookAtControl();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEyesLookAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEyesLookAt')
        // Returns data

        // Params data
        this.appendValueInput('lookAtTarget') 
            .setCheck('Vec3')
            .appendField('lookAtTarget');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Forces the avatar\'s eyes to look at a specified location. Once this method is called, API callsfull control of the eyes for a limited time. If this method is not called for 2 seconds,the engine regains control of the eyes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEyesLookAt');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEyesLookAt'] = (block, generator) => {
    const _lookAtTarget = dfv(generator.valueToCode(block, 'lookAtTarget', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setEyesLookAt(${_lookAtTarget});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getEyesLookAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getEyesLookAt')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current target point of the eyes look direction in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getEyesLookAt');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getEyesLookAt'] = (block, generator) => {

return [`MyAvatar.getEyesLookAt()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_releaseEyesLookAtControl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.releaseEyesLookAtControl')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Returns control of the avatar\'s eyes to the engine, and releases control from API calls.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.releaseEyesLookAtControl');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_releaseEyesLookAtControl'] = (block, generator) => {


    return `MyAvatar.releaseEyesLookAtControl();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setPointAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setPointAt')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('pointAtTarget') 
            .setCheck('Vec3')
            .appendField('pointAtTarget');

        this.setColour('#DC476E');
        this.setTooltip('Sets the point-at target for the <code>"point"</code> reaction that may be started with {@link MyAvatar.beginReaction}.The point-at target is set only if it is in front of the avatar.<p>Note: The <code>"point"</code> reaction should be started before calling this method.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setPointAt');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setPointAt'] = (block, generator) => {
    const _pointAtTarget = dfv(generator.valueToCode(block, 'pointAtTarget', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.setPointAt(${_pointAtTarget})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_grab'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.grab')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('targetID') 
            .setCheck('Uuid')
            .appendField('targetID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('offset') 
            .setCheck('Vec3')
            .appendField('offset');
        this.appendValueInput('rotationalOffset') 
            .setCheck('Quat')
            .appendField('rotationalOffset');

        this.setColour('#DC476E');
        this.setTooltip('Creates a new grab that grabs an entity.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.grab');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_grab'] = (block, generator) => {
    const _targetID = dfv(generator.valueToCode(block, 'targetID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _offset = dfv(generator.valueToCode(block, 'offset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotationalOffset = dfv(generator.valueToCode(block, 'rotationalOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.grab(${_targetID},${_parentJointIndex},${_offset},${_rotationalOffset})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_releaseGrab'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.releaseGrab')
        // Returns data

        // Params data
        this.appendValueInput('grabID') 
            .setCheck('Uuid')
            .appendField('grabID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Releases (deletes) a grab to stop grabbing an entity.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.releaseGrab');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_releaseGrab'] = (block, generator) => {
    const _grabID = dfv(generator.valueToCode(block, 'grabID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.releaseGrab(${_grabID});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getAvatarEntityData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAvatarEntityData')
        // Returns data
        this.setOutput(true, '["AvatarEntityMap"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets details of all avatar entities.<p><strong>Warning:</strong> Potentially an expensive call. Do not use if possible.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAvatarEntityData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAvatarEntityData'] = (block, generator) => {

return [`MyAvatar.getAvatarEntityData()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setAvatarEntityData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setAvatarEntityData')
        // Returns data

        // Params data
        this.appendValueInput('avatarEntityData') 
            .setCheck('AvatarEntityMap')
            .appendField('avatarEntityData');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets all avatar entities from an object.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setAvatarEntityData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setAvatarEntityData'] = (block, generator) => {
    const _avatarEntityData = dfv(generator.valueToCode(block, 'avatarEntityData', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setAvatarEntityData(${_avatarEntityData});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_useFlow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.useFlow')
        // Returns data

        // Params data
        this.appendValueInput('isActive') 
            .setCheck('Boolean')
            .appendField('isActive');
        this.appendValueInput('isCollidable') 
            .setCheck('Boolean')
            .appendField('isCollidable');
        this.appendValueInput('physicsConfig') 
            .setCheck('Object.<JointName, MyAvatar.FlowPhysicsOptions>')
            .appendField('physicsConfig');
        this.appendValueInput('collisionsConfig') 
            .setCheck('Object.<JointName, MyAvatar.FlowCollisionsOptions>')
            .appendField('collisionsConfig');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Enables and disables flow simulation of physics on the avatar\'s hair, clothes, and body parts. See{@link https://docs.overte.org/create/avatars/add-flow.html|Add Flow to Your Avatar} for moreinformation.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.useFlow');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_useFlow'] = (block, generator) => {
    const _isActive = dfv(generator.valueToCode(block, 'isActive', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isCollidable = dfv(generator.valueToCode(block, 'isCollidable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _physicsConfig = dfv(generator.valueToCode(block, 'physicsConfig', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _collisionsConfig = dfv(generator.valueToCode(block, 'collisionsConfig', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.useFlow(${_isActive},${_isCollidable},${_physicsConfig},${_collisionsConfig});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getFlowData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getFlowData')
        // Returns data
        this.setOutput(true, '["MyAvatar.FlowData"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current flow configuration.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getFlowData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getFlowData'] = (block, generator) => {

return [`MyAvatar.getFlowData()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getCollidingFlowJoints'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getCollidingFlowJoints')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the indexes of currently colliding flow joints.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getCollidingFlowJoints');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getCollidingFlowJoints'] = (block, generator) => {

return [`MyAvatar.getCollidingFlowJoints()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_beginSit'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.beginSit')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Starts a sitting action for the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.beginSit');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_beginSit'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.beginSit(${_position},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_endSit'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.endSit')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Ends a sitting action for the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.endSit');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_endSit'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.endSit(${_position},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_isSeated'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isSeated')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether the avatar is in a seated pose. The seated pose is set by calling {@link MyAvatar.beginSit}.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isSeated');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isSeated'] = (block, generator) => {

return [`MyAvatar.isSeated()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_increaseSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.increaseSize')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Increases the avatar\'s scale by five percent, up to a minimum scale of <code>1000</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.increaseSize');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_increaseSize'] = (block, generator) => {


    return `MyAvatar.increaseSize();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_decreaseSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.decreaseSize')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Decreases the avatar\'s scale by five percent, down to a minimum scale of <code>0.25</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.decreaseSize');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_decreaseSize'] = (block, generator) => {


    return `MyAvatar.decreaseSize();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_resetSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.resetSize')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Resets the avatar\'s scale back to the default scale of <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.resetSize');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_resetSize'] = (block, generator) => {


    return `MyAvatar.resetSize();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setGravity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setGravity')
        // Returns data

        // Params data
        this.appendValueInput('gravity') 
            .setCheck('Number')
            .appendField('gravity');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the amount of gravity applied to the avatar in the y-axis direction. (Negative values are downward.)');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setGravity');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setGravity'] = (block, generator) => {
    const _gravity = dfv(generator.valueToCode(block, 'gravity', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setGravity(${_gravity});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getGravity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getGravity')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Sets the amount of gravity applied to the avatar in the y-axis direction. (Negative values are downward.) The defaultvalue is <code>-5</code> m/s<sup>2</sup>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getGravity');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getGravity'] = (block, generator) => {

return [`MyAvatar.getGravity()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_goToFeetLocation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.goToFeetLocation')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('hasOrientation') 
            .setCheck('Boolean')
            .appendField('hasOrientation');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('shouldFaceLocation') 
            .setCheck('Boolean')
            .appendField('shouldFaceLocation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Moves the avatar to a new position and/or orientation in the domain, with safe landing, while taking into account avatarleg length.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.goToFeetLocation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_goToFeetLocation'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hasOrientation = dfv(generator.valueToCode(block, 'hasOrientation', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), `Quat.IDENTITY`);
    const _shouldFaceLocation = dfv(generator.valueToCode(block, 'shouldFaceLocation', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.goToFeetLocation(${_position},${_hasOrientation},${_orientation},${_shouldFaceLocation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_goToLocation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.goToLocation')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('hasOrientation') 
            .setCheck('Boolean')
            .appendField('hasOrientation');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('shouldFaceLocation') 
            .setCheck('Boolean')
            .appendField('shouldFaceLocation');
        this.appendValueInput('withSafeLanding') 
            .setCheck('Boolean')
            .appendField('withSafeLanding');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Moves the avatar to a new position and/or orientation in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.goToLocation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_goToLocation'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hasOrientation = dfv(generator.valueToCode(block, 'hasOrientation', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), `Quat.IDENTITY`);
    const _shouldFaceLocation = dfv(generator.valueToCode(block, 'shouldFaceLocation', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _withSafeLanding = dfv(generator.valueToCode(block, 'withSafeLanding', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);


    return `MyAvatar.goToLocation(${_position},${_hasOrientation},${_orientation},${_shouldFaceLocation},${_withSafeLanding});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_goToLocationtarget'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.goToLocation')
        // Returns data

        // Params data
        this.appendValueInput('target') 
            .setCheck('MyAvatar.GoToProperties')
            .appendField('target');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Moves the avatar to a new position and (optional) orientation in the domain, with safe landing.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.goToLocation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_goToLocationtarget'] = (block, generator) => {
    const _target = dfv(generator.valueToCode(block, 'target', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.goToLocation(${_target});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_goToLocationAndEnableCollisions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.goToLocationAndEnableCollisions')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Moves the avatar to a new position, with safe landing, and enables collisions.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.goToLocationAndEnableCollisions');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_goToLocationAndEnableCollisions'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.goToLocationAndEnableCollisions(${_position});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_updateMotionBehaviorFromMenu'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.updateMotionBehaviorFromMenu')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Updates avatar motion behavior from the Developer &gt; Avatar &gt; Enable Default Motor Control and Enable ScriptedMotor Control menu items.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.updateMotionBehaviorFromMenu');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_updateMotionBehaviorFromMenu'] = (block, generator) => {


    return `MyAvatar.updateMotionBehaviorFromMenu();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawBaseOfSupport'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawBaseOfSupport')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays the base of support area debug graphics if in HMD mode. If your head goes outside this area your avatar\'s hipsare moved to counterbalance your avatar, and if your head moves too far then your avatar\'s position is moved (i.e., astep happens).');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawBaseOfSupport');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawBaseOfSupport'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawBaseOfSupport(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawDefaultPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawDefaultPose')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays default pose debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawDefaultPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawDefaultPose'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawDefaultPose(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawAnimPose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawAnimPose')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays animation debug graphics. By default, the animation poses used for rendering are displayed. However,{@link MyAvatar.setDebugDrawAnimPoseName} can be used to set a specific animation node to display.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawAnimPose');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawAnimPose'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawAnimPose(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setDebugDrawAnimPoseName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setDebugDrawAnimPoseName')
        // Returns data

        // Params data
        this.appendValueInput('poseName') 
            .setCheck('String')
            .appendField('poseName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the animation node to display when animation debug graphics are enabled with{@link MyAvatar.setEnableDebugDrawAnimPose}.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setDebugDrawAnimPoseName');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setDebugDrawAnimPoseName'] = (block, generator) => {
    const _poseName = dfv(generator.valueToCode(block, 'poseName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setDebugDrawAnimPoseName(${_poseName});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawPosition')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays position debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawPosition'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawPosition(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawHandControllers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawHandControllers')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays controller hand target debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawHandControllers');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawHandControllers'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawHandControllers(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawSensorToWorldMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawSensorToWorldMatrix')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays sensor-to-world matrix debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawSensorToWorldMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawSensorToWorldMatrix'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawSensorToWorldMatrix(${_enable});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawIKTargets'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawIKTargets')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays inverse kinematics targets debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawIKTargets');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawIKTargets'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawIKTargets(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawIKConstraints'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawIKConstraints')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays inverse kinematics constraints debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawIKConstraints');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawIKConstraints'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawIKConstraints(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawIKChains'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawIKChains')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays inverse kinematics chains debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawIKChains');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawIKChains'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawIKChains(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableDebugDrawDetailedCollision'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableDebugDrawDetailedCollision')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Displays detailed collision debug graphics.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableDebugDrawDetailedCollision');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableDebugDrawDetailedCollision'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableDebugDrawDetailedCollision(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getEnableMeshVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getEnableMeshVisible')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets whether your avatar mesh is visible.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getEnableMeshVisible');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getEnableMeshVisible'] = (block, generator) => {

return [`MyAvatar.getEnableMeshVisible()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableMeshVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableMeshVisible')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether your avatar mesh is visible to you.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableMeshVisible');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableMeshVisible'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableMeshVisible(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setEnableInverseKinematics'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setEnableInverseKinematics')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets whether inverse kinematics (IK) is enabled for your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setEnableInverseKinematics');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setEnableInverseKinematics'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setEnableInverseKinematics(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getAnimGraphOverrideUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAnimGraphOverrideUrl')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the URL of the override animation graph.<p>See {@link https://docs.overte.org/create/avatars/custom-animations.html|Custom Avatar Animations} forinformation on animation graphs.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAnimGraphOverrideUrl');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAnimGraphOverrideUrl'] = (block, generator) => {

return [`MyAvatar.getAnimGraphOverrideUrl()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setAnimGraphOverrideUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setAnimGraphOverrideUrl')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the animation graph to use in preference to the default animation graph.<p>See {@link https://docs.overte.org/create/avatars/custom-animations.html|Custom Avatar Animations} forinformation on animation graphs.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setAnimGraphOverrideUrl');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setAnimGraphOverrideUrl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setAnimGraphOverrideUrl(${_url});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getAnimGraphUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAnimGraphUrl')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the URL of animation graph (i.e., the avatar animation JSON) that\'s currently being used for avatar animations.<p>See {@link https://docs.overte.org/create/avatars/custom-animations.html|Custom Avatar Animations} forinformation on animation graphs.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAnimGraphUrl');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAnimGraphUrl'] = (block, generator) => {

return [`MyAvatar.getAnimGraphUrl()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setAnimGraphUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setAnimGraphUrl')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the current animation graph  (i.e., the avatar animation JSON) to use for avatar animations and makes it the default.<p>See {@link https://docs.overte.org/create/avatars/custom-animations.html|Custom Avatar Animations} forinformation on animation graphs.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setAnimGraphUrl');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setAnimGraphUrl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setAnimGraphUrl(${_url});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getPositionForAudio'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getPositionForAudio')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets your listening position for spatialized audio. The position depends on the value of the{@link Myavatar|audioListenerMode} property.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getPositionForAudio');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getPositionForAudio'] = (block, generator) => {

return [`MyAvatar.getPositionForAudio()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getOrientationForAudio'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getOrientationForAudio')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the orientation of your listening position for spatialized audio. The orientation depends on the value of the{@link Myavatar|audioListenerMode} property.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getOrientationForAudio');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getOrientationForAudio'] = (block, generator) => {

return [`MyAvatar.getOrientationForAudio()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getTriggerReactions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getTriggerReactions')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the list of reactions names that can be triggered using {@link MyAvatar.triggerReaction}.<p>See also: {@link MyAvatar.getBeginEndReactions}.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getTriggerReactions');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getTriggerReactions'] = (block, generator) => {

return [`MyAvatar.getTriggerReactions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getBeginEndReactions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getBeginEndReactions')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the list of reactions names that can be enabled using {@link MyAvatar.beginReaction} and{@link MyAvatar.endReaction}.<p>See also: {@link MyAvatar.getTriggerReactions}.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getBeginEndReactions');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getBeginEndReactions'] = (block, generator) => {

return [`MyAvatar.getBeginEndReactions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_triggerReaction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.triggerReaction')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('reactionName') 
            .setCheck('String')
            .appendField('reactionName');

        this.setColour('#DC476E');
        this.setTooltip('Plays a reaction on the avatar. Once the reaction is complete it will stop playing.<p>Only reaction names returned by {@link MyAvatar.getTriggerReactions} are available.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.triggerReaction');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_triggerReaction'] = (block, generator) => {
    const _reactionName = dfv(generator.valueToCode(block, 'reactionName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.triggerReaction(${_reactionName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_beginReaction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.beginReaction')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('reactionName') 
            .setCheck('String')
            .appendField('reactionName');

        this.setColour('#DC476E');
        this.setTooltip('Starts playing a reaction on the avatar. The reaction will continue to play until stopped using{@link MyAvatar.endReaction} or superseded by another reaction.<p>Only reactions returned by {@link MyAvatar.getBeginEndReactions} are available.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.beginReaction');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_beginReaction'] = (block, generator) => {
    const _reactionName = dfv(generator.valueToCode(block, 'reactionName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.beginReaction(${_reactionName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_endReaction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.endReaction')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('reactionName') 
            .setCheck('String')
            .appendField('reactionName');

        this.setColour('#DC476E');
        this.setTooltip('Stops playing a reaction that was started using {@link MyAvatar.beginReaction}.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.endReaction');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_endReaction'] = (block, generator) => {
    const _reactionName = dfv(generator.valueToCode(block, 'reactionName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.endReaction(${_reactionName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['MyAvatar_audioListenerModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.audioListenerModeChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the {@link MyAvatar|audioListenerMode} property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.audioListenerModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_audioListenerModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.audioListenerModeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_analogPlusWalkSpeedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.analogPlusWalkSpeedChanged');

        this.appendDummyInput('speed')
            .appendField('speed:')
            .appendField(new Blockly.FieldVariable('analogPlusWalkSpeedChanged_speed'), 'speed');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the walk speed set for the "AnalogPlus" control scheme changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.analogPlusWalkSpeedChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_analogPlusWalkSpeedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const speed = generator.getVariableName(block.getFieldValue('speed'));

return `MyAvatar.analogPlusWalkSpeedChanged.connect((_speed) => { 
  ${speed} = _speed;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_analogPlusSprintSpeedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.analogPlusSprintSpeedChanged');

        this.appendDummyInput('speed')
            .appendField('speed:')
            .appendField(new Blockly.FieldVariable('analogPlusSprintSpeedChanged_speed'), 'speed');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the sprint (run) speed set for the "AnalogPlus" control scheme changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.analogPlusSprintSpeedChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_analogPlusSprintSpeedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const speed = generator.getVariableName(block.getFieldValue('speed'));

return `MyAvatar.analogPlusSprintSpeedChanged.connect((_speed) => { 
  ${speed} = _speed;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_sprintSpeedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.sprintSpeedChanged');

        this.appendDummyInput('speed')
            .appendField('speed:')
            .appendField(new Blockly.FieldVariable('sprintSpeedChanged_speed'), 'speed');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the sprint (run) speed set for the current control scheme (see{@link MyAvatar.getControlScheme|getControlScheme}) changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sprintSpeedChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sprintSpeedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const speed = generator.getVariableName(block.getFieldValue('speed'));

return `MyAvatar.sprintSpeedChanged.connect((_speed) => { 
  ${speed} = _speed;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_walkBackwardSpeedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.walkBackwardSpeedChanged');

        this.appendDummyInput('speed')
            .appendField('speed:')
            .appendField(new Blockly.FieldVariable('walkBackwardSpeedChanged_speed'), 'speed');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the walk backward speed set for the current control scheme (see{@link MyAvatar.getControlScheme|getControlScheme}) changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.walkBackwardSpeedChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_walkBackwardSpeedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const speed = generator.getVariableName(block.getFieldValue('speed'));

return `MyAvatar.walkBackwardSpeedChanged.connect((_speed) => { 
  ${speed} = _speed;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_newCollisionSoundURL'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.newCollisionSoundURL');

        this.appendDummyInput('url')
            .appendField('url:')
            .appendField(new Blockly.FieldVariable('newCollisionSoundURL_url'), 'url');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the {@link MyAvatar|collisionSoundURL} property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.newCollisionSoundURL');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_newCollisionSoundURL'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const url = generator.getVariableName(block.getFieldValue('url'));

return `MyAvatar.newCollisionSoundURL.connect((_url) => { 
  ${url} = _url;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_collisionWithEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.collisionWithEntity');

        this.appendDummyInput('collision')
            .appendField('collision:')
            .appendField(new Blockly.FieldVariable('collisionWithEntity_collision'), 'collision');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar collides with an entity.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.collisionWithEntity');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_collisionWithEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const collision = generator.getVariableName(block.getFieldValue('collision'));

return `MyAvatar.collisionWithEntity.connect((_collision) => { 
  ${collision} = _collision;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_collisionsEnabledChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.collisionsEnabledChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('collisionsEnabledChanged_enabled'), 'enabled');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when collisions with the environment are enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.collisionsEnabledChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_collisionsEnabledChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `MyAvatar.collisionsEnabledChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_otherAvatarsCollisionsEnabledChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.otherAvatarsCollisionsEnabledChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('otherAvatarsCollisionsEnabledChanged_enabled'), 'enabled');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when collisions with other avatars are enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.otherAvatarsCollisionsEnabledChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_otherAvatarsCollisionsEnabledChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `MyAvatar.otherAvatarsCollisionsEnabledChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_animGraphUrlChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.animGraphUrlChanged');

        this.appendDummyInput('url')
            .appendField('url:')
            .appendField(new Blockly.FieldVariable('animGraphUrlChanged_url'), 'url');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s animation graph being used changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.animGraphUrlChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_animGraphUrlChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const url = generator.getVariableName(block.getFieldValue('url'));

return `MyAvatar.animGraphUrlChanged.connect((_url) => { 
  ${url} = _url;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_positionGoneTo'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.positionGoneTo');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar has been moved to a new position by one of the MyAvatar "goTo" functions.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.positionGoneTo');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_positionGoneTo'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.positionGoneTo.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_onLoadComplete'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.onLoadComplete');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s model finishes loading.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.onLoadComplete');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_onLoadComplete'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.onLoadComplete.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_onLoadFailed'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.onLoadFailed');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s model has failed to load.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.onLoadFailed');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_onLoadFailed'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.onLoadFailed.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_wentAway'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.wentAway');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when your avatar changes from being active to being away.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.wentAway');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_wentAway'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.wentAway.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_wentActive'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.wentActive');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when your avatar changes from being away to being active.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.wentActive');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_wentActive'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.wentActive.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_skeletonChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.skeletonChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s model (i.e., {@link MyAvatar|skeletonModelURL} property value) is changed.<p>Synonym of {@link MyAvatar.skeletonModelURLChanged|skeletonModelURLChanged}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.skeletonChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_skeletonChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.skeletonChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_dominantHandChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.dominantHandChanged');

        this.appendDummyInput('hand')
            .appendField('hand:')
            .appendField(new Blockly.FieldVariable('dominantHandChanged_hand'), 'hand');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s dominant hand changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.dominantHandChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_dominantHandChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const hand = generator.getVariableName(block.getFieldValue('hand'));

return `MyAvatar.dominantHandChanged.connect((_hand) => { 
  ${hand} = _hand;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_hmdAvatarAlignmentTypeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.hmdAvatarAlignmentTypeChanged');

        this.appendDummyInput('type')
            .appendField('type:')
            .appendField(new Blockly.FieldVariable('hmdAvatarAlignmentTypeChanged_type'), 'type');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the HMD alignment for your avatar changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.hmdAvatarAlignmentTypeChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_hmdAvatarAlignmentTypeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const type = generator.getVariableName(block.getFieldValue('type'));

return `MyAvatar.hmdAvatarAlignmentTypeChanged.connect((_type) => { 
  ${type} = _type;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_sensorToWorldScaleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.sensorToWorldScaleChanged');

        this.appendDummyInput('scale')
            .appendField('scale:')
            .appendField(new Blockly.FieldVariable('sensorToWorldScaleChanged_scale'), 'scale');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s <code>sensorToWorldScale</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sensorToWorldScaleChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sensorToWorldScaleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const scale = generator.getVariableName(block.getFieldValue('scale'));

return `MyAvatar.sensorToWorldScaleChanged.connect((_scale) => { 
  ${scale} = _scale;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_scaleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.scaleChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s size changes. This can be due to the user changing the size of their avatar or the domainlimiting the size of their avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.scaleChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_scaleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.scaleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_shouldDisableHandTouchChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.shouldDisableHandTouchChanged');

        this.appendDummyInput('disabled')
            .appendField('disabled:')
            .appendField(new Blockly.FieldVariable('shouldDisableHandTouchChanged_disabled'), 'disabled');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the hand touch effect is enabled or disabled for the avatar.<p>The hand touch effect makes the avatar\'s fingers adapt to the shape of any object grabbed, creating the effect thatit is really touching that object.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.shouldDisableHandTouchChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_shouldDisableHandTouchChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const disabled = generator.getVariableName(block.getFieldValue('disabled'));

return `MyAvatar.shouldDisableHandTouchChanged.connect((_disabled) => { 
  ${disabled} = _disabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_disableHandTouchForIDChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.disableHandTouchForIDChanged');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('disableHandTouchForIDChanged_entityID'), 'entityID');
        this.appendDummyInput('disabled')
            .appendField('disabled:')
            .appendField(new Blockly.FieldVariable('disableHandTouchForIDChanged_disabled'), 'disabled');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the hand touch is enabled or disabled on a specific entity.<p>The hand touch effect makes the avatar\'s fingers adapt to the shape of any object grabbed, creating the effect thatit is really touching that object.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.disableHandTouchForIDChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_disableHandTouchForIDChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const disabled = generator.getVariableName(block.getFieldValue('disabled'));

return `MyAvatar.disableHandTouchForIDChanged.connect((_entityID,_disabled) => { 
  ${entityID} = _entityID; 
  ${disabled} = _disabled;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['CollisionPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('CollisionPickResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('intersectingObjects') 
            .setCheck('Array')
            .appendField('intersectingObjects');
        this.appendValueInput('collisionRegion') 
            .setCheck('CollisionRegion')
            .appendField('collisionRegion');
        this.setColour('#95E1A5');
        this.setTooltip('An intersection result for a collision pick.');
        this.setHelpUrl('https://apidocs.overte.org/CollisionPickResult');
    }
};
javascript.javascriptGenerator.forBlock['CollisionPickResult'] = (block, generator) => {
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _intersectingObjects = dfv(generator.valueToCode(block, 'intersectingObjects', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _collisionRegion = dfv(generator.valueToCode(block, 'collisionRegion', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new CollisionPickResult(${_intersects},${_intersectingObjects},${_collisionRegion})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['IntersectingObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('IntersectingObject')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('type') 
            .setCheck('IntersectionType')
            .appendField('type');
        this.appendValueInput('collisionContacts') 
            .setCheck('Array')
            .appendField('collisionContacts');
        this.setColour('#7D99D2');
        this.setTooltip('Information about a {@link CollisionPick}\'s intersection with an object.');
        this.setHelpUrl('https://apidocs.overte.org/IntersectingObject');
    }
};
javascript.javascriptGenerator.forBlock['IntersectingObject'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _collisionContacts = dfv(generator.valueToCode(block, 'collisionContacts', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new IntersectingObject(${_id},${_type},${_collisionContacts})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['CollisionContact'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('CollisionContact')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('pointOnPick') 
            .setCheck('Vec3')
            .appendField('pointOnPick');
        this.appendValueInput('pointOnObject') 
            .setCheck('Vec3')
            .appendField('pointOnObject');
        this.appendValueInput('normalOnPick') 
            .setCheck('Vec3')
            .appendField('normalOnPick');
        this.setColour('#AC2EDE');
        this.setTooltip('A pair of points that represents part of an overlap between a {@link CollisionPick} and an object in the physics engine. Points which are further apart represent deeper overlap.');
        this.setHelpUrl('https://apidocs.overte.org/CollisionContact');
    }
};
javascript.javascriptGenerator.forBlock['CollisionContact'] = (block, generator) => {
    const _pointOnPick = dfv(generator.valueToCode(block, 'pointOnPick', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pointOnObject = dfv(generator.valueToCode(block, 'pointOnObject', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _normalOnPick = dfv(generator.valueToCode(block, 'normalOnPick', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new CollisionContact(${_pointOnPick},${_pointOnObject},${_normalOnPick})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ParabolaPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ParabolaPickResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('Number')
            .appendField('type');
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('objectID') 
            .setCheck('Uuid')
            .appendField('objectID');
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.appendValueInput('parabolicDistance') 
            .setCheck('Number')
            .appendField('parabolicDistance');
        this.appendValueInput('intersection') 
            .setCheck('Vec3')
            .appendField('intersection');
        this.appendValueInput('surfaceNormal') 
            .setCheck('Vec3')
            .appendField('surfaceNormal');
        this.appendValueInput('extraInfo') 
            .setCheck('SubmeshIntersection')
            .appendField('extraInfo');
        this.appendValueInput('parabola') 
            .setCheck('PickParabola')
            .appendField('parabola');
        this.setColour('#AB9440');
        this.setTooltip('An intersection result for a parabola pick.');
        this.setHelpUrl('https://apidocs.overte.org/ParabolaPickResult');
    }
};
javascript.javascriptGenerator.forBlock['ParabolaPickResult'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _objectID = dfv(generator.valueToCode(block, 'objectID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _parabolicDistance = dfv(generator.valueToCode(block, 'parabolicDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _intersection = dfv(generator.valueToCode(block, 'intersection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _surfaceNormal = dfv(generator.valueToCode(block, 'surfaceNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extraInfo = dfv(generator.valueToCode(block, 'extraInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parabola = dfv(generator.valueToCode(block, 'parabola', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ParabolaPickResult(${_type},${_intersects},${_objectID},${_distance},${_parabolicDistance},${_intersection},${_surfaceNormal},${_extraInfo},${_parabola})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Picks_RayPickProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.RayPickProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');
        this.appendValueInput('filter') 
            .setCheck('FilterFlags')
            .appendField('filter');
        this.appendValueInput('maxDistance') 
            .setCheck('Number')
            .appendField('maxDistance');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('joint') 
            .setCheck('String')
            .appendField('joint');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('posOffset') 
            .setCheck('Vec3')
            .appendField('posOffset');
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('dirOffset') 
            .setCheck('Vec3')
            .appendField('dirOffset');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('delay') 
            .setCheck('Number')
            .appendField('delay');
        this.appendValueInput('pickType') 
            .setCheck('PickType')
            .appendField('pickType');
        this.appendValueInput('baseScale') 
            .setCheck('Vec3')
            .appendField('baseScale');
        this.setColour('#A0719C');
        this.setTooltip('The properties of a ray pick.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.RayPickProperties');
    }
};
javascript.javascriptGenerator.forBlock['Picks_RayPickProperties'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _filter = dfv(generator.valueToCode(block, 'filter', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _maxDistance = dfv(generator.valueToCode(block, 'maxDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _joint = dfv(generator.valueToCode(block, 'joint', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), `Vec3.ZERO`);
    const _posOffset = dfv(generator.valueToCode(block, 'posOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dirOffset = dfv(generator.valueToCode(block, 'dirOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _delay = dfv(generator.valueToCode(block, 'delay', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _pickType = dfv(generator.valueToCode(block, 'pickType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _baseScale = dfv(generator.valueToCode(block, 'baseScale', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Picks.RayPickProperties(${_enabled},${_filter},${_maxDistance},${_parentID},${_parentJointIndex},${_joint},${_position},${_posOffset},${_direction},${_dirOffset},${_orientation},${_delay},${_pickType},${_baseScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Picks_StylusPickProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.StylusPickProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('hand') 
            .setCheck('Number')
            .appendField('hand');
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');
        this.appendValueInput('filter') 
            .setCheck('Number')
            .appendField('filter');
        this.appendValueInput('maxDistance') 
            .setCheck('Number')
            .appendField('maxDistance');
        this.appendValueInput('tipOffset') 
            .setCheck('Vec3')
            .appendField('tipOffset');
        this.appendValueInput('pickType') 
            .setCheck('PickType')
            .appendField('pickType');
        this.setColour('#A0719C');
        this.setTooltip('The properties of a stylus pick.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.StylusPickProperties');
    }
};
javascript.javascriptGenerator.forBlock['Picks_StylusPickProperties'] = (block, generator) => {
    const _hand = dfv(generator.valueToCode(block, 'hand', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _filter = dfv(generator.valueToCode(block, 'filter', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _maxDistance = dfv(generator.valueToCode(block, 'maxDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _tipOffset = dfv(generator.valueToCode(block, 'tipOffset', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0.095,0`);
    const _pickType = dfv(generator.valueToCode(block, 'pickType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Picks.StylusPickProperties(${_hand},${_enabled},${_filter},${_maxDistance},${_tipOffset},${_pickType})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Picks_ParabolaPickProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.ParabolaPickProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');
        this.appendValueInput('filter') 
            .setCheck('Number')
            .appendField('filter');
        this.appendValueInput('maxDistance') 
            .setCheck('Number')
            .appendField('maxDistance');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('joint') 
            .setCheck('String')
            .appendField('joint');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('posOffset') 
            .setCheck('Vec3')
            .appendField('posOffset');
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('dirOffset') 
            .setCheck('Vec3')
            .appendField('dirOffset');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('speed') 
            .setCheck('Number')
            .appendField('speed');
        this.appendValueInput('accelerationAxis') 
            .setCheck('Vec3')
            .appendField('accelerationAxis');
        this.appendValueInput('rotateAccelerationWithAvatar') 
            .setCheck('Boolean')
            .appendField('rotateAccelerationWithAvatar');
        this.appendValueInput('rotateAccelerationWithParent') 
            .setCheck('Boolean')
            .appendField('rotateAccelerationWithParent');
        this.appendValueInput('scaleWithParent') 
            .setCheck('Boolean')
            .appendField('scaleWithParent');
        this.appendValueInput('scaleWithAvatar') 
            .setCheck('Boolean')
            .appendField('scaleWithAvatar');
        this.appendValueInput('pickType') 
            .setCheck('PickType')
            .appendField('pickType');
        this.appendValueInput('baseScale') 
            .setCheck('Vec3')
            .appendField('baseScale');
        this.setColour('#A0719C');
        this.setTooltip('The properties of a parabola pick.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.ParabolaPickProperties');
    }
};
javascript.javascriptGenerator.forBlock['Picks_ParabolaPickProperties'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _filter = dfv(generator.valueToCode(block, 'filter', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _maxDistance = dfv(generator.valueToCode(block, 'maxDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _joint = dfv(generator.valueToCode(block, 'joint', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), `Vec3.ZERO`);
    const _posOffset = dfv(generator.valueToCode(block, 'posOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dirOffset = dfv(generator.valueToCode(block, 'dirOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _speed = dfv(generator.valueToCode(block, 'speed', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _accelerationAxis = dfv(generator.valueToCode(block, 'accelerationAxis', javascript.javascriptGenerator.ORDER_ATOMIC), `-Vec3.UP`);
    const _rotateAccelerationWithAvatar = dfv(generator.valueToCode(block, 'rotateAccelerationWithAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _rotateAccelerationWithParent = dfv(generator.valueToCode(block, 'rotateAccelerationWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _scaleWithParent = dfv(generator.valueToCode(block, 'scaleWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _scaleWithAvatar = dfv(generator.valueToCode(block, 'scaleWithAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _pickType = dfv(generator.valueToCode(block, 'pickType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _baseScale = dfv(generator.valueToCode(block, 'baseScale', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Picks.ParabolaPickProperties(${_enabled},${_filter},${_maxDistance},${_parentID},${_parentJointIndex},${_joint},${_position},${_posOffset},${_direction},${_dirOffset},${_orientation},${_speed},${_accelerationAxis},${_rotateAccelerationWithAvatar},${_rotateAccelerationWithParent},${_scaleWithParent},${_scaleWithAvatar},${_pickType},${_baseScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Picks_CollisionPickProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.CollisionPickProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');
        this.appendValueInput('filter') 
            .setCheck('FilterFlags')
            .appendField('filter');
        this.appendValueInput('maxDistance') 
            .setCheck('Number')
            .appendField('maxDistance');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('joint') 
            .setCheck('String')
            .appendField('joint');
        this.appendValueInput('scaleWithParent') 
            .setCheck('Boolean')
            .appendField('scaleWithParent');
        this.appendValueInput('shape') 
            .setCheck('Shape')
            .appendField('shape');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('threshold') 
            .setCheck('Number')
            .appendField('threshold');
        this.appendValueInput('collisionGroup') 
            .setCheck('CollisionMask')
            .appendField('collisionGroup');
        this.appendValueInput('pickType') 
            .setCheck('PickType')
            .appendField('pickType');
        this.appendValueInput('baseScale') 
            .setCheck('Vec3')
            .appendField('baseScale');
        this.setColour('#A0719C');
        this.setTooltip('The properties of a collision pick.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.CollisionPickProperties');
    }
};
javascript.javascriptGenerator.forBlock['Picks_CollisionPickProperties'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _filter = dfv(generator.valueToCode(block, 'filter', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _maxDistance = dfv(generator.valueToCode(block, 'maxDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _joint = dfv(generator.valueToCode(block, 'joint', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scaleWithParent = dfv(generator.valueToCode(block, 'scaleWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _shape = dfv(generator.valueToCode(block, 'shape', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _threshold = dfv(generator.valueToCode(block, 'threshold', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _collisionGroup = dfv(generator.valueToCode(block, 'collisionGroup', javascript.javascriptGenerator.ORDER_ATOMIC), `8`);
    const _pickType = dfv(generator.valueToCode(block, 'pickType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _baseScale = dfv(generator.valueToCode(block, 'baseScale', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Picks.CollisionPickProperties(${_enabled},${_filter},${_maxDistance},${_parentID},${_parentJointIndex},${_joint},${_scaleWithParent},${_shape},${_position},${_orientation},${_threshold},${_collisionGroup},${_pickType},${_baseScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Picks_PICK_DOMAIN_ENTITIES'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_DOMAIN_ENTITIES')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include domain entities when intersecting. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_DOMAIN_ENTITIES');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_DOMAIN_ENTITIES'] = (block, generator) => {
    return [`Picks.PICK_DOMAIN_ENTITIES`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_AVATAR_ENTITIES'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_AVATAR_ENTITIES')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include avatar entities when intersecting. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_AVATAR_ENTITIES');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_AVATAR_ENTITIES'] = (block, generator) => {
    return [`Picks.PICK_AVATAR_ENTITIES`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_LOCAL_ENTITIES'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_LOCAL_ENTITIES')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include local entities when intersecting. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_LOCAL_ENTITIES');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_LOCAL_ENTITIES'] = (block, generator) => {
    return [`Picks.PICK_LOCAL_ENTITIES`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_AVATARS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_AVATARS')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include avatars when intersecting. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_AVATARS');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_AVATARS'] = (block, generator) => {
    return [`Picks.PICK_AVATARS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_HUD'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_HUD')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include the HUD surface when intersecting in HMD mode. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_HUD');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_HUD'] = (block, generator) => {
    return [`Picks.PICK_HUD`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_ENTITIES'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_ENTITIES')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include domain and avatar entities when intersecting. <em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed. Use <code>PICK_DOMAIN_ENTITIES |     PICK_AVATAR_ENTITIES</code> instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_ENTITIES');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_ENTITIES'] = (block, generator) => {
    return [`Picks.PICK_ENTITIES`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_OVERLAYS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_OVERLAYS')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include local entities when intersecting. <em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed. Use <code>PICK_LOCAL_ENTITIES</code>     instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_OVERLAYS');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_OVERLAYS'] = (block, generator) => {
    return [`Picks.PICK_OVERLAYS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_INCLUDE_VISIBLE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_INCLUDE_VISIBLE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include visible objects when intersecting. <em>Read-only.</em>    <p><strong>Warning:</strong> Is currently always enabled by default but may not be in the future.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_INCLUDE_VISIBLE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_INCLUDE_VISIBLE'] = (block, generator) => {
    return [`Picks.PICK_INCLUDE_VISIBLE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_INCLUDE_INVISIBLE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_INCLUDE_INVISIBLE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include invisible objects when intersecting. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_INCLUDE_INVISIBLE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_INCLUDE_INVISIBLE'] = (block, generator) => {
    return [`Picks.PICK_INCLUDE_INVISIBLE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_INCLUDE_COLLIDABLE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_INCLUDE_COLLIDABLE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include collidable objects when intersecting. <em>Read-only.</em>    <p><strong>Warning:</strong> Is currently always enabled by default but may not be in the future.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_INCLUDE_COLLIDABLE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_INCLUDE_COLLIDABLE'] = (block, generator) => {
    return [`Picks.PICK_INCLUDE_COLLIDABLE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_INCLUDE_NONCOLLIDABLE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_INCLUDE_NONCOLLIDABLE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Include non-collidable objects when intersecting. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_INCLUDE_NONCOLLIDABLE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_INCLUDE_NONCOLLIDABLE'] = (block, generator) => {
    return [`Picks.PICK_INCLUDE_NONCOLLIDABLE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_PRECISE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_PRECISE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Pick against exact meshes. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_PRECISE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_PRECISE'] = (block, generator) => {
    return [`Picks.PICK_PRECISE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_COARSE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_COARSE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Pick against coarse meshes. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_COARSE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_COARSE'] = (block, generator) => {
    return [`Picks.PICK_COARSE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_ALL_INTERSECTIONS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_ALL_INTERSECTIONS')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('If set, returns all intersections instead of just the closest.     <em>Read-only.</em>    <p><strong>Warning:</strong> Not yet implemented.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_ALL_INTERSECTIONS');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_ALL_INTERSECTIONS'] = (block, generator) => {
    return [`Picks.PICK_ALL_INTERSECTIONS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_PICK_BYPASS_IGNORE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.PICK_BYPASS_IGNORE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Allows pick to intersect entities even when their     <code>ignorePickIntersection</code> property value is <code>true</code>. For debug purposes.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.PICK_BYPASS_IGNORE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_PICK_BYPASS_IGNORE'] = (block, generator) => {
    return [`Picks.PICK_BYPASS_IGNORE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_INTERSECTED_NONE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.INTERSECTED_NONE')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Intersected nothing. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.INTERSECTED_NONE');
    }
};
javascript.javascriptGenerator.forBlock['Picks_INTERSECTED_NONE'] = (block, generator) => {
    return [`Picks.INTERSECTED_NONE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_INTERSECTED_ENTITY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.INTERSECTED_ENTITY')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Intersected an entity. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.INTERSECTED_ENTITY');
    }
};
javascript.javascriptGenerator.forBlock['Picks_INTERSECTED_ENTITY'] = (block, generator) => {
    return [`Picks.INTERSECTED_ENTITY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_INTERSECTED_LOCAL_ENTITY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.INTERSECTED_LOCAL_ENTITY')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Intersected a local entity. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.INTERSECTED_LOCAL_ENTITY');
    }
};
javascript.javascriptGenerator.forBlock['Picks_INTERSECTED_LOCAL_ENTITY'] = (block, generator) => {
    return [`Picks.INTERSECTED_LOCAL_ENTITY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_INTERSECTED_OVERLAY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.INTERSECTED_OVERLAY')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Intersected a local entity. (3D overlays no longer exist.)     <em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed. Use     <code>INTERSECTED_LOCAL_ENTITY</code> instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.INTERSECTED_OVERLAY');
    }
};
javascript.javascriptGenerator.forBlock['Picks_INTERSECTED_OVERLAY'] = (block, generator) => {
    return [`Picks.INTERSECTED_OVERLAY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_INTERSECTED_AVATAR'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.INTERSECTED_AVATAR')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Intersected an avatar. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.INTERSECTED_AVATAR');
    }
};
javascript.javascriptGenerator.forBlock['Picks_INTERSECTED_AVATAR'] = (block, generator) => {
    return [`Picks.INTERSECTED_AVATAR`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_INTERSECTED_HUD'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.INTERSECTED_HUD')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('Intersected the HUD surface. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.INTERSECTED_HUD');
    }
};
javascript.javascriptGenerator.forBlock['Picks_INTERSECTED_HUD'] = (block, generator) => {
    return [`Picks.INTERSECTED_HUD`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_perFrameTimeBudget'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.perFrameTimeBudget')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('The maximum time, in microseconds, to spend per frame updating pick results.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.perFrameTimeBudget');
    }
};
javascript.javascriptGenerator.forBlock['Picks_perFrameTimeBudget'] = (block, generator) => {
    return [`Picks.perFrameTimeBudget`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Picks_handLaserDelay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.handLaserDelay')       
        this.setOutput(true, '');
        this.setColour('#A0719C');
        this.setTooltip('The delay, in seconds, applied to the hand lasers to smooth their movement.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.handLaserDelay');
    }
};
javascript.javascriptGenerator.forBlock['Picks_handLaserDelay'] = (block, generator) => {
    return [`Picks.handLaserDelay`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Picks_createPick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.createPick')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('type') 
            .setCheck('PickType')
            .appendField('type');
        this.appendValueInput('properties') 
            .setCheck('Picks.RayPickProperties')
            .appendField('properties');

        this.setColour('#A0719C');
        this.setTooltip('Creates a new pick. Different {@link PickType}s use different properties, and within one PickType the properties you choose can lead to a wide range of behaviors. For example, with <code>PickType.Ray</code>, the properties could configure a mouse ray pick, an avatar head ray pick, or a joint ray pick.<p><strong>Warning:</strong> Picks created using this method currently always intersect at least visible and collidable things but this may not always be the case.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.createPick');
    }
};
javascript.javascriptGenerator.forBlock['Picks_createPick'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Picks.createPick(${_type},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_enablePick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.enablePick')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Enables a pick. Enabled picks update their pick results.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.enablePick');
    }
};
javascript.javascriptGenerator.forBlock['Picks_enablePick'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Picks.enablePick(${_id});\n`;};


// Blockly function
Blockly.Blocks['Picks_disablePick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.disablePick')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Disables a pick. Disabled picks do not update their pick results.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.disablePick');
    }
};
javascript.javascriptGenerator.forBlock['Picks_disablePick'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Picks.disablePick(${_id});\n`;};


// Blockly function
Blockly.Blocks['Picks_isPickEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.isPickEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Get the enabled status of a pick. Enabled picks update their pick results.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.isPickEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Picks_isPickEnabled'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.isPickEnabled(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_removePick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.removePick')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Removes (deletes) a pick.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.removePick');
    }
};
javascript.javascriptGenerator.forBlock['Picks_removePick'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Picks.removePick(${_id});\n`;};


// Blockly function
Blockly.Blocks['Picks_getPickProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.getPickProperties')
        // Returns data
        this.setOutput(true, '["Picks.RayPickProperties"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Gets the current properties of the pick.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.getPickProperties');
    }
};
javascript.javascriptGenerator.forBlock['Picks_getPickProperties'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.getPickProperties(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_getPickScriptParameters'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.getPickScriptParameters')
        // Returns data
        this.setOutput(true, '["Picks.RayPickProperties"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Gets the parameters that were passed in to {@link Picks.createPick} to create the pick, if the pick was created through a script. Note that these properties do not reflect the current state of the pick.See {@link Picks.getPickProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.getPickScriptParameters');
    }
};
javascript.javascriptGenerator.forBlock['Picks_getPickScriptParameters'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.getPickScriptParameters(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_getPicks'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.getPicks')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#A0719C');
        this.setTooltip('Gets all picks which currently exist, including disabled picks.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.getPicks');
    }
};
javascript.javascriptGenerator.forBlock['Picks_getPicks'] = (block, generator) => {

return [`Picks.getPicks()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_getPrevPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.getPrevPickResult')
        // Returns data
        this.setOutput(true, '["RayPickResult"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Gets the most recent result from a pick. A pick continues to be updated ready to return a result, as long as it is enabled.<p><strong>Note:</strong> Stylus picks only intersect with objects in their include list, set using {@link Picks.setIncludeItems|setIncludeItems}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.getPrevPickResult');
    }
};
javascript.javascriptGenerator.forBlock['Picks_getPrevPickResult'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.getPrevPickResult(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_setPrecisionPicking'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.setPrecisionPicking')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('precisionPicking') 
            .setCheck('Boolean')
            .appendField('precisionPicking');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Sets whether or not a pick should use precision picking, i.e., whether it should pick against precise meshes or coarse meshes.This has the same effect as using the <code>PICK_PRECISE</code> or <code>PICK_COARSE</code> filter flags.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.setPrecisionPicking');
    }
};
javascript.javascriptGenerator.forBlock['Picks_setPrecisionPicking'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _precisionPicking = dfv(generator.valueToCode(block, 'precisionPicking', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Picks.setPrecisionPicking(${_id},${_precisionPicking});\n`;};


// Blockly function
Blockly.Blocks['Picks_setIgnoreItems'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.setIgnoreItems')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('ignoreItems') 
            .setCheck('Array')
            .appendField('ignoreItems');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Sets a list of entity and avatar IDs that a pick should ignore during intersection.<p><strong>Note:</strong> Not used by stylus picks.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.setIgnoreItems');
    }
};
javascript.javascriptGenerator.forBlock['Picks_setIgnoreItems'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _ignoreItems = dfv(generator.valueToCode(block, 'ignoreItems', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Picks.setIgnoreItems(${_id},${_ignoreItems});\n`;};


// Blockly function
Blockly.Blocks['Picks_setIncludeItems'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.setIncludeItems')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('includeItems') 
            .setCheck('Array')
            .appendField('includeItems');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Sets a list of entity and avatar IDs that a pick should include during intersection, instead of intersecting with everything.<p><strong>Note:</strong> Stylus picks only intersect with items in their include list.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.setIncludeItems');
    }
};
javascript.javascriptGenerator.forBlock['Picks_setIncludeItems'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _includeItems = dfv(generator.valueToCode(block, 'includeItems', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Picks.setIncludeItems(${_id},${_includeItems});\n`;};


// Blockly function
Blockly.Blocks['Picks_setDelay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.setDelay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('delay') 
            .setCheck('Number')
            .appendField('delay');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#A0719C');
        this.setTooltip('Sets the delay of a Ray pick.<p><strong>Note:</strong> Not used by other pick types.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.setDelay');
    }
};
javascript.javascriptGenerator.forBlock['Picks_setDelay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _delay = dfv(generator.valueToCode(block, 'delay', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Picks.setDelay(${_id},${_delay});\n`;};


// Blockly function
Blockly.Blocks['Picks_isLeftHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.isLeftHand')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Checks if a pick is associated with the left hand: a ray or parabola pick with <code>joint</code> property set to <code>"_CONTROLLER_LEFTHAND"</code> or <code>"_CAMERA_RELATIVE_CONTROLLER_LEFTHAND"</code>, or a stylus pick with <code>hand</code> property set to <code>0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.isLeftHand');
    }
};
javascript.javascriptGenerator.forBlock['Picks_isLeftHand'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.isLeftHand(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_isRightHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.isRightHand')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Checks if a pick is associated with the right hand: a ray or parabola pick with <code>joint</code> property set to<code>"_CONTROLLER_RIGHTHAND"</code> or <code>"_CAMERA_RELATIVE_CONTROLLER_RIGHTHAND"</code>, or a stylus pick with <code>hand</code> property set to <code>1</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.isRightHand');
    }
};
javascript.javascriptGenerator.forBlock['Picks_isRightHand'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.isRightHand(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Picks_isMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Picks.isMouse')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#A0719C');
        this.setTooltip('Checks if a pick is associated with the system mouse: a ray or parabola pick with <code>joint</code> property set to <code>"Mouse"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Picks.html#.isMouse');
    }
};
javascript.javascriptGenerator.forBlock['Picks_isMouse'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Picks.isMouse(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Pointers_StylusPointerProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.StylusPointerProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('model') 
            .setCheck('Pointers.StylusPointerModel')
            .appendField('model');
        this.appendValueInput('hover') 
            .setCheck('Boolean')
            .appendField('hover');
        this.appendValueInput('pointerType') 
            .setCheck('PickType')
            .appendField('pointerType');
        this.appendValueInput('pickID') 
            .setCheck('Number')
            .appendField('pickID');
        this.setColour('#7BBA5D');
        this.setTooltip('The properties of a stylus pointer. These include the properties from the underlying stylus pick that the pointer uses.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.StylusPointerProperties');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_StylusPointerProperties'] = (block, generator) => {
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hover = dfv(generator.valueToCode(block, 'hover', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _pointerType = dfv(generator.valueToCode(block, 'pointerType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pickID = dfv(generator.valueToCode(block, 'pickID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Pointers.StylusPointerProperties(${_model},${_hover},${_pointerType},${_pickID})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_StylusPointerModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.StylusPointerModel')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('positionOffset') 
            .setCheck('Vec3')
            .appendField('positionOffset');
        this.appendValueInput('rotationOffset') 
            .setCheck('Quat')
            .appendField('rotationOffset');
        this.setColour('#7BBA5D');
        this.setTooltip('The properties of a stylus pointer model.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.StylusPointerModel');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_StylusPointerModel'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _positionOffset = dfv(generator.valueToCode(block, 'positionOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotationOffset = dfv(generator.valueToCode(block, 'rotationOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Pointers.StylusPointerModel(${_url},${_dimensions},${_positionOffset},${_rotationOffset})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_DefaultRayPointerRenderState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.DefaultRayPointerRenderState')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.setColour('#7BBA5D');
        this.setTooltip('Properties that define the visual appearance of a ray pointer when the pointer is not intersecting something. These are the properties of {@link Pointers.RayPointerRenderState} but with an additional property.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.DefaultRayPointerRenderState');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_DefaultRayPointerRenderState'] = (block, generator) => {
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Pointers.DefaultRayPointerRenderState(${_distance})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_RayPointerRenderState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.RayPointerRenderState')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('start') 
            .setCheck('Entities.EntityProperties')
            .appendField('start');
        this.appendValueInput('path') 
            .setCheck('Entities.EntityProperties')
            .appendField('path');
        this.appendValueInput('end') 
            .setCheck('Entities.EntityProperties')
            .appendField('end');
        this.setColour('#7BBA5D');
        this.setTooltip('Properties that define the visual appearance of a ray pointer when the pointer is intersecting something.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.RayPointerRenderState');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_RayPointerRenderState'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _start = dfv(generator.valueToCode(block, 'start', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _end = dfv(generator.valueToCode(block, 'end', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Pointers.RayPointerRenderState(${_name},${_start},${_path},${_end})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_RayPointerProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.RayPointerProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('faceAvatar') 
            .setCheck('Boolean')
            .appendField('faceAvatar');
        this.appendValueInput('centerEndY') 
            .setCheck('Boolean')
            .appendField('centerEndY');
        this.appendValueInput('lockEnd') 
            .setCheck('Boolean')
            .appendField('lockEnd');
        this.appendValueInput('distanceScaleEnd') 
            .setCheck('Boolean')
            .appendField('distanceScaleEnd');
        this.appendValueInput('scaleWithParent') 
            .setCheck('Boolean')
            .appendField('scaleWithParent');
        this.appendValueInput('scaleWithAvatar') 
            .setCheck('Boolean')
            .appendField('scaleWithAvatar');
        this.appendValueInput('followNormal') 
            .setCheck('Boolean')
            .appendField('followNormal');
        this.appendValueInput('followNormalStrength') 
            .setCheck('Number')
            .appendField('followNormalStrength');
        this.appendValueInput('renderStates') 
            .setCheck('Array')
            .appendField('renderStates');
        this.appendValueInput('defaultRenderStates') 
            .setCheck('Array')
            .appendField('defaultRenderStates');
        this.appendValueInput('hover') 
            .setCheck('Boolean')
            .appendField('hover');
        this.appendValueInput('triggers') 
            .setCheck('Array')
            .appendField('triggers');
        this.appendValueInput('pointerType') 
            .setCheck('PickType')
            .appendField('pointerType');
        this.appendValueInput('pickID') 
            .setCheck('Number')
            .appendField('pickID');
        this.setColour('#7BBA5D');
        this.setTooltip('The properties of a ray pointer. These include the properties from the underlying ray pick that the pointer uses.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.RayPointerProperties');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_RayPointerProperties'] = (block, generator) => {
    const _faceAvatar = dfv(generator.valueToCode(block, 'faceAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _centerEndY = dfv(generator.valueToCode(block, 'centerEndY', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _lockEnd = dfv(generator.valueToCode(block, 'lockEnd', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _distanceScaleEnd = dfv(generator.valueToCode(block, 'distanceScaleEnd', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _scaleWithParent = dfv(generator.valueToCode(block, 'scaleWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _scaleWithAvatar = dfv(generator.valueToCode(block, 'scaleWithAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _followNormal = dfv(generator.valueToCode(block, 'followNormal', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _followNormalStrength = dfv(generator.valueToCode(block, 'followNormalStrength', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _renderStates = dfv(generator.valueToCode(block, 'renderStates', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultRenderStates = dfv(generator.valueToCode(block, 'defaultRenderStates', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hover = dfv(generator.valueToCode(block, 'hover', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _triggers = dfv(generator.valueToCode(block, 'triggers', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _pointerType = dfv(generator.valueToCode(block, 'pointerType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pickID = dfv(generator.valueToCode(block, 'pickID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Pointers.RayPointerProperties(${_faceAvatar},${_centerEndY},${_lockEnd},${_distanceScaleEnd},${_scaleWithParent},${_scaleWithAvatar},${_followNormal},${_followNormalStrength},${_renderStates},${_defaultRenderStates},${_hover},${_triggers},${_pointerType},${_pickID})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_ParabolaPointerPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.ParabolaPointerPath')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('isVisibleInSecondaryCamera') 
            .setCheck('Boolean')
            .appendField('isVisibleInSecondaryCamera');
        this.appendValueInput('drawInFront') 
            .setCheck('Boolean')
            .appendField('drawInFront');
        this.setColour('#7BBA5D');
        this.setTooltip('The visual appearance of the parabolic path.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.ParabolaPointerPath');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_ParabolaPointerPath'] = (block, generator) => {
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0.01`);
    const _isVisibleInSecondaryCamera = dfv(generator.valueToCode(block, 'isVisibleInSecondaryCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _drawInFront = dfv(generator.valueToCode(block, 'drawInFront', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Pointers.ParabolaPointerPath(${_color},${_alpha},${_width},${_isVisibleInSecondaryCamera},${_drawInFront})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_DefaultParabolaPointerRenderState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.DefaultParabolaPointerRenderState')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.setColour('#7BBA5D');
        this.setTooltip('Properties that define the visual appearance of a parabola pointer when the pointer is not intersecting something. These areproperties of {@link Pointers.ParabolaPointerRenderState} but with an additional property.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.DefaultParabolaPointerRenderState');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_DefaultParabolaPointerRenderState'] = (block, generator) => {
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Pointers.DefaultParabolaPointerRenderState(${_distance})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_ParabolaPointerRenderState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.ParabolaPointerRenderState')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('start') 
            .setCheck('Entities.EntityProperties')
            .appendField('start');
        this.appendValueInput('path') 
            .setCheck('Pointers.ParabolaPointerPath')
            .appendField('path');
        this.appendValueInput('end') 
            .setCheck('Entities.EntityProperties')
            .appendField('end');
        this.setColour('#7BBA5D');
        this.setTooltip('Properties that define the visual appearance of a parabola pointer when the pointer is intersecting something.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.ParabolaPointerRenderState');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_ParabolaPointerRenderState'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _start = dfv(generator.valueToCode(block, 'start', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _end = dfv(generator.valueToCode(block, 'end', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Pointers.ParabolaPointerRenderState(${_name},${_start},${_path},${_end})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_ParabolaPointerProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.ParabolaPointerProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('faceAvatar') 
            .setCheck('Boolean')
            .appendField('faceAvatar');
        this.appendValueInput('centerEndY') 
            .setCheck('Boolean')
            .appendField('centerEndY');
        this.appendValueInput('lockEnd') 
            .setCheck('Boolean')
            .appendField('lockEnd');
        this.appendValueInput('distanceScaleEnd') 
            .setCheck('Boolean')
            .appendField('distanceScaleEnd');
        this.appendValueInput('scaleWithParent') 
            .setCheck('Boolean')
            .appendField('scaleWithParent');
        this.appendValueInput('scaleWithAvatar') 
            .setCheck('Boolean')
            .appendField('scaleWithAvatar');
        this.appendValueInput('followNormal') 
            .setCheck('Boolean')
            .appendField('followNormal');
        this.appendValueInput('followNormalStrength') 
            .setCheck('Number')
            .appendField('followNormalStrength');
        this.appendValueInput('renderStates') 
            .setCheck('Array')
            .appendField('renderStates');
        this.appendValueInput('defaultRenderStates') 
            .setCheck('Array')
            .appendField('defaultRenderStates');
        this.appendValueInput('hover') 
            .setCheck('Boolean')
            .appendField('hover');
        this.appendValueInput('triggers') 
            .setCheck('Array')
            .appendField('triggers');
        this.appendValueInput('pointerType') 
            .setCheck('PickType')
            .appendField('pointerType');
        this.appendValueInput('pickID') 
            .setCheck('Number')
            .appendField('pickID');
        this.setColour('#7BBA5D');
        this.setTooltip('The properties of a parabola pointer. These include the properties from the underlying parabola pick that the pointer uses.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.ParabolaPointerProperties');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_ParabolaPointerProperties'] = (block, generator) => {
    const _faceAvatar = dfv(generator.valueToCode(block, 'faceAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _centerEndY = dfv(generator.valueToCode(block, 'centerEndY', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _lockEnd = dfv(generator.valueToCode(block, 'lockEnd', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _distanceScaleEnd = dfv(generator.valueToCode(block, 'distanceScaleEnd', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _scaleWithParent = dfv(generator.valueToCode(block, 'scaleWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _scaleWithAvatar = dfv(generator.valueToCode(block, 'scaleWithAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _followNormal = dfv(generator.valueToCode(block, 'followNormal', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _followNormalStrength = dfv(generator.valueToCode(block, 'followNormalStrength', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _renderStates = dfv(generator.valueToCode(block, 'renderStates', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultRenderStates = dfv(generator.valueToCode(block, 'defaultRenderStates', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hover = dfv(generator.valueToCode(block, 'hover', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _triggers = dfv(generator.valueToCode(block, 'triggers', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _pointerType = dfv(generator.valueToCode(block, 'pointerType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pickID = dfv(generator.valueToCode(block, 'pickID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Pointers.ParabolaPointerProperties(${_faceAvatar},${_centerEndY},${_lockEnd},${_distanceScaleEnd},${_scaleWithParent},${_scaleWithAvatar},${_followNormal},${_followNormalStrength},${_renderStates},${_defaultRenderStates},${_hover},${_triggers},${_pointerType},${_pickID})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pointers_Trigger'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.Trigger')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('action') 
            .setCheck('Controller.Standard')
            .appendField('action');
        this.appendValueInput('button') 
            .setCheck('String')
            .appendField('button');
        this.setColour('#7BBA5D');
        this.setTooltip('Specifies that a {@link Controller} action or function should trigger events on the entity or overlay currently intersected by a {@link Pointers.RayPointerProperties|Ray} or {@link Pointers.ParabolaPointerProperties|Parabola} pointer.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.Trigger');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_Trigger'] = (block, generator) => {
    const _action = dfv(generator.valueToCode(block, 'action', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _button = dfv(generator.valueToCode(block, 'button', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Pointers.Trigger(${_action},${_button})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Pointers_createPointer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.createPointer')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('type') 
            .setCheck('PickType')
            .appendField('type');
        this.appendValueInput('properties') 
            .setCheck('Pointers.RayPointerProperties')
            .appendField('properties');

        this.setColour('#7BBA5D');
        this.setTooltip('Creates a new ray, parabola, or stylus pointer. The pointer can have a wide range of behaviors depending on the properties specified. For example, a ray pointer may be a static ray pointer, a mouse ray pointer, or joint ray pointer.<p><strong>Warning:</strong> Pointers created using this method currently always intersect at least visible and collidable things but this may not always be the case.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.createPointer');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_createPointer'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Pointers.createPointer(${_type},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_enablePointer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.enablePointer')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Enables and shows a pointer. Enabled pointers update their pick results and generate events.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.enablePointer');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_enablePointer'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Pointers.enablePointer(${_id});\n`;};


// Blockly function
Blockly.Blocks['Pointers_disablePointer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.disablePointer')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Disables and hides a pointer. Disabled pointers do not update their pick results or generate events.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.disablePointer');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_disablePointer'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Pointers.disablePointer(${_id});\n`;};


// Blockly function
Blockly.Blocks['Pointers_isPointerEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.isPointerEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Gets the enabled status of a pointer. Enabled pointers update their pick results and generate events.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.isPointerEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_isPointerEnabled'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.isPointerEnabled(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_removePointer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.removePointer')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Removes (deletes) a pointer.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.removePointer');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_removePointer'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Pointers.removePointer(${_id});\n`;};


// Blockly function
Blockly.Blocks['Pointers_getPointerScriptParameters'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.getPointerScriptParameters')
        // Returns data
        this.setOutput(true, '["Pointers.RayPointerProperties"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Gets the parameters that were passed in to {@link Pointers.createPointer} to create the pointer when the pointer was created through a script. <p><strong>Note:</strong> These properties do not reflect the current state of the pointer. To get the current state of the pointer, see {@link Pointers.getPointerProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.getPointerScriptParameters');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_getPointerScriptParameters'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.getPointerScriptParameters(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_getPointers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.getPointers')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#7BBA5D');
        this.setTooltip('Gets all pointers which currently exist, including disabled pointers.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.getPointers');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_getPointers'] = (block, generator) => {

return [`Pointers.getPointers()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_editRenderState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.editRenderState')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('renderState') 
            .setCheck('String')
            .appendField('renderState');
        this.appendValueInput('properties') 
            .setCheck('Pointers.RayPointerRenderState')
            .appendField('properties');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Edits a render state of a {@link Pointers.RayPointerProperties|ray} or {@link Pointers.ParabolaPointerProperties|parabola} pointer, to change its visual appearance for the state when the pointer is intersecting something.<p><strong>Note:</strong> You can only edit the properties of the existing parts of the pointer; you cannot change the type of any part.</p><p><strong>Note:</strong> You cannot use this method to change the appearance of a default render state.</p><p><strong>Note:</strong> Not able to be used with stylus pointers.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.editRenderState');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_editRenderState'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _renderState = dfv(generator.valueToCode(block, 'renderState', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Pointers.editRenderState(${_id},${_renderState},${_properties});\n`;};


// Blockly function
Blockly.Blocks['Pointers_setRenderState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setRenderState')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('renderState') 
            .setCheck('String')
            .appendField('renderState');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Sets the render state of a pointer, to change its visual appearance and possibly disable or enable it.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setRenderState');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setRenderState'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _renderState = dfv(generator.valueToCode(block, 'renderState', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Pointers.setRenderState(${_id},${_renderState});\n`;};


// Blockly function
Blockly.Blocks['Pointers_getPrevPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.getPrevPickResult')
        // Returns data
        this.setOutput(true, '["RayPickResult"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Gets the most recent intersection of a pointer. A pointer continues to be updated ready to return a result, as long as  it is enabled, regardless of the render state.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.getPrevPickResult');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_getPrevPickResult'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.getPrevPickResult(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_setPrecisionPicking'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setPrecisionPicking')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('precisionPicking') 
            .setCheck('Boolean')
            .appendField('precisionPicking');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Sets whether or not a pointer should use precision picking, i.e., whether it should pick against precise meshes or coarse meshes. This has the same effect as using the <code>PICK_PRECISE</code> or <code>PICK_COARSE</code> filter flags.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setPrecisionPicking');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setPrecisionPicking'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _precisionPicking = dfv(generator.valueToCode(block, 'precisionPicking', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Pointers.setPrecisionPicking(${_id},${_precisionPicking});\n`;};


// Blockly function
Blockly.Blocks['Pointers_setLength'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setLength')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('length') 
            .setCheck('Number')
            .appendField('length');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Sets the length of a pointer.<p><strong>Note:</strong> Not used by stylus pointers.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setLength');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setLength'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _length = dfv(generator.valueToCode(block, 'length', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Pointers.setLength(${_id},${_length});\n`;};


// Blockly function
Blockly.Blocks['Pointers_setIgnoreItems'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setIgnoreItems')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('ignoreItems') 
            .setCheck('Array')
            .appendField('ignoreItems');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Sets a list of entity and avatar IDs that a pointer should ignore during intersection.<p><strong>Note:</strong> Not used by stylus pointers.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setIgnoreItems');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setIgnoreItems'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _ignoreItems = dfv(generator.valueToCode(block, 'ignoreItems', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Pointers.setIgnoreItems(${_id},${_ignoreItems});\n`;};


// Blockly function
Blockly.Blocks['Pointers_setIncludeItems'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setIncludeItems')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('includeItems') 
            .setCheck('Array')
            .appendField('includeItems');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Sets a list of entity and avatar IDs that a pointer should include during intersection, instead of intersecting with everything.  <p><strong>Note:</strong> Stylus pointers only intersect with items in their include list.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setIncludeItems');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setIncludeItems'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _includeItems = dfv(generator.valueToCode(block, 'includeItems', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Pointers.setIncludeItems(${_id},${_includeItems});\n`;};


// Blockly function
Blockly.Blocks['Pointers_setLockEndUUID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setLockEndUUID')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('targetID') 
            .setCheck('Uuid')
            .appendField('targetID');
        this.appendValueInput('isAvatar') 
            .setCheck('Boolean')
            .appendField('isAvatar');
        this.appendValueInput('offset') 
            .setCheck('Mat4')
            .appendField('offset');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Locks a pointer onto a specific entity or avatar.<p><strong>Note:</strong> Not used by stylus pointers.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setLockEndUUID');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setLockEndUUID'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _targetID = dfv(generator.valueToCode(block, 'targetID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isAvatar = dfv(generator.valueToCode(block, 'isAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _offset = dfv(generator.valueToCode(block, 'offset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Pointers.setLockEndUUID(${_id},${_targetID},${_isAvatar},${_offset});\n`;};


// Blockly function
Blockly.Blocks['Pointers_setDelay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.setDelay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('delay') 
            .setCheck('Number')
            .appendField('delay');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7BBA5D');
        this.setTooltip('Sets the delay of a Ray pointer.<p><strong>Note:</strong> Not used by stylus or parabola pointers.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.setDelay');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_setDelay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _delay = dfv(generator.valueToCode(block, 'delay', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Pointers.setDelay(${_id},${_delay});\n`;};


// Blockly function
Blockly.Blocks['Pointers_isLeftHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.isLeftHand')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Checks if a pointer is associated with the left hand: a ray or parabola pointer with <code>joint</code> property set to<code>"_CONTROLLER_LEFTHAND"</code> or <code>"_CAMERA_RELATIVE_CONTROLLER_LEFTHAND"</code>, or a stylus pointer with <code>hand</code> property set to <code>0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.isLeftHand');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_isLeftHand'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.isLeftHand(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_isRightHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.isRightHand')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Checks if a pointer is associated with the right hand: a ray or parabola pointer with <code>joint</code> property set to<code>"_CONTROLLER_RIGHTHAND"</code> or <code>"_CAMERA_RELATIVE_CONTROLLER_RIGHTHAND"</code>, or a stylus pointer with <code>hand</code> property set to <code>1</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.isRightHand');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_isRightHand'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.isRightHand(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_isMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.isMouse')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Checks if a pointer is associated with the system mouse: a ray or parabola pointer with <code>joint</code> property set to <code>"Mouse"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.isMouse');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_isMouse'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.isMouse(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Pointers_getPointerProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pointers.getPointerProperties')
        // Returns data
        this.setOutput(true, '["Pointers.RayPointerProperties"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#7BBA5D');
        this.setTooltip('Gets information about a pointer.');
        this.setHelpUrl('https://apidocs.overte.org/Pointers.html#.getPointerProperties');
    }
};
javascript.javascriptGenerator.forBlock['Pointers_getPointerProperties'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Pointers.getPointerProperties(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['RayPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPickResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('IntersectionType')
            .appendField('type');
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('objectID') 
            .setCheck('Uuid')
            .appendField('objectID');
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.appendValueInput('intersection') 
            .setCheck('Vec3')
            .appendField('intersection');
        this.appendValueInput('surfaceNormal') 
            .setCheck('Vec3')
            .appendField('surfaceNormal');
        this.appendValueInput('extraInfo') 
            .setCheck('SubmeshIntersection')
            .appendField('extraInfo');
        this.appendValueInput('searchRay') 
            .setCheck('PickRay')
            .appendField('searchRay');
        this.setColour('#83E418');
        this.setTooltip('An intersection result for a ray pick.');
        this.setHelpUrl('https://apidocs.overte.org/RayPickResult');
    }
};
javascript.javascriptGenerator.forBlock['RayPickResult'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _objectID = dfv(generator.valueToCode(block, 'objectID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _intersection = dfv(generator.valueToCode(block, 'intersection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _surfaceNormal = dfv(generator.valueToCode(block, 'surfaceNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extraInfo = dfv(generator.valueToCode(block, 'extraInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _searchRay = dfv(generator.valueToCode(block, 'searchRay', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new RayPickResult(${_type},${_intersects},${_objectID},${_distance},${_intersection},${_surfaceNormal},${_extraInfo},${_searchRay})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['RayPick_createRayPick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.createRayPick')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('properties') 
            .setCheck('Picks.RayPickProperties')
            .appendField('properties');

        this.setColour('#BF161D');
        this.setTooltip('Creates a new ray pick.<p><strong>Warning:</strong> Picks created using this method currently always intersect at least visible and collidablethings but this may not always be the case.</p>');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.createRayPick');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_createRayPick'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RayPick.createRayPick(${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RayPick_enableRayPick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.enableRayPick')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BF161D');
        this.setTooltip('Enables a ray pick.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.enableRayPick');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_enableRayPick'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `RayPick.enableRayPick(${_id});\n`;};


// Blockly function
Blockly.Blocks['RayPick_disableRayPick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.disableRayPick')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BF161D');
        this.setTooltip('Disables a ray pick.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.disableRayPick');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_disableRayPick'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `RayPick.disableRayPick(${_id});\n`;};


// Blockly function
Blockly.Blocks['RayPick_removeRayPick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.removeRayPick')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BF161D');
        this.setTooltip('Removes (deletes) a ray pick.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.removeRayPick');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_removeRayPick'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `RayPick.removeRayPick(${_id});\n`;};


// Blockly function
Blockly.Blocks['RayPick_getPrevRayPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.getPrevRayPickResult')
        // Returns data
        this.setOutput(true, '["RayPickResult"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#BF161D');
        this.setTooltip('Gets the most recent pick result from a ray pick. A ray pick continues to be updated ready to return a result, as long as it is enabled.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.getPrevRayPickResult');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_getPrevRayPickResult'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RayPick.getPrevRayPickResult(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RayPick_setPrecisionPicking'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.setPrecisionPicking')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('precisionPicking') 
            .setCheck('Boolean')
            .appendField('precisionPicking');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BF161D');
        this.setTooltip('Sets whether or not a ray pick should use precision picking, i.e., whether it should pick against precise meshes or coarse meshes.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.setPrecisionPicking');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_setPrecisionPicking'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _precisionPicking = dfv(generator.valueToCode(block, 'precisionPicking', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `RayPick.setPrecisionPicking(${_id},${_precisionPicking});\n`;};


// Blockly function
Blockly.Blocks['RayPick_setIgnoreItems'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.setIgnoreItems')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('ignoreItems') 
            .setCheck('Array')
            .appendField('ignoreItems');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BF161D');
        this.setTooltip('Sets a list of entity and avatar IDs that a ray pick should ignore during intersection.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.setIgnoreItems');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_setIgnoreItems'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _ignoreItems = dfv(generator.valueToCode(block, 'ignoreItems', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `RayPick.setIgnoreItems(${_id},${_ignoreItems});\n`;};


// Blockly function
Blockly.Blocks['RayPick_setIncludeItems'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.setIncludeItems')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('includeItems') 
            .setCheck('Array')
            .appendField('includeItems');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BF161D');
        this.setTooltip('Sets a list of entity and avatar IDs that a ray pick should include during intersection, instead of intersecting with everything.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.setIncludeItems');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_setIncludeItems'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _includeItems = dfv(generator.valueToCode(block, 'includeItems', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `RayPick.setIncludeItems(${_id},${_includeItems});\n`;};


// Blockly function
Blockly.Blocks['RayPick_isLeftHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.isLeftHand')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#BF161D');
        this.setTooltip('Checks if a pick is associated with the left hand: a ray or parabola pick with <code>joint</code> property set to<code>"_CONTROLLER_LEFTHAND"</code> or <code>"_CAMERA_RELATIVE_CONTROLLER_LEFTHAND"</code>, or a stylus pick with <code>hand</code> property set to <code>0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.isLeftHand');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_isLeftHand'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RayPick.isLeftHand(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RayPick_isRightHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.isRightHand')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#BF161D');
        this.setTooltip('Checks if a pick is associated with the right hand: a ray or parabola pick with <code>joint</code> property set to<code>"_CONTROLLER_RIGHTHAND"</code> or <code>"_CAMERA_RELATIVE_CONTROLLER_RIGHTHAND"</code>, or a stylus pick with <code>hand</code> property set to <code>1</code>.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.isRightHand');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_isRightHand'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RayPick.isRightHand(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RayPick_isMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayPick.isMouse')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setColour('#BF161D');
        this.setTooltip('Checks if a pick is associated with the system mouse: a ray or parabola pick with <code>joint</code> property set to <code>"Mouse"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/RayPick.html#.isMouse');
    }
};
javascript.javascriptGenerator.forBlock['RayPick_isMouse'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RayPick.isMouse(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['StylusPickResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('StylusPickResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('Number')
            .appendField('type');
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('objectID') 
            .setCheck('Uuid')
            .appendField('objectID');
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.appendValueInput('intersection') 
            .setCheck('Vec3')
            .appendField('intersection');
        this.appendValueInput('surfaceNormal') 
            .setCheck('Vec3')
            .appendField('surfaceNormal');
        this.appendValueInput('stylusTip') 
            .setCheck('StylusTip')
            .appendField('stylusTip');
        this.setColour('#492D56');
        this.setTooltip('An intersection result for a stylus pick.');
        this.setHelpUrl('https://apidocs.overte.org/StylusPickResult');
    }
};
javascript.javascriptGenerator.forBlock['StylusPickResult'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _objectID = dfv(generator.valueToCode(block, 'objectID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _intersection = dfv(generator.valueToCode(block, 'intersection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _surfaceNormal = dfv(generator.valueToCode(block, 'surfaceNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _stylusTip = dfv(generator.valueToCode(block, 'stylusTip', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new StylusPickResult(${_type},${_intersects},${_objectID},${_distance},${_intersection},${_surfaceNormal},${_stylusTip})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AccountServices_DownloadInfoResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.DownloadInfoResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('downloading') 
            .setCheck('Array')
            .appendField('downloading');
        this.appendValueInput('pending') 
            .setCheck('Number')
            .appendField('pending');
        this.setColour('#063210');
        this.setTooltip('Information on the assets currently being downloaded and pending download.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.DownloadInfoResult');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_DownloadInfoResult'] = (block, generator) => {
    const _downloading = dfv(generator.valueToCode(block, 'downloading', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pending = dfv(generator.valueToCode(block, 'pending', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new AccountServices.DownloadInfoResult(${_downloading},${_pending})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['AccountServices_username'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.username')       
        this.setOutput(true, '');
        this.setColour('#063210');
        this.setTooltip('The user name of the user logged in. If there is no user logged in, it is    <code>"Unknown user"</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.username');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_username'] = (block, generator) => {
    return [`AccountServices.username`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AccountServices_loggedIn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.loggedIn')       
        this.setOutput(true, '');
        this.setColour('#063210');
        this.setTooltip('<code>true</code> if the user is logged in, otherwise <code>false</code>.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.loggedIn');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_loggedIn'] = (block, generator) => {
    return [`AccountServices.loggedIn`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AccountServices_findableBy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.findableBy')       
        this.setOutput(true, '');
        this.setColour('#063210');
        this.setTooltip('The user\'s visibility to other users:    <ul>        <li><code>"none"</code> &mdash; user appears offline.</li>        <li><code>"friends"</code> &mdash; user is visible only to friends.</li>        <li><code>"connections"</code> &mdash; user is visible to friends and connections.</li>        <li><code>"all"</code> &mdash; user is visible to everyone.</li>    </ul>');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.findableBy');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_findableBy'] = (block, generator) => {
    return [`AccountServices.findableBy`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AccountServices_metaverseServerURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.metaverseServerURL')       
        this.setOutput(true, '');
        this.setColour('#063210');
        this.setTooltip('The metaverse server that the user is authenticated against when logged in    &mdash; typically <code>"https://metaverse.highfidelity.com"</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.metaverseServerURL');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_metaverseServerURL'] = (block, generator) => {
    return [`AccountServices.metaverseServerURL`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['AccountServices_getDownloadInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.getDownloadInfo')
        // Returns data
        this.setOutput(true, '["AccountServices.DownloadInfoResult"]');

        // Params data

        this.setColour('#063210');
        this.setTooltip('Gets information on the download progress of assets in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.getDownloadInfo');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_getDownloadInfo'] = (block, generator) => {

return [`AccountServices.getDownloadInfo()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AccountServices_updateDownloadInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.updateDownloadInfo')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#063210');
        this.setTooltip('Triggers a {@link AccountServices.downloadInfoChanged|downloadInfoChanged} signal with information on the current download progress of the assets in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.updateDownloadInfo');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_updateDownloadInfo'] = (block, generator) => {


    return `AccountServices.updateDownloadInfo();\n`;};


// Blockly function
Blockly.Blocks['AccountServices_isLoggedIn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.isLoggedIn')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#063210');
        this.setTooltip('Checks whether the user is logged in.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.isLoggedIn');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_isLoggedIn'] = (block, generator) => {

return [`AccountServices.isLoggedIn()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AccountServices_checkAndSignalForAccessToken'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.checkAndSignalForAccessToken')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#063210');
        this.setTooltip('The function returns the login status of the user and prompts the user to log in (with a login dialog) if they\'re not already logged in.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.checkAndSignalForAccessToken');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_checkAndSignalForAccessToken'] = (block, generator) => {

return [`AccountServices.checkAndSignalForAccessToken()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AccountServices_logOut'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.logOut')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#063210');
        this.setTooltip('Logs the user out.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.logOut');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_logOut'] = (block, generator) => {


    return `AccountServices.logOut();\n`;};


// Blockly function
Blockly.Blocks['AccountServices_updateAuthURLFromMetaverseServerURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AccountServices.updateAuthURLFromMetaverseServerURL')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#063210');
        this.setTooltip('Updates Directory Server URL in AccountManager. It\'s called by Login window after Directory Server URL is changed.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.updateAuthURLFromMetaverseServerURL');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_updateAuthURLFromMetaverseServerURL'] = (block, generator) => {


    return `AccountServices.updateAuthURLFromMetaverseServerURL();\n`;};


// Blockly signal
Blockly.Blocks['AccountServices_connected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AccountServices.connected');


        this.setColour('#063210');
        this.setTooltip('Not currently used.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.connected');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_connected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AccountServices.connected.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AccountServices_disconnected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AccountServices.disconnected');

        this.appendDummyInput('reason')
            .appendField('reason:')
            .appendField(new Blockly.FieldVariable('disconnected_reason'), 'reason');

        this.setColour('#063210');
        this.setTooltip('Triggered when the user logs out.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.disconnected');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_disconnected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const reason = generator.getVariableName(block.getFieldValue('reason'));

return `AccountServices.disconnected.connect((_reason) => { 
  ${reason} = _reason;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AccountServices_myUsernameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AccountServices.myUsernameChanged');

        this.appendDummyInput('username')
            .appendField('username:')
            .appendField(new Blockly.FieldVariable('myUsernameChanged_username'), 'username');

        this.setColour('#063210');
        this.setTooltip('Triggered when the username logged in with changes, i.e., when the user logs in or out.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.myUsernameChanged');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_myUsernameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const username = generator.getVariableName(block.getFieldValue('username'));

return `AccountServices.myUsernameChanged.connect((_username) => { 
  ${username} = _username;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AccountServices_downloadInfoChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AccountServices.downloadInfoChanged');

        this.appendDummyInput('downloadInfo')
            .appendField('downloadInfo:')
            .appendField(new Blockly.FieldVariable('downloadInfoChanged_downloadInfo'), 'downloadInfo');

        this.setColour('#063210');
        this.setTooltip('Triggered when the download progress of the assets in the domain changes.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.downloadInfoChanged');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_downloadInfoChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const downloadInfo = generator.getVariableName(block.getFieldValue('downloadInfo'));

return `AccountServices.downloadInfoChanged.connect((_downloadInfo) => { 
  ${downloadInfo} = _downloadInfo;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AccountServices_findableByChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AccountServices.findableByChanged');

        this.appendDummyInput('findableBy')
            .appendField('findableBy:')
            .appendField(new Blockly.FieldVariable('findableByChanged_findableBy'), 'findableBy');

        this.setColour('#063210');
        this.setTooltip('Triggered when the user\'s visibility to others changes.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.findableByChanged');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_findableByChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const findableBy = generator.getVariableName(block.getFieldValue('findableBy'));

return `AccountServices.findableByChanged.connect((_findableBy) => { 
  ${findableBy} = _findableBy;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AccountServices_loggedInChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AccountServices.loggedInChanged');

        this.appendDummyInput('loggedIn')
            .appendField('loggedIn:')
            .appendField(new Blockly.FieldVariable('loggedInChanged_loggedIn'), 'loggedIn');

        this.setColour('#063210');
        this.setTooltip('Triggered when the login status of the user changes.');
        this.setHelpUrl('https://apidocs.overte.org/AccountServices.html#.loggedInChanged');
    }
};
javascript.javascriptGenerator.forBlock['AccountServices_loggedInChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const loggedIn = generator.getVariableName(block.getFieldValue('loggedIn'));

return `AccountServices.loggedInChanged.connect((_loggedIn) => { 
  ${loggedIn} = _loggedIn;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Audio_muted'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.muted')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if the audio input is muted for the current user context (desktop or HMD),     otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.muted');
    }
};
javascript.javascriptGenerator.forBlock['Audio_muted'] = (block, generator) => {
    return [`Audio.muted`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_mutedDesktop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.mutedDesktop')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if desktop audio input is muted, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.mutedDesktop');
    }
};
javascript.javascriptGenerator.forBlock['Audio_mutedDesktop'] = (block, generator) => {
    return [`Audio.mutedDesktop`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_mutedHMD'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.mutedHMD')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if the HMD input is muted, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.mutedHMD');
    }
};
javascript.javascriptGenerator.forBlock['Audio_mutedHMD'] = (block, generator) => {
    return [`Audio.mutedHMD`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_warnWhenMuted'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.warnWhenMuted')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if the "muted" warning is enabled, otherwise <code>false</code>.    When enabled, if you speak while your microphone is muted, "muted" is displayed on the screen as a warning.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.warnWhenMuted');
    }
};
javascript.javascriptGenerator.forBlock['Audio_warnWhenMuted'] = (block, generator) => {
    return [`Audio.warnWhenMuted`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_noiseReduction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.noiseReduction')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if noise reduction is enabled, otherwise <code>false</code>. When    enabled, the input audio signal is blocked (fully attenuated) when it falls below an adaptive threshold set just    above the noise floor.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseReduction');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseReduction'] = (block, generator) => {
    return [`Audio.noiseReduction`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_noiseReductionAutomatic'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.noiseReductionAutomatic')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if audio input noise reduction automatic mode is enabled,     <code>false</code> if in manual mode. Manual mode allows you to use <code>Audio.noiseReductionThreshold</code>    to set a manual sensitivity for the noise gate.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseReductionAutomatic');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseReductionAutomatic'] = (block, generator) => {
    return [`Audio.noiseReductionAutomatic`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_noiseReductionThreshold'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.noiseReductionThreshold')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('Sets the noise gate threshold before your mic audio is transmitted.     (Applies only if <code>Audio.noiseReductionAutomatic</code> is <code>false</code>.)');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseReductionThreshold');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseReductionThreshold'] = (block, generator) => {
    return [`Audio.noiseReductionThreshold`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_inputVolume'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.inputVolume')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('Adjusts the volume of the input audio, range <code>0.0</code> &ndash; <code>1.0</code>.     If set to a value, the resulting value depends on the input device: for example, the volume can\'t be changed on some     devices, and others might only support values of <code>0.0</code> and <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.inputVolume');
    }
};
javascript.javascriptGenerator.forBlock['Audio_inputVolume'] = (block, generator) => {
    return [`Audio.inputVolume`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_inputLevel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.inputLevel')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The loudness of the audio input, range <code>0.0</code> (no sound) &ndash;    <code>1.0</code> (the onset of clipping). <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.inputLevel');
    }
};
javascript.javascriptGenerator.forBlock['Audio_inputLevel'] = (block, generator) => {
    return [`Audio.inputLevel`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_clipping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.clipping')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if the audio input is clipping, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.clipping');
    }
};
javascript.javascriptGenerator.forBlock['Audio_clipping'] = (block, generator) => {
    return [`Audio.clipping`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_context'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.context')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The current context of the audio: either <code>"Desktop"</code> or <code>"HMD"</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.context');
    }
};
javascript.javascriptGenerator.forBlock['Audio_context'] = (block, generator) => {
    return [`Audio.context`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_devices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.devices')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.devices');
    }
};
javascript.javascriptGenerator.forBlock['Audio_devices'] = (block, generator) => {
    return [`Audio.devices`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_pushToTalk'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.pushToTalk')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if push-to-talk is enabled for the current user context (desktop or     HMD), otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushToTalk');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushToTalk'] = (block, generator) => {
    return [`Audio.pushToTalk`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_pushToTalkDesktop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.pushToTalkDesktop')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if desktop push-to-talk is enabled, otherwise     <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushToTalkDesktop');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushToTalkDesktop'] = (block, generator) => {
    return [`Audio.pushToTalkDesktop`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_pushToTalkHMD'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.pushToTalkHMD')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if HMD push-to-talk is enabled, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushToTalkHMD');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushToTalkHMD'] = (block, generator) => {
    return [`Audio.pushToTalkHMD`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_pushingToTalk'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.pushingToTalk')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if the user is currently pushing-to-talk, otherwise     <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushingToTalk');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushingToTalk'] = (block, generator) => {
    return [`Audio.pushingToTalk`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_avatarGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.avatarGain')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The gain (relative volume in dB) that avatars\' voices are played at. This gain is used     at the server.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.avatarGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_avatarGain'] = (block, generator) => {
    return [`Audio.avatarGain`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_localInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.localInjectorGain')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The gain (relative volume in dB) that local injectors (local environment sounds)    are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.localInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_localInjectorGain'] = (block, generator) => {
    return [`Audio.localInjectorGain`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_serverInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.serverInjectorGain')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The gain (relative volume in dB) that server injectors (server environment     sounds) are played at. This gain is used at the server.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.serverInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_serverInjectorGain'] = (block, generator) => {
    return [`Audio.serverInjectorGain`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_systemInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.systemInjectorGain')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The gain (relative volume in dB) that system sounds are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.systemInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_systemInjectorGain'] = (block, generator) => {
    return [`Audio.systemInjectorGain`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_pushingToTalkOutputGainDesktop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.pushingToTalkOutputGainDesktop')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The gain (relative volume in dB) that all sounds are played at when     the user is holding the push-to-talk key in desktop mode.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushingToTalkOutputGainDesktop');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushingToTalkOutputGainDesktop'] = (block, generator) => {
    return [`Audio.pushingToTalkOutputGainDesktop`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_acousticEchoCancellation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.acousticEchoCancellation')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if acoustic echo cancellation is enabled, otherwise    <code>false</code>. When enabled, sound from the audio output is suppressed when it echos back to the input audio     signal.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.acousticEchoCancellation');
    }
};
javascript.javascriptGenerator.forBlock['Audio_acousticEchoCancellation'] = (block, generator) => {
    return [`Audio.acousticEchoCancellation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_isStereoInput'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.isStereoInput')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if the input audio is being used in stereo, otherwise    <code>false</code>. Some devices do not support stereo, in which case the value is always <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.isStereoInput');
    }
};
javascript.javascriptGenerator.forBlock['Audio_isStereoInput'] = (block, generator) => {
    return [`Audio.isStereoInput`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_isSoloing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.isSoloing')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('<code>true</code> if currently audio soloing, i.e., playing audio from only specific     avatars. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.isSoloing');
    }
};
javascript.javascriptGenerator.forBlock['Audio_isSoloing'] = (block, generator) => {
    return [`Audio.isSoloing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Audio_soloList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.soloList')       
        this.setOutput(true, '');
        this.setColour('#B22F04');
        this.setTooltip('The list of currently soloed avatar IDs. Empty list if not currently audio soloing.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.soloList');
    }
};
javascript.javascriptGenerator.forBlock['Audio_soloList'] = (block, generator) => {
    return [`Audio.soloList`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Audio_setReverb'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setReverb')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Enables or disables reverberation. Reverberation is done by the client on the post-mix audio. The reverberation optionscome from either the domain\'s audio zone configured on the server or settings scripted by{@link Audio.setReverbOptions|setReverbOptions}.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setReverb');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setReverb'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Audio.setReverb(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Audio_setReverbOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setReverbOptions')
        // Returns data

        // Params data
        this.appendValueInput('options') 
            .setCheck('AudioEffectOptions')
            .appendField('options');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Configures reverberation options. Use {@link Audio.setReverb|setReverb} to enable or disable reverberation.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setReverbOptions');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setReverbOptions'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Audio.setReverbOptions(${_options});\n`;};


// Blockly function
Blockly.Blocks['Audio_setAvatarGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setAvatarGain')
        // Returns data

        // Params data
        this.appendValueInput('gain') 
            .setCheck('Number')
            .appendField('gain');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets the gain (relative volume) that avatars\' voices are played at. This gain is used at the server.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setAvatarGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setAvatarGain'] = (block, generator) => {
    const _gain = dfv(generator.valueToCode(block, 'gain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Audio.setAvatarGain(${_gain});\n`;};


// Blockly function
Blockly.Blocks['Audio_getAvatarGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getAvatarGain')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets the gain (relative volume) that avatars\' voices are played at. This gain is used at the server.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getAvatarGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getAvatarGain'] = (block, generator) => {

return [`Audio.getAvatarGain()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setInjectorGain')
        // Returns data

        // Params data
        this.appendValueInput('gain') 
            .setCheck('Number')
            .appendField('gain');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets the gain (relative volume) that environment sounds from the server are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setInjectorGain'] = (block, generator) => {
    const _gain = dfv(generator.valueToCode(block, 'gain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Audio.setInjectorGain(${_gain});\n`;};


// Blockly function
Blockly.Blocks['Audio_getInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getInjectorGain')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets the gain (relative volume) that environment sounds from the server are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getInjectorGain'] = (block, generator) => {

return [`Audio.getInjectorGain()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setLocalInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setLocalInjectorGain')
        // Returns data

        // Params data
        this.appendValueInput('gain') 
            .setCheck('Number')
            .appendField('gain');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets the gain (relative volume) that environment sounds from the client are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setLocalInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setLocalInjectorGain'] = (block, generator) => {
    const _gain = dfv(generator.valueToCode(block, 'gain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Audio.setLocalInjectorGain(${_gain});\n`;};


// Blockly function
Blockly.Blocks['Audio_getLocalInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getLocalInjectorGain')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets the gain (relative volume) that environment sounds from the client are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getLocalInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getLocalInjectorGain'] = (block, generator) => {

return [`Audio.getLocalInjectorGain()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setSystemInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setSystemInjectorGain')
        // Returns data

        // Params data
        this.appendValueInput('gain') 
            .setCheck('Number')
            .appendField('gain');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets the gain (relative volume) that system sounds are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setSystemInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setSystemInjectorGain'] = (block, generator) => {
    const _gain = dfv(generator.valueToCode(block, 'gain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Audio.setSystemInjectorGain(${_gain});\n`;};


// Blockly function
Blockly.Blocks['Audio_getSystemInjectorGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getSystemInjectorGain')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets the gain (relative volume) that system sounds are played at.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getSystemInjectorGain');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getSystemInjectorGain'] = (block, generator) => {

return [`Audio.getSystemInjectorGain()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setNoiseReductionThreshold'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setNoiseReductionThreshold')
        // Returns data

        // Params data
        this.appendValueInput('threshold') 
            .setCheck('Number')
            .appendField('threshold');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets the noise gate threshold before your mic audio is transmitted. (Applies only if <code>Audio.noiseReductionAutomatic</code> is <code>false</code>.)');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setNoiseReductionThreshold');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setNoiseReductionThreshold'] = (block, generator) => {
    const _threshold = dfv(generator.valueToCode(block, 'threshold', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Audio.setNoiseReductionThreshold(${_threshold});\n`;};


// Blockly function
Blockly.Blocks['Audio_getNoiseReductionThreshold'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getNoiseReductionThreshold')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets the noise reduction threshold.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getNoiseReductionThreshold');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getNoiseReductionThreshold'] = (block, generator) => {

return [`Audio.getNoiseReductionThreshold()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_startRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.startRecording')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Starts making an audio recording of the audio being played in-world (i.e., not local-only audio) to a file in WAV format.Audio is recorded to snapshots directory specified in settings.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.startRecording');
    }
};
javascript.javascriptGenerator.forBlock['Audio_startRecording'] = (block, generator) => {

return [`Audio.startRecording()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_stopRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.stopRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Finishes making an audio recording started with {@link Audio.startRecording|startRecording}.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.stopRecording');
    }
};
javascript.javascriptGenerator.forBlock['Audio_stopRecording'] = (block, generator) => {


    return `Audio.stopRecording();\n`;};


// Blockly function
Blockly.Blocks['Audio_getRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getRecording')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Checks whether an audio recording is currently being made.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getRecording');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getRecording'] = (block, generator) => {

return [`Audio.getRecording()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setPushingToTalkOutputGainDesktop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setPushingToTalkOutputGainDesktop')
        // Returns data

        // Params data
        this.appendValueInput('gain') 
            .setCheck('Number')
            .appendField('gain');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets the output volume gain that will be used when the user is holding the push-to-talk key.Should be negative.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setPushingToTalkOutputGainDesktop');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setPushingToTalkOutputGainDesktop'] = (block, generator) => {
    const _gain = dfv(generator.valueToCode(block, 'gain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Audio.setPushingToTalkOutputGainDesktop(${_gain});\n`;};


// Blockly function
Blockly.Blocks['Audio_getPushingToTalkOutputGainDesktop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getPushingToTalkOutputGainDesktop')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets the output volume gain that is used when the user is holding the push-to-talk key.Should be negative.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getPushingToTalkOutputGainDesktop');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getPushingToTalkOutputGainDesktop'] = (block, generator) => {

return [`Audio.getPushingToTalkOutputGainDesktop()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Audio_mutedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.mutedChanged');

        this.appendDummyInput('isMuted')
            .appendField('isMuted:')
            .appendField(new Blockly.FieldVariable('mutedChanged_isMuted'), 'isMuted');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the audio input is muted or unmuted for the current context (desktop or HMD).');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.mutedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_mutedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isMuted = generator.getVariableName(block.getFieldValue('isMuted'));

return `Audio.mutedChanged.connect((_isMuted) => { 
  ${isMuted} = _isMuted;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_mutedDesektopChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.mutedDesektopChanged');

        this.appendDummyInput('isMuted')
            .appendField('isMuted:')
            .appendField(new Blockly.FieldVariable('mutedDesektopChanged_isMuted'), 'isMuted');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when desktop audio input is muted or unmuted.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.mutedDesektopChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_mutedDesektopChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isMuted = generator.getVariableName(block.getFieldValue('isMuted'));

return `Audio.mutedDesektopChanged.connect((_isMuted) => { 
  ${isMuted} = _isMuted;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_mutedHMDChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.mutedHMDChanged');

        this.appendDummyInput('isMuted')
            .appendField('isMuted:')
            .appendField(new Blockly.FieldVariable('mutedHMDChanged_isMuted'), 'isMuted');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when HMD audio input is muted or unmuted.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.mutedHMDChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_mutedHMDChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isMuted = generator.getVariableName(block.getFieldValue('isMuted'));

return `Audio.mutedHMDChanged.connect((_isMuted) => { 
  ${isMuted} = _isMuted;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_pushToTalkChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.pushToTalkChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('pushToTalkChanged_enabled'), 'enabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when push-to-talk is enabled or disabled for the current context (desktop or HMD).');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushToTalkChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushToTalkChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `Audio.pushToTalkChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_pushToTalkDesktopChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.pushToTalkDesktopChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('pushToTalkDesktopChanged_enabled'), 'enabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when push-to-talk is enabled or disabled for desktop mode.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushToTalkDesktopChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushToTalkDesktopChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `Audio.pushToTalkDesktopChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_pushToTalkHMDChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.pushToTalkHMDChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('pushToTalkHMDChanged_enabled'), 'enabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when push-to-talk is enabled or disabled for HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushToTalkHMDChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushToTalkHMDChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `Audio.pushToTalkHMDChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_noiseReductionChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.noiseReductionChanged');

        this.appendDummyInput('isEnabled')
            .appendField('isEnabled:')
            .appendField(new Blockly.FieldVariable('noiseReductionChanged_isEnabled'), 'isEnabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when audio input noise reduction is enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseReductionChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseReductionChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isEnabled = generator.getVariableName(block.getFieldValue('isEnabled'));

return `Audio.noiseReductionChanged.connect((_isEnabled) => { 
  ${isEnabled} = _isEnabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_noiseReductionAutomaticChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.noiseReductionAutomaticChanged');

        this.appendDummyInput('isEnabled')
            .appendField('isEnabled:')
            .appendField(new Blockly.FieldVariable('noiseReductionAutomaticChanged_isEnabled'), 'isEnabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the audio input noise reduction mode is changed.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseReductionAutomaticChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseReductionAutomaticChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isEnabled = generator.getVariableName(block.getFieldValue('isEnabled'));

return `Audio.noiseReductionAutomaticChanged.connect((_isEnabled) => { 
  ${isEnabled} = _isEnabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_noiseReductionThresholdChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.noiseReductionThresholdChanged');

        this.appendDummyInput('threshold')
            .appendField('threshold:')
            .appendField(new Blockly.FieldVariable('noiseReductionThresholdChanged_threshold'), 'threshold');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the audio input noise reduction threshold is changed.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseReductionThresholdChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseReductionThresholdChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const threshold = generator.getVariableName(block.getFieldValue('threshold'));

return `Audio.noiseReductionThresholdChanged.connect((_threshold) => { 
  ${threshold} = _threshold;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_warnWhenMutedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.warnWhenMutedChanged');

        this.appendDummyInput('isEnabled')
            .appendField('isEnabled:')
            .appendField(new Blockly.FieldVariable('warnWhenMutedChanged_isEnabled'), 'isEnabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when "warn when muted" is enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.warnWhenMutedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_warnWhenMutedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isEnabled = generator.getVariableName(block.getFieldValue('isEnabled'));

return `Audio.warnWhenMutedChanged.connect((_isEnabled) => { 
  ${isEnabled} = _isEnabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_acousticEchoCancellationChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.acousticEchoCancellationChanged');

        this.appendDummyInput('isEnabled')
            .appendField('isEnabled:')
            .appendField(new Blockly.FieldVariable('acousticEchoCancellationChanged_isEnabled'), 'isEnabled');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when acoustic echo cancellation is enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.acousticEchoCancellationChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_acousticEchoCancellationChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isEnabled = generator.getVariableName(block.getFieldValue('isEnabled'));

return `Audio.acousticEchoCancellationChanged.connect((_isEnabled) => { 
  ${isEnabled} = _isEnabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_inputVolumeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.inputVolumeChanged');

        this.appendDummyInput('volume')
            .appendField('volume:')
            .appendField(new Blockly.FieldVariable('inputVolumeChanged_volume'), 'volume');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the input audio volume changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.inputVolumeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_inputVolumeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const volume = generator.getVariableName(block.getFieldValue('volume'));

return `Audio.inputVolumeChanged.connect((_volume) => { 
  ${volume} = _volume;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_inputLevelChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.inputLevelChanged');

        this.appendDummyInput('level')
            .appendField('level:')
            .appendField(new Blockly.FieldVariable('inputLevelChanged_level'), 'level');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the input audio level changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.inputLevelChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_inputLevelChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const level = generator.getVariableName(block.getFieldValue('level'));

return `Audio.inputLevelChanged.connect((_level) => { 
  ${level} = _level;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_clippingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.clippingChanged');

        this.appendDummyInput('isClipping')
            .appendField('isClipping:')
            .appendField(new Blockly.FieldVariable('clippingChanged_isClipping'), 'isClipping');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the clipping state of the input audio changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.clippingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_clippingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isClipping = generator.getVariableName(block.getFieldValue('isClipping'));

return `Audio.clippingChanged.connect((_isClipping) => { 
  ${isClipping} = _isClipping;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_contextChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.contextChanged');

        this.appendDummyInput('context')
            .appendField('context:')
            .appendField(new Blockly.FieldVariable('contextChanged_context'), 'context');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the current context of the audio changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.contextChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_contextChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const context = generator.getVariableName(block.getFieldValue('context'));

return `Audio.contextChanged.connect((_context) => { 
  ${context} = _context;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_pushingToTalkChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.pushingToTalkChanged');

        this.appendDummyInput('talking')
            .appendField('talking:')
            .appendField(new Blockly.FieldVariable('pushingToTalkChanged_talking'), 'talking');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the user starts or stops push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushingToTalkChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushingToTalkChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const talking = generator.getVariableName(block.getFieldValue('talking'));

return `Audio.pushingToTalkChanged.connect((_talking) => { 
  ${talking} = _talking;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_avatarGainChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.avatarGainChanged');

        this.appendDummyInput('gain')
            .appendField('gain:')
            .appendField(new Blockly.FieldVariable('avatarGainChanged_gain'), 'gain');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the avatar gain changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.avatarGainChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_avatarGainChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const gain = generator.getVariableName(block.getFieldValue('gain'));

return `Audio.avatarGainChanged.connect((_gain) => { 
  ${gain} = _gain;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_localInjectorGainChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.localInjectorGainChanged');

        this.appendDummyInput('gain')
            .appendField('gain:')
            .appendField(new Blockly.FieldVariable('localInjectorGainChanged_gain'), 'gain');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the local injector gain changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.localInjectorGainChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_localInjectorGainChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const gain = generator.getVariableName(block.getFieldValue('gain'));

return `Audio.localInjectorGainChanged.connect((_gain) => { 
  ${gain} = _gain;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_serverInjectorGainChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.serverInjectorGainChanged');

        this.appendDummyInput('gain')
            .appendField('gain:')
            .appendField(new Blockly.FieldVariable('serverInjectorGainChanged_gain'), 'gain');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the server injector gain changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.serverInjectorGainChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_serverInjectorGainChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const gain = generator.getVariableName(block.getFieldValue('gain'));

return `Audio.serverInjectorGainChanged.connect((_gain) => { 
  ${gain} = _gain;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_systemInjectorGainChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.systemInjectorGainChanged');

        this.appendDummyInput('gain')
            .appendField('gain:')
            .appendField(new Blockly.FieldVariable('systemInjectorGainChanged_gain'), 'gain');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the system injector gain changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.systemInjectorGainChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_systemInjectorGainChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const gain = generator.getVariableName(block.getFieldValue('gain'));

return `Audio.systemInjectorGainChanged.connect((_gain) => { 
  ${gain} = _gain;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_pushingToTalkOutputGainDesktopChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.pushingToTalkOutputGainDesktopChanged');

        this.appendDummyInput('gain')
            .appendField('gain:')
            .appendField(new Blockly.FieldVariable('pushingToTalkOutputGainDesktopChanged_gain'), 'gain');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the push to talk gain changes.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.pushingToTalkOutputGainDesktopChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_pushingToTalkOutputGainDesktopChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const gain = generator.getVariableName(block.getFieldValue('gain'));

return `Audio.pushingToTalkOutputGainDesktopChanged.connect((_gain) => { 
  ${gain} = _gain;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['Clipboard_getContentsDimensions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Clipboard.getContentsDimensions')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#23E5A7');
        this.setTooltip('Gets the extents of the entities held in the clipboard.');
        this.setHelpUrl('https://apidocs.overte.org/Clipboard.html#.getContentsDimensions');
    }
};
javascript.javascriptGenerator.forBlock['Clipboard_getContentsDimensions'] = (block, generator) => {

return [`Clipboard.getContentsDimensions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Clipboard_getClipboardContentsLargestDimension'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Clipboard.getClipboardContentsLargestDimension')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#23E5A7');
        this.setTooltip('Gets the largest dimension of the extents of the entities held in the clipboard.');
        this.setHelpUrl('https://apidocs.overte.org/Clipboard.html#.getClipboardContentsLargestDimension');
    }
};
javascript.javascriptGenerator.forBlock['Clipboard_getClipboardContentsLargestDimension'] = (block, generator) => {

return [`Clipboard.getClipboardContentsLargestDimension()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Clipboard_importEntities'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Clipboard.importEntities')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');
        this.appendValueInput('isObservable') 
            .setCheck('Boolean')
            .appendField('isObservable');
        this.appendValueInput('callerID') 
            .setCheck('Number')
            .appendField('callerID');

        this.setColour('#23E5A7');
        this.setTooltip('Imports entities from a JSON file into the clipboard.');
        this.setHelpUrl('https://apidocs.overte.org/Clipboard.html#.importEntities');
    }
};
javascript.javascriptGenerator.forBlock['Clipboard_importEntities'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isObservable = dfv(generator.valueToCode(block, 'isObservable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _callerID = dfv(generator.valueToCode(block, 'callerID', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`Clipboard.importEntities(${_filename},${_isObservable},${_callerID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Clipboard_exportEntities'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Clipboard.exportEntities')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');
        this.appendValueInput('entityIDs') 
            .setCheck('Array')
            .appendField('entityIDs');

        this.setColour('#23E5A7');
        this.setTooltip('Exports specified entities to a JSON file.');
        this.setHelpUrl('https://apidocs.overte.org/Clipboard.html#.exportEntities');
    }
};
javascript.javascriptGenerator.forBlock['Clipboard_exportEntities'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entityIDs = dfv(generator.valueToCode(block, 'entityIDs', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Clipboard.exportEntities(${_filename},${_entityIDs})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Clipboard_exportEntitiesfilenamexyzscale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Clipboard.exportEntities')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('z') 
            .setCheck('Number')
            .appendField('z');
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');

        this.setColour('#23E5A7');
        this.setTooltip('Exports all entities that have centers within a cube to a JSON file.');
        this.setHelpUrl('https://apidocs.overte.org/Clipboard.html#.exportEntities');
    }
};
javascript.javascriptGenerator.forBlock['Clipboard_exportEntitiesfilenamexyzscale'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _z = dfv(generator.valueToCode(block, 'z', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Clipboard.exportEntities(${_filename},${_x},${_y},${_z},${_scale})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Clipboard_pasteEntities'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Clipboard.pasteEntities')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('entityHostType') 
            .setCheck('Entities.EntityHostType')
            .appendField('entityHostType');

        this.setColour('#23E5A7');
        this.setTooltip('Pastes the contents of the clipboard into the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Clipboard.html#.pasteEntities');
    }
};
javascript.javascriptGenerator.forBlock['Clipboard_pasteEntities'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entityHostType = dfv(generator.valueToCode(block, 'entityHostType', javascript.javascriptGenerator.ORDER_ATOMIC), `"domain"`);

return [`Clipboard.pasteEntities(${_position},${_entityHostType})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['Controller_Actions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Actions')       
        this.setOutput(true, '');
        this.setColour('#9BBF37');
        this.setTooltip('Predefined actions on Interface and the user\'s avatar. These can be used as end    points in a {@link RouteObject} mapping. A synonym for <code>Controller.Hardware.Actions</code>.    Getting this property is computationally expensive, so it\'s best to cache it once on script start.    <em>Read-only.</em>    <p>Default mappings are provided from the <code>Controller.Hardware.Keyboard</code> and <code>Controller.Standard</code>     to actions in     <a href="https://github.com/highfidelity/hifi/blob/master/interface/resources/controllers/keyboardMouse.json">    keyboardMouse.json</a> and     <a href="https://github.com/highfidelity/hifi/blob/master/interface/resources/controllers/standard.json">    standard.json</a>, respectively.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Actions');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Actions'] = (block, generator) => {
    return [`Controller.Actions`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Controller_Hardware'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hardware')       
        this.setOutput(true, '');
        this.setColour('#9BBF37');
        this.setTooltip('Standard and hardware-specific controller and computer outputs, plus predefined     actions on Interface and the user\'s avatar. Getting this property is computationally expensive, so it\'s best to cache it    instead of calling on every update.    The outputs can be mapped to <code>Actions</code> or functions in a    {@link RouteObject} mapping. Additionally, hardware-specific controller outputs can be mapped to     <code>Controller.Standard</code> controller outputs. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hardware');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hardware'] = (block, generator) => {
    return [`Controller.Hardware`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Controller_Standard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Standard')       
        this.setOutput(true, '');
        this.setColour('#9BBF37');
        this.setTooltip('Standard controller outputs that can be mapped to <code>Actions</code> or     functions in a {@link RouteObject} mapping. <em>Read-only.</em>    <p>Each hardware device has a mapping from its outputs to <code>Controller.Standard</code> items, specified in a JSON file.    Getting this property is computationally expensive, so it\'s best to cache it once on script start.    For example, <a href="https://github.com/highfidelity/hifi/blob/master/interface/resources/controllers/leapmotion.json">    leapmotion.json</a> and     <a href="https://github.com/highfidelity/hifi/blob/master/interface/resources/controllers/vive.json">vive.json</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Standard');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Standard'] = (block, generator) => {
    return [`Controller.Standard`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Controller_captureKeyEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.captureKeyEvents')
        // Returns data

        // Params data
        this.appendValueInput('event') 
            .setCheck('KeyEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables default Interface actions for a particular key event.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.captureKeyEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_captureKeyEvents'] = (block, generator) => {
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Controller.captureKeyEvents(${_event});\n`;};


// Blockly function
Blockly.Blocks['Controller_releaseKeyEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.releaseKeyEvents')
        // Returns data

        // Params data
        this.appendValueInput('event') 
            .setCheck('KeyEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Re-enables default Interface actions for a particular key event that has been disabled using {@link Controller.captureKeyEvents|captureKeyEvents}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.releaseKeyEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_releaseKeyEvents'] = (block, generator) => {
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Controller.releaseKeyEvents(${_event});\n`;};


// Blockly function
Blockly.Blocks['Controller_captureEntityClickEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.captureEntityClickEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables {@link Entities.mousePressOnEntity} and {@link Entities.mouseDoublePressOnEntity} events on entities.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.captureEntityClickEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_captureEntityClickEvents'] = (block, generator) => {


    return `Controller.captureEntityClickEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_releaseEntityClickEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.releaseEntityClickEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Re-enables {@link Entities.mousePressOnEntity} and {@link Entities.mouseDoublePressOnEntity} events on entities that were disabled using {@link Controller.captureEntityClickEvents|captureEntityClickEvents}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.releaseEntityClickEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_releaseEntityClickEvents'] = (block, generator) => {


    return `Controller.releaseEntityClickEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_getViewportDimensions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getViewportDimensions')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the dimensions of the Interface window\'s interior if in desktop mode or the HUD surface if in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getViewportDimensions');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getViewportDimensions'] = (block, generator) => {

return [`Controller.getViewportDimensions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getRecommendedHUDRect'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getRecommendedHUDRect')
        // Returns data
        this.setOutput(true, '["Rect"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the recommended area to position UI on the HUD surface if in HMD mode or Interface\'s window interior if in desktop mode.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getRecommendedHUDRect');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getRecommendedHUDRect'] = (block, generator) => {

return [`Controller.getRecommendedHUDRect()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_setVPadEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.setVPadEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Enables or disables the virtual game pad that is displayed on certain devices (e.g., Android).');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.setVPadEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Controller_setVPadEnabled'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Controller.setVPadEnabled(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Controller_setVPadHidden'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.setVPadHidden')
        // Returns data

        // Params data
        this.appendValueInput('hidden') 
            .setCheck('Boolean')
            .appendField('hidden');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Shows or hides the virtual game pad that is displayed on certain devices (e.g., Android).');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.setVPadHidden');
    }
};
javascript.javascriptGenerator.forBlock['Controller_setVPadHidden'] = (block, generator) => {
    const _hidden = dfv(generator.valueToCode(block, 'hidden', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Controller.setVPadHidden(${_hidden});\n`;};


// Blockly function
Blockly.Blocks['Controller_setVPadExtraBottomMargin'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.setVPadExtraBottomMargin')
        // Returns data

        // Params data
        this.appendValueInput('margin') 
            .setCheck('Number')
            .appendField('margin');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Sets the amount of extra margin between the virtual game pad that is displayed on certain devices (e.g., Android) and the bottom of the display.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.setVPadExtraBottomMargin');
    }
};
javascript.javascriptGenerator.forBlock['Controller_setVPadExtraBottomMargin'] = (block, generator) => {
    const _margin = dfv(generator.valueToCode(block, 'margin', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Controller.setVPadExtraBottomMargin(${_margin});\n`;};


// Blockly signal
Blockly.Blocks['Controller_keyPressEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.keyPressEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('keyPressEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a keyboard key is pressed.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.keyPressEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_keyPressEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.keyPressEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_keyReleaseEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.keyReleaseEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('keyReleaseEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a keyboard key is released from being pressed.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.keyReleaseEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_keyReleaseEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.keyReleaseEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_mouseMoveEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.mouseMoveEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseMoveEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when the mouse moves.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.mouseMoveEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_mouseMoveEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.mouseMoveEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_mousePressEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.mousePressEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mousePressEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a mouse button is pressed.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.mousePressEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_mousePressEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.mousePressEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_mouseDoublePressEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.mouseDoublePressEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseDoublePressEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a mouse button is double-pressed.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.mouseDoublePressEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_mouseDoublePressEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.mouseDoublePressEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_mouseReleaseEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.mouseReleaseEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseReleaseEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a mouse button is released from being pressed.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.mouseReleaseEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_mouseReleaseEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.mouseReleaseEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_touchBeginEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.touchBeginEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('touchBeginEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a touch event starts in the Interface window on a touch-enabled display or device.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.touchBeginEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_touchBeginEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.touchBeginEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_touchEndEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.touchEndEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('touchEndEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a touch event ends in the Interface window on a touch-enabled display or device.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.touchEndEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_touchEndEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.touchEndEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_touchUpdateEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.touchUpdateEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('touchUpdateEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a touch event update occurs in the Interface window on a touch-enabled display or device.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.touchUpdateEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_touchUpdateEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.touchUpdateEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_wheelEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.wheelEvent');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('wheelEvent_event'), 'event');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when the mouse wheel is rotated.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.wheelEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_wheelEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Controller.wheelEvent.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['InteractiveWindow_DockAreas'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.DockAreas')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('TOP') 
            .setCheck('InteractiveWindow.DockArea')
            .appendField('TOP');
        this.appendValueInput('BOTTOM') 
            .setCheck('InteractiveWindow.DockArea')
            .appendField('BOTTOM');
        this.appendValueInput('LEFT') 
            .setCheck('InteractiveWindow.DockArea')
            .appendField('LEFT');
        this.appendValueInput('RIGHT') 
            .setCheck('InteractiveWindow.DockArea')
            .appendField('RIGHT');
        this.setColour('#E873CA');
        this.setTooltip('The possible docking locations of an <code>InteractiveWindow</code>.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.DockAreas');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_DockAreas'] = (block, generator) => {
    const _TOP = dfv(generator.valueToCode(block, 'TOP', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _BOTTOM = dfv(generator.valueToCode(block, 'BOTTOM', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _LEFT = dfv(generator.valueToCode(block, 'LEFT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _RIGHT = dfv(generator.valueToCode(block, 'RIGHT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new InteractiveWindow.DockAreas(${_TOP},${_BOTTOM},${_LEFT},${_RIGHT})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_RelativePositionAnchors'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.RelativePositionAnchors')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('NOANCHOR') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('NOANCHOR');
        this.appendValueInput('TOPLEFT') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('TOPLEFT');
        this.appendValueInput('TOPRIGHT') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('TOPRIGHT');
        this.appendValueInput('BOTTOMRIGHT') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('BOTTOMRIGHT');
        this.appendValueInput('BOTTOMLEFT') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('BOTTOMLEFT');
        this.setColour('#E873CA');
        this.setTooltip('The possible relative position anchors of an <code>InteractiveWindow</code> relative to the Interface window.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.RelativePositionAnchors');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_RelativePositionAnchors'] = (block, generator) => {
    const _NOANCHOR = dfv(generator.valueToCode(block, 'NOANCHOR', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _TOPLEFT = dfv(generator.valueToCode(block, 'TOPLEFT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _TOPRIGHT = dfv(generator.valueToCode(block, 'TOPRIGHT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _BOTTOMRIGHT = dfv(generator.valueToCode(block, 'BOTTOMRIGHT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _BOTTOMLEFT = dfv(generator.valueToCode(block, 'BOTTOMLEFT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new InteractiveWindow.RelativePositionAnchors(${_NOANCHOR},${_TOPLEFT},${_TOPRIGHT},${_BOTTOMRIGHT},${_BOTTOMLEFT})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_PresentationModes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.PresentationModes')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('VIRTUAL') 
            .setCheck('InteractiveWindow.PresentationMode')
            .appendField('VIRTUAL');
        this.appendValueInput('NATIVE') 
            .setCheck('InteractiveWindow.PresentationMode')
            .appendField('NATIVE');
        this.setColour('#E873CA');
        this.setTooltip('The possible display modes for an <code>InteractiveWindow</code>.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.PresentationModes');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_PresentationModes'] = (block, generator) => {
    const _VIRTUAL = dfv(generator.valueToCode(block, 'VIRTUAL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _NATIVE = dfv(generator.valueToCode(block, 'NATIVE', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new InteractiveWindow.PresentationModes(${_VIRTUAL},${_NATIVE})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Desktop_width'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.width')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('The width of the computer screen including task bar and system menu, in pixels.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.width');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_width'] = (block, generator) => {
    return [`Desktop.width`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Desktop_height'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.height')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('The height of the computer screen including task bar and system menu, in pixels.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.height');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_height'] = (block, generator) => {
    return [`Desktop.height`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Desktop_ALWAYS_ON_TOP'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.ALWAYS_ON_TOP')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('A flag value that makes an {@link InteractiveWindow} always display on     top. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.ALWAYS_ON_TOP');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_ALWAYS_ON_TOP'] = (block, generator) => {
    return [`Desktop.ALWAYS_ON_TOP`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Desktop_CLOSE_BUTTON_HIDES'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.CLOSE_BUTTON_HIDES')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('A flag value that makes an {@link InteractiveWindow} hide instead     of closing when the user clicks the "close" button.<em> Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.CLOSE_BUTTON_HIDES');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_CLOSE_BUTTON_HIDES'] = (block, generator) => {
    return [`Desktop.CLOSE_BUTTON_HIDES`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Desktop_PresentationMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.PresentationMode')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('The possible display options for an     {@link InteractiveWindow}: display inside Interface or in a separate desktop window. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.PresentationMode');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_PresentationMode'] = (block, generator) => {
    return [`Desktop.PresentationMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Desktop_DockArea'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.DockArea')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('The possible docking locations of an {@link InteractiveWindow}: top,     bottom, left, or right of the Interface window.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.DockArea');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_DockArea'] = (block, generator) => {
    return [`Desktop.DockArea`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Desktop_RelativePositionAnchor'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.RelativePositionAnchor')       
        this.setOutput(true, '');
        this.setColour('#231040');
        this.setTooltip('The possible relative position anchors for an     {@link InteractiveWindow}: none, top left, top right, bottom right, or bottom left of the Interface window.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.RelativePositionAnchor');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_RelativePositionAnchor'] = (block, generator) => {
    return [`Desktop.RelativePositionAnchor`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Desktop_setHUDAlpha'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.setHUDAlpha')
        // Returns data

        // Params data
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#231040');
        this.setTooltip('Sets the opacity of the HUD surface.');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.setHUDAlpha');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_setHUDAlpha'] = (block, generator) => {
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Desktop.setHUDAlpha(${_alpha});\n`;};


// Blockly function
Blockly.Blocks['Desktop_show'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.show')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#231040');
        this.setTooltip('Opens a QML window within Interface: in the Interface window in desktop mode or on the HUD surface in HMD mode. If a window of the specified name already exists, it is shown, otherwise a new window is created from the QML.');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.show');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_show'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Desktop.show(${_url},${_name});\n`;};


// Blockly function
Blockly.Blocks['Desktop_createWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.createWindow')
        // Returns data
        this.setOutput(true, '["InteractiveWindow"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('properties') 
            .setCheck('InteractiveWindow.WindowProperties')
            .appendField('properties');

        this.setColour('#231040');
        this.setTooltip('Creates a new window that can be displayed either within Interface or as a separate desktop window.');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.createWindow');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_createWindow'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Desktop.createWindow(${_url},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Desktop_isOverlayWindowFocused'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Desktop.isOverlayWindowFocused')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#231040');
        this.setTooltip('Checks whether the keyboard focus belongs to overlay UI window.');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.isOverlayWindowFocused');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_isOverlayWindowFocused'] = (block, generator) => {

return [`Desktop.isOverlayWindowFocused()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Desktop_uiFocusChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Desktop.uiFocusChanged');

        this.appendDummyInput('isActive')
            .appendField('isActive:')
            .appendField(new Blockly.FieldVariable('uiFocusChanged_isActive'), 'isActive');

        this.setColour('#231040');
        this.setTooltip('Triggered when keyboard focus changes to another overlay UI window.');
        this.setHelpUrl('https://apidocs.overte.org/Desktop.html#.uiFocusChanged');
    }
};
javascript.javascriptGenerator.forBlock['Desktop_uiFocusChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isActive = generator.getVariableName(block.getFieldValue('isActive'));

return `Desktop.uiFocusChanged.connect((_isActive) => { 
  ${isActive} = _isActive;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['DialogsManager_showFeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DialogsManager.showFeed')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#872D9E');
        this.setTooltip('<em>Currently performs no action.</em>');
        this.setHelpUrl('https://apidocs.overte.org/DialogsManager.html#.showFeed');
    }
};
javascript.javascriptGenerator.forBlock['DialogsManager_showFeed'] = (block, generator) => {


    return `DialogsManager.showFeed();\n`;};


// Blockly function
Blockly.Blocks['DialogsManager_showAddressBar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DialogsManager.showAddressBar')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#872D9E');
        this.setTooltip('Shows the "Goto" dialog.');
        this.setHelpUrl('https://apidocs.overte.org/DialogsManager.html#.showAddressBar');
    }
};
javascript.javascriptGenerator.forBlock['DialogsManager_showAddressBar'] = (block, generator) => {


    return `DialogsManager.showAddressBar();\n`;};


// Blockly function
Blockly.Blocks['DialogsManager_hideAddressBar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DialogsManager.hideAddressBar')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#872D9E');
        this.setTooltip('Hides the "Goto" dialog.');
        this.setHelpUrl('https://apidocs.overte.org/DialogsManager.html#.hideAddressBar');
    }
};
javascript.javascriptGenerator.forBlock['DialogsManager_hideAddressBar'] = (block, generator) => {


    return `DialogsManager.hideAddressBar();\n`;};


// Blockly function
Blockly.Blocks['DialogsManager_showLoginDialog'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DialogsManager.showLoginDialog')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#872D9E');
        this.setTooltip('Shows the login dialog.');
        this.setHelpUrl('https://apidocs.overte.org/DialogsManager.html#.showLoginDialog');
    }
};
javascript.javascriptGenerator.forBlock['DialogsManager_showLoginDialog'] = (block, generator) => {


    return `DialogsManager.showLoginDialog();\n`;};


// Blockly signal
Blockly.Blocks['DialogsManager_addressBarShown'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('DialogsManager.addressBarShown');

        this.appendDummyInput('visible')
            .appendField('visible:')
            .appendField(new Blockly.FieldVariable('addressBarShown_visible'), 'visible');

        this.setColour('#872D9E');
        this.setTooltip('Triggered when the "Goto" dialog is opened or closed.<p><strong>Warning:</strong> Currently isn\'t always triggered.</p>');
        this.setHelpUrl('https://apidocs.overte.org/DialogsManager.html#.addressBarShown');
    }
};
javascript.javascriptGenerator.forBlock['DialogsManager_addressBarShown'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const visible = generator.getVariableName(block.getFieldValue('visible'));

return `DialogsManager.addressBarShown.connect((_visible) => { 
  ${visible} = _visible;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['GooglePoly_setAPIKey'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.setAPIKey')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.setAPIKey');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_setAPIKey'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `GooglePoly.setAPIKey(${_key});\n`;};


// Blockly function
Blockly.Blocks['GooglePoly_getAssetList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getAssetList')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');
        this.appendValueInput('format') 
            .setCheck('String')
            .appendField('format');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getAssetList');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getAssetList'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _format = dfv(generator.valueToCode(block, 'format', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getAssetList(${_keyword},${_category},${_format})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getFBX'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getFBX')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getFBX');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getFBX'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getFBX(${_keyword},${_category})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getOBJ'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getOBJ')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getOBJ');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getOBJ'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getOBJ(${_keyword},${_category})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getBlocks'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getBlocks')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getBlocks');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getBlocks'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getBlocks(${_keyword},${_category})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getGLTF'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getGLTF')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getGLTF');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getGLTF'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getGLTF(${_keyword},${_category})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getGLTF2'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getGLTF2')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getGLTF2');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getGLTF2'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getGLTF2(${_keyword},${_category})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getTilt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getTilt')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('keyword') 
            .setCheck('String')
            .appendField('keyword');
        this.appendValueInput('category') 
            .setCheck('String')
            .appendField('category');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getTilt');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getTilt'] = (block, generator) => {
    const _keyword = dfv(generator.valueToCode(block, 'keyword', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _category = dfv(generator.valueToCode(block, 'category', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getTilt(${_keyword},${_category})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GooglePoly_getModelInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GooglePoly.getModelInfo')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('input') 
            .setCheck('String')
            .appendField('input');

        this.setColour('#87AB40');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/GooglePoly.html#.getModelInfo');
    }
};
javascript.javascriptGenerator.forBlock['GooglePoly_getModelInfo'] = (block, generator) => {
    const _input = dfv(generator.valueToCode(block, 'input', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GooglePoly.getModelInfo(${_input})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['HMD_position'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.position')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The position of the HMD if currently in VR display mode, otherwise    {@link Vec3|Vec3.ZERO}. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.position');
    }
};
javascript.javascriptGenerator.forBlock['HMD_position'] = (block, generator) => {
    return [`HMD.position`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_orientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.orientation')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The orientation of the HMD if currently in VR display mode, otherwise     {@link Quat|Quat.IDENTITY}. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.orientation');
    }
};
javascript.javascriptGenerator.forBlock['HMD_orientation'] = (block, generator) => {
    return [`HMD.orientation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_active'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.active')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<code>true</code> if the display mode is HMD, otherwise <code>false</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.active');
    }
};
javascript.javascriptGenerator.forBlock['HMD_active'] = (block, generator) => {
    return [`HMD.active`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_mounted'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.mounted')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<code>true</code> if currently in VR display mode and the HMD is being worn, otherwise    <code>false</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.mounted');
    }
};
javascript.javascriptGenerator.forBlock['HMD_mounted'] = (block, generator) => {
    return [`HMD.mounted`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_playerHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.playerHeight')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The real-world height of the user. <em>Read-only.</em> <em>Currently always returns a    value of <code>1.755</code>.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.playerHeight');
    }
};
javascript.javascriptGenerator.forBlock['HMD_playerHeight'] = (block, generator) => {
    return [`HMD.playerHeight`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_eyeHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.eyeHeight')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The real-world height of the user\'s eyes. <em>Read-only.</em> <em>Currently always returns a    value of <code>1.655</code>.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.eyeHeight');
    }
};
javascript.javascriptGenerator.forBlock['HMD_eyeHeight'] = (block, generator) => {
    return [`HMD.eyeHeight`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_ipd'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.ipd')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The inter-pupillary distance (distance between eyes) of the user, used for rendering. Defaults to    the human average of <code>0.064</code> unless set by the HMD. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.ipd');
    }
};
javascript.javascriptGenerator.forBlock['HMD_ipd'] = (block, generator) => {
    return [`HMD.ipd`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_ipdScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.ipdScale')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('A scale factor applied to the <code>ipd</code> property value.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.ipdScale');
    }
};
javascript.javascriptGenerator.forBlock['HMD_ipdScale'] = (block, generator) => {
    return [`HMD.ipdScale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_showTablet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.showTablet')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<code>true</code> if the tablet is being displayed, <code>false</code> otherwise.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.showTablet');
    }
};
javascript.javascriptGenerator.forBlock['HMD_showTablet'] = (block, generator) => {
    return [`HMD.showTablet`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_tabletContextualMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.tabletContextualMode')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<code>true</code> if the tablet has been opened in contextual mode, otherwise     <code>false</code>. In contextual mode, the tablet has been opened at a specific world position and orientation rather     than at a position and orientation relative to the user. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.tabletContextualMode');
    }
};
javascript.javascriptGenerator.forBlock['HMD_tabletContextualMode'] = (block, generator) => {
    return [`HMD.tabletContextualMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_tabletID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.tabletID')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The UUID of the tablet body model entity.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.tabletID');
    }
};
javascript.javascriptGenerator.forBlock['HMD_tabletID'] = (block, generator) => {
    return [`HMD.tabletID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_tabletScreenID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.tabletScreenID')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The UUID of the tablet\'s screen entity.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.tabletScreenID');
    }
};
javascript.javascriptGenerator.forBlock['HMD_tabletScreenID'] = (block, generator) => {
    return [`HMD.tabletScreenID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_homeButtonID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.homeButtonID')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The UUID of the tablet\'s "home" button entity.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.homeButtonID');
    }
};
javascript.javascriptGenerator.forBlock['HMD_homeButtonID'] = (block, generator) => {
    return [`HMD.homeButtonID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_homeButtonHighlightID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.homeButtonHighlightID')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The UUID of the tablet\'s "home" button highlight entity.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.homeButtonHighlightID');
    }
};
javascript.javascriptGenerator.forBlock['HMD_homeButtonHighlightID'] = (block, generator) => {
    return [`HMD.homeButtonHighlightID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_miniTabletID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.miniTabletID')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The UUID of the mini tablet\'s body model entity. <code>null</code> if not in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.miniTabletID');
    }
};
javascript.javascriptGenerator.forBlock['HMD_miniTabletID'] = (block, generator) => {
    return [`HMD.miniTabletID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_miniTabletScreenID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.miniTabletScreenID')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The UUID of the mini tablet\'s screen entity. <code>null</code> if not in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.miniTabletScreenID');
    }
};
javascript.javascriptGenerator.forBlock['HMD_miniTabletScreenID'] = (block, generator) => {
    return [`HMD.miniTabletScreenID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_miniTabletHand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.miniTabletHand')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The hand that the mini tablet is displayed on: <code>0</code> for left hand,     <code>1</code> for right hand, <code>-1</code> if not in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.miniTabletHand');
    }
};
javascript.javascriptGenerator.forBlock['HMD_miniTabletHand'] = (block, generator) => {
    return [`HMD.miniTabletHand`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_miniTabletEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.miniTabletEnabled')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<code>true</code> if the mini tablet is enabled to be displayed, otherwise     <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.miniTabletEnabled');
    }
};
javascript.javascriptGenerator.forBlock['HMD_miniTabletEnabled'] = (block, generator) => {
    return [`HMD.miniTabletEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_playArea'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.playArea')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The size and position of the HMD play area in sensor coordinates. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.playArea');
    }
};
javascript.javascriptGenerator.forBlock['HMD_playArea'] = (block, generator) => {
    return [`HMD.playArea`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_sensorPositions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.sensorPositions')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The positions of the VR system sensors in sensor coordinates. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.sensorPositions');
    }
};
javascript.javascriptGenerator.forBlock['HMD_sensorPositions'] = (block, generator) => {
    return [`HMD.sensorPositions`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeRatioX'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeRatioX')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The amount of vision squeeze for the x-axis when moving, range <code>0.0</code>     &ndash; <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeRatioX');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeRatioX'] = (block, generator) => {
    return [`HMD.visionSqueezeRatioX`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeRatioY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeRatioY')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The amount of vision squeeze for the y-axis when moving, range <code>0.0</code>     &ndash; <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeRatioY');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeRatioY'] = (block, generator) => {
    return [`HMD.visionSqueezeRatioY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeTurningXFactor'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeTurningXFactor')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The additional amount of vision squeeze for the x-axis when turning,    range <code>0.0</code> &ndash; <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeTurningXFactor');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeTurningXFactor'] = (block, generator) => {
    return [`HMD.visionSqueezeTurningXFactor`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeTurningYFactor'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeTurningYFactor')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<em>Currently unused.</em>');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeTurningYFactor');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeTurningYFactor'] = (block, generator) => {
    return [`HMD.visionSqueezeTurningYFactor`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeUnSqueezeDelay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeUnSqueezeDelay')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The delay in undoing the vision squeeze effect after motion stops, in    seconds.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeUnSqueezeDelay');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeUnSqueezeDelay'] = (block, generator) => {
    return [`HMD.visionSqueezeUnSqueezeDelay`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeUnSqueezeSpeed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeUnSqueezeSpeed')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('How quickly the vision squeeze effect fades, once     <code>visionSqueezeUnSqueezeDelay</code> has passed.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeUnSqueezeSpeed');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeUnSqueezeSpeed'] = (block, generator) => {
    return [`HMD.visionSqueezeUnSqueezeSpeed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeTransition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeTransition')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('How tightly vision is squeezed, range <code>0.01</code> &ndash;     <code>0.7</code>.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeTransition');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeTransition'] = (block, generator) => {
    return [`HMD.visionSqueezeTransition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezePerEye'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezePerEye')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('<code>1</code> if each eye gets a tube to see through, <code>0</code> if the face     gets a tube.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezePerEye');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezePerEye'] = (block, generator) => {
    return [`HMD.visionSqueezePerEye`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeGroundPlaneY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeGroundPlaneY')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('Adjusts how far below the camera the vision squeeze grid is displayed at.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeGroundPlaneY');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeGroundPlaneY'] = (block, generator) => {
    return [`HMD.visionSqueezeGroundPlaneY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['HMD_visionSqueezeSpotlightSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.visionSqueezeSpotlightSize')       
        this.setOutput(true, '');
        this.setColour('#23491C');
        this.setTooltip('The diameter of the circle of vision squeeze grid that is illuminated     around the camera.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.visionSqueezeSpotlightSize');
    }
};
javascript.javascriptGenerator.forBlock['HMD_visionSqueezeSpotlightSize'] = (block, generator) => {
    return [`HMD.visionSqueezeSpotlightSize`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['HMD_calculateRayUICollisionPoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.calculateRayUICollisionPoint')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');

        this.setColour('#23491C');
        this.setTooltip('Calculates the intersection of a ray with the HUD overlay.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.calculateRayUICollisionPoint');
    }
};
javascript.javascriptGenerator.forBlock['HMD_calculateRayUICollisionPoint'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`HMD.calculateRayUICollisionPoint(${_position},${_direction})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_overlayFromWorldPoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.overlayFromWorldPoint')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');

        this.setColour('#23491C');
        this.setTooltip('Gets the 2D HUD overlay coordinates of a 3D point on the HUD overlay.2D HUD overlay coordinates are pixels with the origin at the top left of the overlay.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.overlayFromWorldPoint');
    }
};
javascript.javascriptGenerator.forBlock['HMD_overlayFromWorldPoint'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`HMD.overlayFromWorldPoint(${_position})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_worldPointFromOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.worldPointFromOverlay')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('coordinates') 
            .setCheck('Vec2')
            .appendField('coordinates');

        this.setColour('#23491C');
        this.setTooltip('Gets the 3D world coordinates of a 2D point on the HUD overlay.2D HUD overlay coordinates are pixels with the origin at the top left of the overlay.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.worldPointFromOverlay');
    }
};
javascript.javascriptGenerator.forBlock['HMD_worldPointFromOverlay'] = (block, generator) => {
    const _coordinates = dfv(generator.valueToCode(block, 'coordinates', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`HMD.worldPointFromOverlay(${_coordinates})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_sphericalToOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.sphericalToOverlay')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data
        this.appendValueInput('sphericalPos') 
            .setCheck('Vec2')
            .appendField('sphericalPos');

        this.setColour('#23491C');
        this.setTooltip('Gets the 2D point on the HUD overlay represented by given spherical coordinates. 2D HUD overlay coordinates are pixels with the origin at the top left of the overlay.Spherical coordinates are polar coordinates in radians with <code>{ x: 0, y: 0 }</code> being the center of the HUD overlay.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.sphericalToOverlay');
    }
};
javascript.javascriptGenerator.forBlock['HMD_sphericalToOverlay'] = (block, generator) => {
    const _sphericalPos = dfv(generator.valueToCode(block, 'sphericalPos', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`HMD.sphericalToOverlay(${_sphericalPos})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_overlayToSpherical'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.overlayToSpherical')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data
        this.appendValueInput('overlayPos') 
            .setCheck('Vec2')
            .appendField('overlayPos');

        this.setColour('#23491C');
        this.setTooltip('Gets the spherical coordinates of a 2D point on the HUD overlay.2D HUD overlay coordinates are pixels with the origin at the top left of the overlay.Spherical coordinates are polar coordinates in radians with <code>{ x: 0, y: 0 }</code> being the center of the HUDoverlay.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.overlayToSpherical');
    }
};
javascript.javascriptGenerator.forBlock['HMD_overlayToSpherical'] = (block, generator) => {
    const _overlayPos = dfv(generator.valueToCode(block, 'overlayPos', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`HMD.overlayToSpherical(${_overlayPos})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_centerUI'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.centerUI')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Recenters the HMD HUD to the current HMD position and orientation.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.centerUI');
    }
};
javascript.javascriptGenerator.forBlock['HMD_centerUI'] = (block, generator) => {


    return `HMD.centerUI();\n`;};


// Blockly function
Blockly.Blocks['HMD_preferredAudioInput'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.preferredAudioInput')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Gets the name of the HMD audio input device.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.preferredAudioInput');
    }
};
javascript.javascriptGenerator.forBlock['HMD_preferredAudioInput'] = (block, generator) => {

return [`HMD.preferredAudioInput()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_preferredAudioOutput'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.preferredAudioOutput')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Gets the name of the HMD audio output device.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.preferredAudioOutput');
    }
};
javascript.javascriptGenerator.forBlock['HMD_preferredAudioOutput'] = (block, generator) => {

return [`HMD.preferredAudioOutput()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_isHMDAvailable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.isHMDAvailable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#23491C');
        this.setTooltip('Checks whether there is an HMD available.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.isHMDAvailable');
    }
};
javascript.javascriptGenerator.forBlock['HMD_isHMDAvailable'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`HMD.isHMDAvailable(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_isHeadControllerAvailable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.isHeadControllerAvailable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#23491C');
        this.setTooltip('Checks whether there is an HMD head controller available.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.isHeadControllerAvailable');
    }
};
javascript.javascriptGenerator.forBlock['HMD_isHeadControllerAvailable'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`HMD.isHeadControllerAvailable(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_isHandControllerAvailable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.isHandControllerAvailable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#23491C');
        this.setTooltip('Checks whether there are HMD hand controllers available.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.isHandControllerAvailable');
    }
};
javascript.javascriptGenerator.forBlock['HMD_isHandControllerAvailable'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`HMD.isHandControllerAvailable(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_isSubdeviceContainingNameAvailable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.isSubdeviceContainingNameAvailable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#23491C');
        this.setTooltip('Checks whether there are specific HMD controllers available.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.isSubdeviceContainingNameAvailable');
    }
};
javascript.javascriptGenerator.forBlock['HMD_isSubdeviceContainingNameAvailable'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`HMD.isSubdeviceContainingNameAvailable(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_requestShowHandControllers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.requestShowHandControllers')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Signals that models of the HMD hand controllers being used should be displayed. The models are displayed at their actual, real-world locations.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.requestShowHandControllers');
    }
};
javascript.javascriptGenerator.forBlock['HMD_requestShowHandControllers'] = (block, generator) => {


    return `HMD.requestShowHandControllers();\n`;};


// Blockly function
Blockly.Blocks['HMD_requestHideHandControllers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.requestHideHandControllers')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Signals that it is no longer necessary to display models of the HMD hand controllers being used. If no other scripts want the models displayed then they are no longer displayed.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.requestHideHandControllers');
    }
};
javascript.javascriptGenerator.forBlock['HMD_requestHideHandControllers'] = (block, generator) => {


    return `HMD.requestHideHandControllers();\n`;};


// Blockly function
Blockly.Blocks['HMD_shouldShowHandControllers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.shouldShowHandControllers')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Checks whether any script wants models of the HMD hand controllers displayed. Requests are made and canceled using {@link HMD.requestShowHandControllers|requestShowHandControllers} and {@link HMD.requestHideHandControllers|requestHideHandControllers}.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.shouldShowHandControllers');
    }
};
javascript.javascriptGenerator.forBlock['HMD_shouldShowHandControllers'] = (block, generator) => {

return [`HMD.shouldShowHandControllers()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_activateHMDHandMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.activateHMDHandMouse')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Causes the borders in HUD windows to be enlarged when the laser intersects them in HMD mode. By default, borders are not enlarged.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.activateHMDHandMouse');
    }
};
javascript.javascriptGenerator.forBlock['HMD_activateHMDHandMouse'] = (block, generator) => {


    return `HMD.activateHMDHandMouse();\n`;};


// Blockly function
Blockly.Blocks['HMD_deactivateHMDHandMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.deactivateHMDHandMouse')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Causes the border in HUD windows to no longer be enlarged when the laser intersects them in HMD mode. By default, borders are not enlarged.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.deactivateHMDHandMouse');
    }
};
javascript.javascriptGenerator.forBlock['HMD_deactivateHMDHandMouse'] = (block, generator) => {


    return `HMD.deactivateHMDHandMouse();\n`;};


// Blockly function
Blockly.Blocks['HMD_suppressKeyboard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.suppressKeyboard')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Suppresses the activation of the HMD-provided keyboard, if any. Successful calls should be balanced with a call to {@link HMD.unsuppressKeyboard|unsuppressKeyboard} within a reasonable amount of time.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.suppressKeyboard');
    }
};
javascript.javascriptGenerator.forBlock['HMD_suppressKeyboard'] = (block, generator) => {

return [`HMD.suppressKeyboard()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_unsuppressKeyboard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.unsuppressKeyboard')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Unsuppresses the activation of the HMD-provided keyboard, if any.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.unsuppressKeyboard');
    }
};
javascript.javascriptGenerator.forBlock['HMD_unsuppressKeyboard'] = (block, generator) => {


    return `HMD.unsuppressKeyboard();\n`;};


// Blockly function
Blockly.Blocks['HMD_isKeyboardVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.isKeyboardVisible')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Checks whether the HMD-provided keyboard, if any, is visible.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.isKeyboardVisible');
    }
};
javascript.javascriptGenerator.forBlock['HMD_isKeyboardVisible'] = (block, generator) => {

return [`HMD.isKeyboardVisible()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_closeTablet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.closeTablet')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Closes the tablet if it is open.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.closeTablet');
    }
};
javascript.javascriptGenerator.forBlock['HMD_closeTablet'] = (block, generator) => {


    return `HMD.closeTablet();\n`;};


// Blockly function
Blockly.Blocks['HMD_openTablet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.openTablet')
        // Returns data

        // Params data
        this.appendValueInput('contextualMode') 
            .setCheck('Boolean')
            .appendField('contextualMode');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#23491C');
        this.setTooltip('Opens the tablet if the tablet is used in the current display mode and it isn\'t already showing, and sets the tablet to contextual mode if requested. In contextual mode, the page displayed on the tablet is wholly controlled by script (i.e., the user cannot navigate to another).');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.openTablet');
    }
};
javascript.javascriptGenerator.forBlock['HMD_openTablet'] = (block, generator) => {
    const _contextualMode = dfv(generator.valueToCode(block, 'contextualMode', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `HMD.openTablet(${_contextualMode});\n`;};


// Blockly signal
Blockly.Blocks['HMD_shouldShowHandControllersChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.shouldShowHandControllersChanged');


        this.setColour('#23491C');
        this.setTooltip('Triggered when a request to show or hide models of the HMD hand controllers is made using {@link HMD.requestShowHandControllers|requestShowHandControllers} or{@link HMD.requestHideHandControllers|requestHideHandControllers}.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.shouldShowHandControllersChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_shouldShowHandControllersChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `HMD.shouldShowHandControllersChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['HMD_showTabletChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.showTabletChanged');

        this.appendDummyInput('showTablet')
            .appendField('showTablet:')
            .appendField(new Blockly.FieldVariable('showTabletChanged_showTablet'), 'showTablet');

        this.setColour('#23491C');
        this.setTooltip('Triggered when the tablet is shown or hidden.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.showTabletChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_showTabletChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const showTablet = generator.getVariableName(block.getFieldValue('showTablet'));

return `HMD.showTabletChanged.connect((_showTablet) => { 
  ${showTablet} = _showTablet;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['HMD_miniTabletEnabledChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.miniTabletEnabledChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('miniTabletEnabledChanged_enabled'), 'enabled');

        this.setColour('#23491C');
        this.setTooltip('Triggered when the ability to display the mini tablet has changed.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.miniTabletEnabledChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_miniTabletEnabledChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `HMD.miniTabletEnabledChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['HMD_awayStateWhenFocusLostInVRChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.awayStateWhenFocusLostInVRChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('awayStateWhenFocusLostInVRChanged_enabled'), 'enabled');

        this.setColour('#23491C');
        this.setTooltip('Triggered when the altering the mode for going into an away state when the interface focus is lost in VR.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.awayStateWhenFocusLostInVRChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_awayStateWhenFocusLostInVRChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `HMD.awayStateWhenFocusLostInVRChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['HMD_getHUDLookAtPosition2D'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.getHUDLookAtPosition2D')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Gets the position on the HUD overlay that your HMD is looking at, in HUD coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.getHUDLookAtPosition2D');
    }
};
javascript.javascriptGenerator.forBlock['HMD_getHUDLookAtPosition2D'] = (block, generator) => {

return [`HMD.getHUDLookAtPosition2D()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['HMD_getHUDLookAtPosition3D'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HMD.getHUDLookAtPosition3D')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#23491C');
        this.setTooltip('Gets the position on the HUD overlay that your HMD is looking at, in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.getHUDLookAtPosition3D');
    }
};
javascript.javascriptGenerator.forBlock['HMD_getHUDLookAtPosition3D'] = (block, generator) => {

return [`HMD.getHUDLookAtPosition3D()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['Keyboard_raised'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.raised')       
        this.setOutput(true, '');
        this.setColour('#6CE4D8');
        this.setTooltip('<code>true</code> if the virtual keyboard is visible, <code>false</code> if it isn\'t.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.raised');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_raised'] = (block, generator) => {
    return [`Keyboard.raised`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Keyboard_password'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.password')       
        this.setOutput(true, '');
        this.setColour('#6CE4D8');
        this.setTooltip('<code>true</code> if <code>"*"</code>s are displayed on the virtual keyboard\'s display     instead of the characters typed, <code>false</code> if the actual characters are displayed.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.password');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_password'] = (block, generator) => {
    return [`Keyboard.password`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Keyboard_use3DKeyboard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.use3DKeyboard')       
        this.setOutput(true, '');
        this.setColour('#6CE4D8');
        this.setTooltip('<code>true</code> if user settings have "Use Virtual Keyboard" enabled,     <code>false</code> if it\'s disabled. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.use3DKeyboard');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_use3DKeyboard'] = (block, generator) => {
    return [`Keyboard.use3DKeyboard`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Keyboard_preferMalletsOverLasers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.preferMalletsOverLasers')       
        this.setOutput(true, '');
        this.setColour('#6CE4D8');
        this.setTooltip('<code>true</code> if user settings for the virtual keyboard have "Mallets"     selected, <code>false</code> if "Lasers" is selected. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.preferMalletsOverLasers');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_preferMalletsOverLasers'] = (block, generator) => {
    return [`Keyboard.preferMalletsOverLasers`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Keyboard_loadKeyboardFile'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.loadKeyboardFile')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Loads a JSON file that defines the virtual keyboard\'s layout. The default JSON file used is {@link https://github.com/highfidelity/hifi/blob/master/interface/resources/config/keyboard.json|https://github.com/highfidelity/hifi/.../keyboard.json}.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.loadKeyboardFile');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_loadKeyboardFile'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Keyboard.loadKeyboardFile(${_path});\n`;};


// Blockly function
Blockly.Blocks['Keyboard_enableLeftMallet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.enableLeftMallet')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Enables the left mallet so that it is displayed when in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.enableLeftMallet');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_enableLeftMallet'] = (block, generator) => {


    return `Keyboard.enableLeftMallet();\n`;};


// Blockly function
Blockly.Blocks['Keyboard_enableRightMallet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.enableRightMallet')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Enables the right mallet so that it is displayed when in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.enableRightMallet');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_enableRightMallet'] = (block, generator) => {


    return `Keyboard.enableRightMallet();\n`;};


// Blockly function
Blockly.Blocks['Keyboard_disableLeftMallet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.disableLeftMallet')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Disables the left mallet so that it is not displayed when in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.disableLeftMallet');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_disableLeftMallet'] = (block, generator) => {


    return `Keyboard.disableLeftMallet();\n`;};


// Blockly function
Blockly.Blocks['Keyboard_disableRightMallet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.disableRightMallet')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Disables the right mallet so that it is not displayed when in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.disableRightMallet');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_disableRightMallet'] = (block, generator) => {


    return `Keyboard.disableRightMallet();\n`;};


// Blockly function
Blockly.Blocks['Keyboard_setLeftHandLaser'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.setLeftHandLaser')
        // Returns data

        // Params data
        this.appendValueInput('leftHandLaser') 
            .setCheck('Number')
            .appendField('leftHandLaser');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Configures the virtual keyboard to recognize a ray pointer as the left hand\'s laser.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.setLeftHandLaser');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_setLeftHandLaser'] = (block, generator) => {
    const _leftHandLaser = dfv(generator.valueToCode(block, 'leftHandLaser', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Keyboard.setLeftHandLaser(${_leftHandLaser});\n`;};


// Blockly function
Blockly.Blocks['Keyboard_setRightHandLaser'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.setRightHandLaser')
        // Returns data

        // Params data
        this.appendValueInput('rightHandLaser') 
            .setCheck('Number')
            .appendField('rightHandLaser');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6CE4D8');
        this.setTooltip('Configures the virtual keyboard to recognize a ray pointer as the right hand\'s laser.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.setRightHandLaser');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_setRightHandLaser'] = (block, generator) => {
    const _rightHandLaser = dfv(generator.valueToCode(block, 'rightHandLaser', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Keyboard.setRightHandLaser(${_rightHandLaser});\n`;};


// Blockly function
Blockly.Blocks['Keyboard_containsID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Keyboard.containsID')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#6CE4D8');
        this.setTooltip('Checks whether an entity is part of the virtual keyboard.');
        this.setHelpUrl('https://apidocs.overte.org/Keyboard.html#.containsID');
    }
};
javascript.javascriptGenerator.forBlock['Keyboard_containsID'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Keyboard.containsID(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Menu_addMenu'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.addMenu')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('grouping') 
            .setCheck('String')
            .appendField('grouping');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Adds a new top-level menu.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.addMenu');
    }
};
javascript.javascriptGenerator.forBlock['Menu_addMenu'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _grouping = dfv(generator.valueToCode(block, 'grouping', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.addMenu(${_menuName},${_grouping});\n`;};


// Blockly function
Blockly.Blocks['Menu_removeMenu'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.removeMenu')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Removes a top-level menu.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.removeMenu');
    }
};
javascript.javascriptGenerator.forBlock['Menu_removeMenu'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.removeMenu(${_menuName});\n`;};


// Blockly function
Blockly.Blocks['Menu_menuExists'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.menuExists')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');

        this.setColour('#B61541');
        this.setTooltip('Checks whether a top-level menu exists.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.menuExists');
    }
};
javascript.javascriptGenerator.forBlock['Menu_menuExists'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Menu.menuExists(${_menuName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Menu_addSeparator'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.addSeparator')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('separatorName') 
            .setCheck('String')
            .appendField('separatorName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Adds a separator with an unclickable label below it. The separator will be placed at the bottom of the menu. To add a separator at a specific point in the menu, use {@link Menu.addMenuItem} with {@link Menu.MenuItemProperties} instead.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.addSeparator');
    }
};
javascript.javascriptGenerator.forBlock['Menu_addSeparator'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _separatorName = dfv(generator.valueToCode(block, 'separatorName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.addSeparator(${_menuName},${_separatorName});\n`;};


// Blockly function
Blockly.Blocks['Menu_removeSeparator'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.removeSeparator')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('separatorName') 
            .setCheck('String')
            .appendField('separatorName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Removes a separator from a menu.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.removeSeparator');
    }
};
javascript.javascriptGenerator.forBlock['Menu_removeSeparator'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _separatorName = dfv(generator.valueToCode(block, 'separatorName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.removeSeparator(${_menuName},${_separatorName});\n`;};


// Blockly function
Blockly.Blocks['Menu_addMenuItem'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.addMenuItem')
        // Returns data

        // Params data
        this.appendValueInput('properties') 
            .setCheck('Menu.MenuItemProperties')
            .appendField('properties');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Adds a new menu item to a menu. The menu item is specified using {@link Menu.MenuItemProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.addMenuItem');
    }
};
javascript.javascriptGenerator.forBlock['Menu_addMenuItem'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.addMenuItem(${_properties});\n`;};


// Blockly function
Blockly.Blocks['Menu_addMenuItemmenuNamemenuItemshortcutKey'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.addMenuItem')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('menuItem') 
            .setCheck('String')
            .appendField('menuItem');
        this.appendValueInput('shortcutKey') 
            .setCheck('String')
            .appendField('shortcutKey');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Adds a new menu item to a menu. The new item is added at the end of the menu.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.addMenuItem');
    }
};
javascript.javascriptGenerator.forBlock['Menu_addMenuItemmenuNamemenuItemshortcutKey'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _menuItem = dfv(generator.valueToCode(block, 'menuItem', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shortcutKey = dfv(generator.valueToCode(block, 'shortcutKey', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.addMenuItem(${_menuName},${_menuItem},${_shortcutKey});\n`;};


// Blockly function
Blockly.Blocks['Menu_removeMenuItem'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.removeMenuItem')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('menuItem') 
            .setCheck('String')
            .appendField('menuItem');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Removes a menu item from a menu.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.removeMenuItem');
    }
};
javascript.javascriptGenerator.forBlock['Menu_removeMenuItem'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _menuItem = dfv(generator.valueToCode(block, 'menuItem', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.removeMenuItem(${_menuName},${_menuItem});\n`;};


// Blockly function
Blockly.Blocks['Menu_menuItemExists'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.menuItemExists')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('menuItem') 
            .setCheck('String')
            .appendField('menuItem');

        this.setColour('#B61541');
        this.setTooltip('Checks whether a menu item exists.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.menuItemExists');
    }
};
javascript.javascriptGenerator.forBlock['Menu_menuItemExists'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _menuItem = dfv(generator.valueToCode(block, 'menuItem', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Menu.menuItemExists(${_menuName},${_menuItem})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Menu_isOptionChecked'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.isOptionChecked')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('menuOption') 
            .setCheck('String')
            .appendField('menuOption');

        this.setColour('#B61541');
        this.setTooltip('Checks whether a checkable menu item is checked.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.isOptionChecked');
    }
};
javascript.javascriptGenerator.forBlock['Menu_isOptionChecked'] = (block, generator) => {
    const _menuOption = dfv(generator.valueToCode(block, 'menuOption', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Menu.isOptionChecked(${_menuOption})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Menu_setIsOptionChecked'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.setIsOptionChecked')
        // Returns data

        // Params data
        this.appendValueInput('menuOption') 
            .setCheck('String')
            .appendField('menuOption');
        this.appendValueInput('isChecked') 
            .setCheck('Boolean')
            .appendField('isChecked');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Sets a checkable menu item as checked or unchecked.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.setIsOptionChecked');
    }
};
javascript.javascriptGenerator.forBlock['Menu_setIsOptionChecked'] = (block, generator) => {
    const _menuOption = dfv(generator.valueToCode(block, 'menuOption', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isChecked = dfv(generator.valueToCode(block, 'isChecked', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Menu.setIsOptionChecked(${_menuOption},${_isChecked});\n`;};


// Blockly function
Blockly.Blocks['Menu_triggerOption'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.triggerOption')
        // Returns data

        // Params data
        this.appendValueInput('menuOption') 
            .setCheck('String')
            .appendField('menuOption');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Triggers a menu item as if the user clicked on it.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.triggerOption');
    }
};
javascript.javascriptGenerator.forBlock['Menu_triggerOption'] = (block, generator) => {
    const _menuOption = dfv(generator.valueToCode(block, 'menuOption', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Menu.triggerOption(${_menuOption});\n`;};


// Blockly function
Blockly.Blocks['Menu_isMenuEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.isMenuEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');

        this.setColour('#B61541');
        this.setTooltip('Checks whether a menu or menu item is enabled. If disabled, the item is grayed out and unusable.Menus are enabled by default.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.isMenuEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Menu_isMenuEnabled'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Menu.isMenuEnabled(${_menuName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Menu_setMenuEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.setMenuEnabled')
        // Returns data

        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('isEnabled') 
            .setCheck('Boolean')
            .appendField('isEnabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B61541');
        this.setTooltip('Sets a menu or menu item to be enabled or disabled. If disabled, the item is grayed out and unusable.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.setMenuEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Menu_setMenuEnabled'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isEnabled = dfv(generator.valueToCode(block, 'isEnabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Menu.setMenuEnabled(${_menuName},${_isEnabled});\n`;};


// Blockly signal
Blockly.Blocks['Menu_menuItemEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Menu.menuItemEvent');

        this.appendDummyInput('menuItem')
            .appendField('menuItem:')
            .appendField(new Blockly.FieldVariable('menuItemEvent_menuItem'), 'menuItem');

        this.setColour('#B61541');
        this.setTooltip('Triggered when a menu item is clicked or triggered by {@link Menu.triggerOption}.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.menuItemEvent');
    }
};
javascript.javascriptGenerator.forBlock['Menu_menuItemEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const menuItem = generator.getVariableName(block.getFieldValue('menuItem'));

return `Menu.menuItemEvent.connect((_menuItem) => { 
  ${menuItem} = _menuItem;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Performance_performancePreset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.performancePreset')       
        this.setOutput(true, '');
        this.setColour('#9446A9');
        this.setTooltip('The current graphics performance preset.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.performancePreset');
    }
};
javascript.javascriptGenerator.forBlock['Performance_performancePreset'] = (block, generator) => {
    return [`Performance.performancePreset`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Performance_refreshRateProfile'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.refreshRateProfile')       
        this.setOutput(true, '');
        this.setColour('#9446A9');
        this.setTooltip('The current refresh rate profile.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.refreshRateProfile');
    }
};
javascript.javascriptGenerator.forBlock['Performance_refreshRateProfile'] = (block, generator) => {
    return [`Performance.refreshRateProfile`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly typedef
Blockly.Blocks['Performance_PerformancePreset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.PerformancePreset')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9446A9');
        this.setTooltip('<p>Graphics performance presets.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>UNKNOWN</td><td>Custom settings of world detail, rendering effects, and refresh       rate.</td></tr>    <tr><td><code>1</code></td><td>LOW</td><td>Low world detail, no rendering effects, lo refresh rate.</td></tr>    <tr><td><code>2</code></td><td>MID</td><td>Medium world detail, some rendering effects, medium refresh       rate.</td></tr>    <tr><td><code>3</code></td><td>HIGH</td><td>Maximum world detail, all rendering effects, high refresh rate.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.PerformancePreset');
    }
};
javascript.javascriptGenerator.forBlock['Performance_PerformancePreset'] = (block, generator) => {

    return [`new Performance.PerformancePreset()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Performance_RefreshRateProfile'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.RefreshRateProfile')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9446A9');
        this.setTooltip('<p>Refresh rate profile.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>ECO</td><td>Low refresh rate, which is reduced when Interface doesn\'t have focus or       is minimized.</td></tr>    <tr><td><code>1</code></td><td>INTERACTIVE</td><td>Medium refresh rate, which is reduced when Interface doesn\'t have       focus or is minimized.</td></tr>    <tr><td><code>2</code></td><td>REALTIME</td><td>High refresh rate, even when Interface doesn\'t have focus or is       minimized. </td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.RefreshRateProfile');
    }
};
javascript.javascriptGenerator.forBlock['Performance_RefreshRateProfile'] = (block, generator) => {

    return [`new Performance.RefreshRateProfile()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Performance_setPerformancePreset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.setPerformancePreset')
        // Returns data

        // Params data
        this.appendValueInput('performancePreset') 
            .setCheck('Performance.PerformancePreset')
            .appendField('performancePreset');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9446A9');
        this.setTooltip('Sets graphics performance to a preset.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.setPerformancePreset');
    }
};
javascript.javascriptGenerator.forBlock['Performance_setPerformancePreset'] = (block, generator) => {
    const _performancePreset = dfv(generator.valueToCode(block, 'performancePreset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Performance.setPerformancePreset(${_performancePreset});\n`;};


// Blockly function
Blockly.Blocks['Performance_getPerformancePreset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getPerformancePreset')
        // Returns data
        this.setOutput(true, '["Performance.PerformancePreset"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the current graphics performance preset in use.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getPerformancePreset');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getPerformancePreset'] = (block, generator) => {

return [`Performance.getPerformancePreset()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_getPerformancePresetNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getPerformancePresetNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the names of the graphics performance presets.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getPerformancePresetNames');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getPerformancePresetNames'] = (block, generator) => {

return [`Performance.getPerformancePresetNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_setRefreshRateProfile'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.setRefreshRateProfile')
        // Returns data

        // Params data
        this.appendValueInput('refreshRateProfile') 
            .setCheck('Performance.RefreshRateProfile')
            .appendField('refreshRateProfile');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9446A9');
        this.setTooltip('Sets the curfrent refresh rate profile.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.setRefreshRateProfile');
    }
};
javascript.javascriptGenerator.forBlock['Performance_setRefreshRateProfile'] = (block, generator) => {
    const _refreshRateProfile = dfv(generator.valueToCode(block, 'refreshRateProfile', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Performance.setRefreshRateProfile(${_refreshRateProfile});\n`;};


// Blockly function
Blockly.Blocks['Performance_setCustomRefreshRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.setCustomRefreshRate')
        // Returns data

        // Params data
        this.appendValueInput('refreshRateRegime') 
            .setCheck('RefreshRateRegime')
            .appendField('refreshRateRegime');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9446A9');
        this.setTooltip('Sets a custom refresh rate.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.setCustomRefreshRate');
    }
};
javascript.javascriptGenerator.forBlock['Performance_setCustomRefreshRate'] = (block, generator) => {
    const _refreshRateRegime = dfv(generator.valueToCode(block, 'refreshRateRegime', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Performance.setCustomRefreshRate(${_refreshRateRegime},${_value});\n`;};


// Blockly function
Blockly.Blocks['Performance_getCustomRefreshRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getCustomRefreshRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('parameter') 
            .setCheck('RefreshRateRegime')
            .appendField('parameter');

        this.setColour('#9446A9');
        this.setTooltip('Gets the value for a specific RefreshRateRegime.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getCustomRefreshRate');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getCustomRefreshRate'] = (block, generator) => {
    const _parameter = dfv(generator.valueToCode(block, 'parameter', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Performance.getCustomRefreshRate(${_parameter})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_getRefreshRateProfile'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getRefreshRateProfile')
        // Returns data
        this.setOutput(true, '["Performance.RefreshRateProfile"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the current refresh rate profile in use.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getRefreshRateProfile');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getRefreshRateProfile'] = (block, generator) => {

return [`Performance.getRefreshRateProfile()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_getRefreshRateProfileNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getRefreshRateProfileNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the names of the refresh rate profiles.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getRefreshRateProfileNames');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getRefreshRateProfileNames'] = (block, generator) => {

return [`Performance.getRefreshRateProfileNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_getActiveRefreshRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getActiveRefreshRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the current target refresh rate, in Hz, per the current refresh rate profile and refresh rate regime if in desktop mode; a higher rate if in VR mode.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getActiveRefreshRate');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getActiveRefreshRate'] = (block, generator) => {

return [`Performance.getActiveRefreshRate()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_getUXMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getUXMode')
        // Returns data
        this.setOutput(true, '["UXMode"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the current user experience mode.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getUXMode');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getUXMode'] = (block, generator) => {

return [`Performance.getUXMode()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Performance_getRefreshRateRegime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Performance.getRefreshRateRegime')
        // Returns data
        this.setOutput(true, '["RefreshRateRegime"]');

        // Params data

        this.setColour('#9446A9');
        this.setTooltip('Gets the current refresh rate regime that\'s in effect.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.getRefreshRateRegime');
    }
};
javascript.javascriptGenerator.forBlock['Performance_getRefreshRateRegime'] = (block, generator) => {

return [`Performance.getRefreshRateRegime()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Performance_settingsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Performance.settingsChanged');


        this.setColour('#9446A9');
        this.setTooltip('Triggered when the performance preset or refresh rate profile is changed.');
        this.setHelpUrl('https://apidocs.overte.org/Performance.html#.settingsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Performance_settingsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Performance.settingsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['PlatformInfo_PlatformTier'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.PlatformTier')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#178142');
        this.setTooltip('<p>The platform tier of a computer is an indication of its rendering capability.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>UNKNOWN</td><td>Unknown rendering capability.</td></tr>    <tr><td><code>1</code></td><td>LOW</td><td>Low-end PC, capable of rendering low-quality graphics.</td></tr>    <tr><td><code>2</code></td><td>MID</td><td>Business-class PC, capable of rendering medium-quality graphics.</td></tr>    <tr><td><code>3</code></td><td>HIGH</td><td>High-end PC, capable of rendering high-quality graphics.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.PlatformTier');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_PlatformTier'] = (block, generator) => {

    return [`new PlatformInfo.PlatformTier()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['PlatformInfo_hasRiftControllers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.hasRiftControllers')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Checks whether Oculus Touch controllers are connected.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.hasRiftControllers');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_hasRiftControllers'] = (block, generator) => {

return [`PlatformInfo.hasRiftControllers()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_hasViveControllers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.hasViveControllers')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Checks whether Vive controllers are connected.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.hasViveControllers');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_hasViveControllers'] = (block, generator) => {

return [`PlatformInfo.hasViveControllers()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_has3DHTML'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.has3DHTML')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Checks whether HTML on 3D surfaces (e.g., Web entities) is supported.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.has3DHTML');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_has3DHTML'] = (block, generator) => {

return [`PlatformInfo.has3DHTML()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_isStandalone'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.isStandalone')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Checks whether Interface is running on a stand-alone HMD device (CPU incorporated into the HMD display).');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.isStandalone');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_isStandalone'] = (block, generator) => {

return [`PlatformInfo.isStandalone()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getNumCPUs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getNumCPUs')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the number of CPUs.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getNumCPUs');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getNumCPUs'] = (block, generator) => {

return [`PlatformInfo.getNumCPUs()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getPrimaryCPU'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getPrimaryCPU')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the index number of the primary CPU.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getPrimaryCPU');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getPrimaryCPU'] = (block, generator) => {

return [`PlatformInfo.getPrimaryCPU()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getCPU'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getCPU')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#178142');
        this.setTooltip('Gets the platform description of a CPU.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getCPU');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getCPU'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`PlatformInfo.getCPU(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getNumGPUs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getNumGPUs')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the number of GPUs.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getNumGPUs');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getNumGPUs'] = (block, generator) => {

return [`PlatformInfo.getNumGPUs()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getPrimaryGPU'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getPrimaryGPU')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the index number of the primary GPU.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getPrimaryGPU');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getPrimaryGPU'] = (block, generator) => {

return [`PlatformInfo.getPrimaryGPU()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getGPU'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getGPU')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#178142');
        this.setTooltip('Gets the platform description of a GPU.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getGPU');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getGPU'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`PlatformInfo.getGPU(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getNumDisplays'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getNumDisplays')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the number of displays.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getNumDisplays');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getNumDisplays'] = (block, generator) => {

return [`PlatformInfo.getNumDisplays()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getPrimaryDisplay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getPrimaryDisplay')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the index number of the primary display.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getPrimaryDisplay');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getPrimaryDisplay'] = (block, generator) => {

return [`PlatformInfo.getPrimaryDisplay()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getDisplay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getDisplay')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#178142');
        this.setTooltip('Gets the platform description of a display.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getDisplay');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getDisplay'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`PlatformInfo.getDisplay(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getMemory')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the platform description of computer memory.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getMemory');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getMemory'] = (block, generator) => {

return [`PlatformInfo.getMemory()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getComputer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getComputer')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the platform description of the computer.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getComputer');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getComputer'] = (block, generator) => {

return [`PlatformInfo.getComputer()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getPlatform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getPlatform')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the complete description of the computer as a whole.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getPlatform');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getPlatform'] = (block, generator) => {

return [`PlatformInfo.getPlatform()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getTierProfiled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getTierProfiled')
        // Returns data
        this.setOutput(true, '["PlatformInfo.PlatformTier"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the platform tier of the computer, profiled at Interface start-up.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getTierProfiled');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getTierProfiled'] = (block, generator) => {

return [`PlatformInfo.getTierProfiled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_getPlatformTierNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.getPlatformTierNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets the names of the possible platform tiers, per {@link PlatformInfo.PlatformTier}.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.getPlatformTierNames');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_getPlatformTierNames'] = (block, generator) => {

return [`PlatformInfo.getPlatformTierNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['PlatformInfo_isRenderMethodDeferredCapable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.isRenderMethodDeferredCapable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#178142');
        this.setTooltip('Gets whether the current hardware can use deferred rendering.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.isRenderMethodDeferredCapable');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_isRenderMethodDeferredCapable'] = (block, generator) => {

return [`PlatformInfo.isRenderMethodDeferredCapable()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['Rates_render'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Rates.render')       
        this.setOutput(true, '');
        this.setColour('#62FD28');
        this.setTooltip('The rate at which new GPU frames are being created, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Rates.html#.render');
    }
};
javascript.javascriptGenerator.forBlock['Rates_render'] = (block, generator) => {
    return [`Rates.render`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Rates_present'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Rates.present')       
        this.setOutput(true, '');
        this.setColour('#62FD28');
        this.setTooltip('The rate at which the display plugin is presenting to the display device, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Rates.html#.present');
    }
};
javascript.javascriptGenerator.forBlock['Rates_present'] = (block, generator) => {
    return [`Rates.present`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Rates_newFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Rates.newFrame')       
        this.setOutput(true, '');
        this.setColour('#62FD28');
        this.setTooltip('The rate at which the display plugin is presenting new GPU frames, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Rates.html#.newFrame');
    }
};
javascript.javascriptGenerator.forBlock['Rates_newFrame'] = (block, generator) => {
    return [`Rates.newFrame`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Rates_dropped'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Rates.dropped')       
        this.setOutput(true, '');
        this.setColour('#62FD28');
        this.setTooltip('The rate at which the display plugin is dropping GPU frames, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Rates.html#.dropped');
    }
};
javascript.javascriptGenerator.forBlock['Rates_dropped'] = (block, generator) => {
    return [`Rates.dropped`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Rates_simulation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Rates.simulation')       
        this.setOutput(true, '');
        this.setColour('#62FD28');
        this.setTooltip('The rate at which the game loop is running, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Rates.html#.simulation');
    }
};
javascript.javascriptGenerator.forBlock['Rates_simulation'] = (block, generator) => {
    return [`Rates.simulation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Render_renderMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.renderMethod')       
        this.setOutput(true, '');
        this.setColour('#5E520D');
        this.setTooltip('The render method being used.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.renderMethod');
    }
};
javascript.javascriptGenerator.forBlock['Render_renderMethod'] = (block, generator) => {
    return [`Render.renderMethod`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Render_shadowsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.shadowsEnabled')       
        this.setOutput(true, '');
        this.setColour('#5E520D');
        this.setTooltip('<code>true</code> if shadows are enabled, <code>false</code> if they\'re disabled.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.shadowsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Render_shadowsEnabled'] = (block, generator) => {
    return [`Render.shadowsEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Render_ambientOcclusionEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.ambientOcclusionEnabled')       
        this.setOutput(true, '');
        this.setColour('#5E520D');
        this.setTooltip('<code>true</code> if ambient occlusion is enabled, <code>false</code> if it\'s    disabled.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.ambientOcclusionEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Render_ambientOcclusionEnabled'] = (block, generator) => {
    return [`Render.ambientOcclusionEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Render_antialiasingMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.antialiasingMode')       
        this.setOutput(true, '');
        this.setColour('#5E520D');
        this.setTooltip('The active anti-aliasing mode.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.antialiasingMode');
    }
};
javascript.javascriptGenerator.forBlock['Render_antialiasingMode'] = (block, generator) => {
    return [`Render.antialiasingMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Render_viewportResolutionScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.viewportResolutionScale')       
        this.setOutput(true, '');
        this.setColour('#5E520D');
        this.setTooltip('The view port resolution scale, <code>&gt; 0.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.viewportResolutionScale');
    }
};
javascript.javascriptGenerator.forBlock['Render_viewportResolutionScale'] = (block, generator) => {
    return [`Render.viewportResolutionScale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly typedef
Blockly.Blocks['Render_RenderMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.RenderMethod')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#5E520D');
        this.setTooltip('<p>The rendering method is specified by the following values:</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>DEFERRED</td><td>More complex rendering pipeline where lighting is applied to the      scene as a whole after all objects have been rendered.</td></tr>    <tr><td><code>1</code></td><td>FORWARD</td><td>Simpler rendering pipeline where each object in the scene, in turn,      is rendered and has lighting applied.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.RenderMethod');
    }
};
javascript.javascriptGenerator.forBlock['Render_RenderMethod'] = (block, generator) => {

    return [`new Render.RenderMethod()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Render_getConfig'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getConfig')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#5E520D');
        this.setTooltip('Gets the configuration for a rendering job by name.<p><strong>Warning:</strong> For internal, debugging purposes. Subject to change.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getConfig');
    }
};
javascript.javascriptGenerator.forBlock['Render_getConfig'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Render.getConfig(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_getRenderMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getRenderMethod')
        // Returns data
        this.setOutput(true, '["Render.RenderMethod"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets the render method being used.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getRenderMethod');
    }
};
javascript.javascriptGenerator.forBlock['Render_getRenderMethod'] = (block, generator) => {

return [`Render.getRenderMethod()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setRenderMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setRenderMethod')
        // Returns data

        // Params data
        this.appendValueInput('renderMethod') 
            .setCheck('Render.RenderMethod')
            .appendField('renderMethod');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#5E520D');
        this.setTooltip('Sets the render method to use.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setRenderMethod');
    }
};
javascript.javascriptGenerator.forBlock['Render_setRenderMethod'] = (block, generator) => {
    const _renderMethod = dfv(generator.valueToCode(block, 'renderMethod', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Render.setRenderMethod(${_renderMethod});\n`;};


// Blockly function
Blockly.Blocks['Render_getRenderMethodNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getRenderMethodNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets the names of the possible render methods, per {@link Render.RenderMethod}.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getRenderMethodNames');
    }
};
javascript.javascriptGenerator.forBlock['Render_getRenderMethodNames'] = (block, generator) => {

return [`Render.getRenderMethodNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_getShadowsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getShadowsEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets whether or not shadows are enabled.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getShadowsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Render_getShadowsEnabled'] = (block, generator) => {

return [`Render.getShadowsEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setShadowsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setShadowsEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#5E520D');
        this.setTooltip('Sets whether or not shadows are enabled.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setShadowsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Render_setShadowsEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Render.setShadowsEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['Render_getAmbientOcclusionEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getAmbientOcclusionEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets whether or not ambient occlusion is enabled.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getAmbientOcclusionEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Render_getAmbientOcclusionEnabled'] = (block, generator) => {

return [`Render.getAmbientOcclusionEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setAmbientOcclusionEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setAmbientOcclusionEnabled')
        // Returns data

        // Params data
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#5E520D');
        this.setTooltip('Sets whether or not ambient occlusion is enabled.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setAmbientOcclusionEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Render_setAmbientOcclusionEnabled'] = (block, generator) => {
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Render.setAmbientOcclusionEnabled(${_enabled});\n`;};


// Blockly function
Blockly.Blocks['Render_getAntialiasingMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getAntialiasingMode')
        // Returns data
        this.setOutput(true, '["AntialiasingMode"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets the active anti-aliasing mode.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getAntialiasingMode');
    }
};
javascript.javascriptGenerator.forBlock['Render_getAntialiasingMode'] = (block, generator) => {

return [`Render.getAntialiasingMode()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setAntialiasingMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setAntialiasingMode')
        // Returns data

        // Params data
        this.appendValueInput('The') 
            .setCheck('AntialiasingMode')
            .appendField('The');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#5E520D');
        this.setTooltip('Sets the active anti-aliasing mode.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setAntialiasingMode');
    }
};
javascript.javascriptGenerator.forBlock['Render_setAntialiasingMode'] = (block, generator) => {
    const _The = dfv(generator.valueToCode(block, 'The', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Render.setAntialiasingMode(${_The});\n`;};


// Blockly function
Blockly.Blocks['Render_getViewportResolutionScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getViewportResolutionScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets the view port resolution scale.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getViewportResolutionScale');
    }
};
javascript.javascriptGenerator.forBlock['Render_getViewportResolutionScale'] = (block, generator) => {

return [`Render.getViewportResolutionScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setViewportResolutionScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setViewportResolutionScale')
        // Returns data

        // Params data
        this.appendValueInput('resolutionScale') 
            .setCheck('Number')
            .appendField('resolutionScale');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#5E520D');
        this.setTooltip('Sets the view port resolution scale.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setViewportResolutionScale');
    }
};
javascript.javascriptGenerator.forBlock['Render_setViewportResolutionScale'] = (block, generator) => {
    const _resolutionScale = dfv(generator.valueToCode(block, 'resolutionScale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Render.setViewportResolutionScale(${_resolutionScale});\n`;};


// Blockly function
Blockly.Blocks['Render_getScreens'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getScreens')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Returns the list of screens');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getScreens');
    }
};
javascript.javascriptGenerator.forBlock['Render_getScreens'] = (block, generator) => {

return [`Render.getScreens()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_getFullScreenScreen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getFullScreenScreen')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets the screen used when switching to full screen mode.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getFullScreenScreen');
    }
};
javascript.javascriptGenerator.forBlock['Render_getFullScreenScreen'] = (block, generator) => {

return [`Render.getFullScreenScreen()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setFullScreenScreen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setFullScreenScreen')
        // Returns data
        this.setOutput(true, '["bool"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Sets the screen used when switching to full screen mode.This function will only succeed if the name passed is one of the entries from Render.getScreens.Otherwise, it will return False and have no effect.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setFullScreenScreen');
    }
};
javascript.javascriptGenerator.forBlock['Render_setFullScreenScreen'] = (block, generator) => {

return [`Render.setFullScreenScreen()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_getVerticalFieldOfView'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.getVerticalFieldOfView')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#5E520D');
        this.setTooltip('Gets the vertical field of view in degrees.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.getVerticalFieldOfView');
    }
};
javascript.javascriptGenerator.forBlock['Render_getVerticalFieldOfView'] = (block, generator) => {

return [`Render.getVerticalFieldOfView()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Render_setVerticalFieldOfView'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Render.setVerticalFieldOfView')
        // Returns data

        // Params data
        this.appendValueInput('fieldOfView') 
            .setCheck('Number')
            .appendField('fieldOfView');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#5E520D');
        this.setTooltip('Sets the vertical field of view in degrees.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.setVerticalFieldOfView');
    }
};
javascript.javascriptGenerator.forBlock['Render_setVerticalFieldOfView'] = (block, generator) => {
    const _fieldOfView = dfv(generator.valueToCode(block, 'fieldOfView', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Render.setVerticalFieldOfView(${_fieldOfView});\n`;};


// Blockly signal
Blockly.Blocks['Render_settingsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Render.settingsChanged');


        this.setColour('#5E520D');
        this.setTooltip('Triggered when one of the <code>Render</code> API\'s properties changes.');
        this.setHelpUrl('https://apidocs.overte.org/Render.html#.settingsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Render_settingsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Render.settingsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Selection_ItemType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.ItemType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#6FF9DD');
        this.setTooltip('<p>The type of a specific item in a selection list.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"avatar"</code></td><td>The item is an avatar.</td></tr>    <tr><td><code>"entity"</code></td><td>The item is an entity.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.ItemType');
    }
};
javascript.javascriptGenerator.forBlock['Selection_ItemType'] = (block, generator) => {

    return [`new Selection.ItemType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Selection_SelectedItemsList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.SelectedItemsList')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('avatars') 
            .setCheck('Array')
            .appendField('avatars');
        this.appendValueInput('entities') 
            .setCheck('Array')
            .appendField('entities');
        this.setColour('#6FF9DD');
        this.setTooltip('A selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.SelectedItemsList');
    }
};
javascript.javascriptGenerator.forBlock['Selection_SelectedItemsList'] = (block, generator) => {
    const _avatars = dfv(generator.valueToCode(block, 'avatars', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entities = dfv(generator.valueToCode(block, 'entities', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Selection.SelectedItemsList(${_avatars},${_entities})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Selection_HighlightStyle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.HighlightStyle')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('outlineUnoccludedColor') 
            .setCheck('Color')
            .appendField('outlineUnoccludedColor');
        this.appendValueInput('outlineOccludedColor') 
            .setCheck('Color')
            .appendField('outlineOccludedColor');
        this.appendValueInput('fillUnoccludedColor') 
            .setCheck('Color')
            .appendField('fillUnoccludedColor');
        this.appendValueInput('fillOccludedColor') 
            .setCheck('Color')
            .appendField('fillOccludedColor');
        this.appendValueInput('outlineUnoccludedAlpha') 
            .setCheck('Number')
            .appendField('outlineUnoccludedAlpha');
        this.appendValueInput('outlineOccludedAlpha') 
            .setCheck('Number')
            .appendField('outlineOccludedAlpha');
        this.appendValueInput('fillUnoccludedAlpha') 
            .setCheck('Number')
            .appendField('fillUnoccludedAlpha');
        this.appendValueInput('fillOccludedAlpha') 
            .setCheck('Number')
            .appendField('fillOccludedAlpha');
        this.appendValueInput('outlineWidth') 
            .setCheck('Number')
            .appendField('outlineWidth');
        this.appendValueInput('isOutlineSmooth') 
            .setCheck('Boolean')
            .appendField('isOutlineSmooth');
        this.setColour('#6FF9DD');
        this.setTooltip('The highlighting style of a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.HighlightStyle');
    }
};
javascript.javascriptGenerator.forBlock['Selection_HighlightStyle'] = (block, generator) => {
    const _outlineUnoccludedColor = dfv(generator.valueToCode(block, 'outlineUnoccludedColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,178,51`);
    const _outlineOccludedColor = dfv(generator.valueToCode(block, 'outlineOccludedColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,178,51`);
    const _fillUnoccludedColor = dfv(generator.valueToCode(block, 'fillUnoccludedColor', javascript.javascriptGenerator.ORDER_ATOMIC), `51,178,255`);
    const _fillOccludedColor = dfv(generator.valueToCode(block, 'fillOccludedColor', javascript.javascriptGenerator.ORDER_ATOMIC), `51,178,255`);
    const _outlineUnoccludedAlpha = dfv(generator.valueToCode(block, 'outlineUnoccludedAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0.9`);
    const _outlineOccludedAlpha = dfv(generator.valueToCode(block, 'outlineOccludedAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0.9`);
    const _fillUnoccludedAlpha = dfv(generator.valueToCode(block, 'fillUnoccludedAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _fillOccludedAlpha = dfv(generator.valueToCode(block, 'fillOccludedAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _outlineWidth = dfv(generator.valueToCode(block, 'outlineWidth', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);
    const _isOutlineSmooth = dfv(generator.valueToCode(block, 'isOutlineSmooth', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Selection.HighlightStyle(${_outlineUnoccludedColor},${_outlineOccludedColor},${_fillUnoccludedColor},${_fillOccludedColor},${_outlineUnoccludedAlpha},${_outlineOccludedAlpha},${_fillUnoccludedAlpha},${_fillOccludedAlpha},${_outlineWidth},${_isOutlineSmooth})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Selection_getListNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.getListNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#6FF9DD');
        this.setTooltip('Gets the names of all current selection lists.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.getListNames');
    }
};
javascript.javascriptGenerator.forBlock['Selection_getListNames'] = (block, generator) => {

return [`Selection.getListNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_removeListFromMap'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.removeListFromMap')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Deletes a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.removeListFromMap');
    }
};
javascript.javascriptGenerator.forBlock['Selection_removeListFromMap'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.removeListFromMap(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_addToSelectedItemsList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.addToSelectedItemsList')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');
        this.appendValueInput('itemType') 
            .setCheck('Selection.ItemType')
            .appendField('itemType');
        this.appendValueInput('itemID') 
            .setCheck('Uuid')
            .appendField('itemID');

        this.setColour('#6FF9DD');
        this.setTooltip('Adds an item to a selection list. The list is created if it doesn\'t exist.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.addToSelectedItemsList');
    }
};
javascript.javascriptGenerator.forBlock['Selection_addToSelectedItemsList'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _itemType = dfv(generator.valueToCode(block, 'itemType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _itemID = dfv(generator.valueToCode(block, 'itemID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.addToSelectedItemsList(${_listName},${_itemType},${_itemID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_removeFromSelectedItemsList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.removeFromSelectedItemsList')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');
        this.appendValueInput('itemType') 
            .setCheck('Selection.ItemType')
            .appendField('itemType');
        this.appendValueInput('itemID') 
            .setCheck('Uuid')
            .appendField('itemID');

        this.setColour('#6FF9DD');
        this.setTooltip('Removes an item from a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.removeFromSelectedItemsList');
    }
};
javascript.javascriptGenerator.forBlock['Selection_removeFromSelectedItemsList'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _itemType = dfv(generator.valueToCode(block, 'itemType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _itemID = dfv(generator.valueToCode(block, 'itemID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.removeFromSelectedItemsList(${_listName},${_itemType},${_itemID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_clearSelectedItemsList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.clearSelectedItemsList')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Removes all items from a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.clearSelectedItemsList');
    }
};
javascript.javascriptGenerator.forBlock['Selection_clearSelectedItemsList'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.clearSelectedItemsList(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_printList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.printList')
        // Returns data

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6FF9DD');
        this.setTooltip('Prints the list of avatars and entities in a selection to the program log (but not the Script Log window).');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.printList');
    }
};
javascript.javascriptGenerator.forBlock['Selection_printList'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Selection.printList(${_listName});\n`;};


// Blockly function
Blockly.Blocks['Selection_getSelectedItemsList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.getSelectedItemsList')
        // Returns data
        this.setOutput(true, '["Selection.SelectedItemsList"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Gets the list of avatars and entities in a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.getSelectedItemsList');
    }
};
javascript.javascriptGenerator.forBlock['Selection_getSelectedItemsList'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.getSelectedItemsList(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_getHighlightedListNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.getHighlightedListNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#6FF9DD');
        this.setTooltip('Gets the names of all current selection lists that have highlighting enabled.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.getHighlightedListNames');
    }
};
javascript.javascriptGenerator.forBlock['Selection_getHighlightedListNames'] = (block, generator) => {

return [`Selection.getHighlightedListNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_enableListHighlight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.enableListHighlight')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');
        this.appendValueInput('highlightStyle') 
            .setCheck('Selection.HighlightStyle')
            .appendField('highlightStyle');

        this.setColour('#6FF9DD');
        this.setTooltip('Enables highlighting for a selection list. All items in or subsequently added to the list are displayed with the highlight effect specified. The method can be called multiple times with different values in the style to modify the highlighting.<p>Note: This function implicitly calls {@link Selection.enableListToScene|enableListToScene}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.enableListHighlight');
    }
};
javascript.javascriptGenerator.forBlock['Selection_enableListHighlight'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _highlightStyle = dfv(generator.valueToCode(block, 'highlightStyle', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.enableListHighlight(${_listName},${_highlightStyle})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_disableListHighlight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.disableListHighlight')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Disables highlighting for a selection list.<p>Note: This function implicitly calls {@link Selection.disableListToScene|disableListToScene}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.disableListHighlight');
    }
};
javascript.javascriptGenerator.forBlock['Selection_disableListHighlight'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.disableListHighlight(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_enableListToScene'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.enableListToScene')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Enables scene selection for a selection list. All items in or subsequently added to the list are sent to a scene selection in the rendering engine for debugging purposes.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.enableListToScene');
    }
};
javascript.javascriptGenerator.forBlock['Selection_enableListToScene'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.enableListToScene(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_disableListToScene'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.disableListToScene')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Disables scene selection for a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.disableListToScene');
    }
};
javascript.javascriptGenerator.forBlock['Selection_disableListToScene'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.disableListToScene(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Selection_getListHighlightStyle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Selection.getListHighlightStyle')
        // Returns data
        this.setOutput(true, '["Selection.HighlightStyle"]');

        // Params data
        this.appendValueInput('listName') 
            .setCheck('String')
            .appendField('listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Gets the current highlighting style for a selection list.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.getListHighlightStyle');
    }
};
javascript.javascriptGenerator.forBlock['Selection_getListHighlightStyle'] = (block, generator) => {
    const _listName = dfv(generator.valueToCode(block, 'listName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Selection.getListHighlightStyle(${_listName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Selection_selectedItemsListChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Selection.selectedItemsListChanged');

        this.appendDummyInput('listName')
            .appendField('listName:')
            .appendField(new Blockly.FieldVariable('selectedItemsListChanged_listName'), 'listName');

        this.setColour('#6FF9DD');
        this.setTooltip('Triggered when a selection list\'s content changes or the list is deleted.');
        this.setHelpUrl('https://apidocs.overte.org/Selection.html#.selectedItemsListChanged');
    }
};
javascript.javascriptGenerator.forBlock['Selection_selectedItemsListChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const listName = generator.getVariableName(block.getFieldValue('listName'));

return `Selection.selectedItemsListChanged.connect((_listName) => { 
  ${listName} = _listName;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['Settings_getValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Settings.getValue')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');
        this.appendValueInput('defaultValue') 
            .setCheck('String')
            .appendField('defaultValue');

        this.setColour('#F4F707');
        this.setTooltip('Retrieves the value from a named setting.');
        this.setHelpUrl('https://apidocs.overte.org/Settings.html#.getValue');
    }
};
javascript.javascriptGenerator.forBlock['Settings_getValue'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultValue = dfv(generator.valueToCode(block, 'defaultValue', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Settings.getValue(${_key},${_defaultValue})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Settings_setValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Settings.setValue')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');
        this.appendValueInput('value') 
            .setCheck('String')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F4F707');
        this.setTooltip('Stores a value in a named setting. If the setting already exists, its value is overwritten. If the value is<code>null</code> or <code>undefined</code>, the setting is deleted.');
        this.setHelpUrl('https://apidocs.overte.org/Settings.html#.setValue');
    }
};
javascript.javascriptGenerator.forBlock['Settings_setValue'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Settings.setValue(${_key},${_value});\n`;};


// Blockly function
Blockly.Blocks['Test_quit'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.quit')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Exits the application');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.quit');
    }
};
javascript.javascriptGenerator.forBlock['Test_quit'] = (block, generator) => {


    return `Test.quit();\n`;};


// Blockly function
Blockly.Blocks['Test_waitForTextureIdle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.waitForTextureIdle')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits for all texture transfers to be complete');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.waitForTextureIdle');
    }
};
javascript.javascriptGenerator.forBlock['Test_waitForTextureIdle'] = (block, generator) => {


    return `Test.waitForTextureIdle();\n`;};


// Blockly function
Blockly.Blocks['Test_waitForDownloadIdle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.waitForDownloadIdle')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits for all pending downloads to be complete');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.waitForDownloadIdle');
    }
};
javascript.javascriptGenerator.forBlock['Test_waitForDownloadIdle'] = (block, generator) => {


    return `Test.waitForDownloadIdle();\n`;};


// Blockly function
Blockly.Blocks['Test_waitForProcessingIdle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.waitForProcessingIdle')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits for all file parsing operations to be complete');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.waitForProcessingIdle');
    }
};
javascript.javascriptGenerator.forBlock['Test_waitForProcessingIdle'] = (block, generator) => {


    return `Test.waitForProcessingIdle();\n`;};


// Blockly function
Blockly.Blocks['Test_waitIdle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.waitIdle')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits for all pending downloads, parsing and texture transfers to be complete');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.waitIdle');
    }
};
javascript.javascriptGenerator.forBlock['Test_waitIdle'] = (block, generator) => {


    return `Test.waitIdle();\n`;};


// Blockly function
Blockly.Blocks['Test_waitForConnection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.waitForConnection')
        // Returns data

        // Params data
        this.appendValueInput('maxWaitMs') 
            .setCheck('Number')
            .appendField('maxWaitMs');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits for establishment of connection to server');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.waitForConnection');
    }
};
javascript.javascriptGenerator.forBlock['Test_waitForConnection'] = (block, generator) => {
    const _maxWaitMs = dfv(generator.valueToCode(block, 'maxWaitMs', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.waitForConnection(${_maxWaitMs});\n`;};


// Blockly function
Blockly.Blocks['Test_wait'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.wait')
        // Returns data

        // Params data
        this.appendValueInput('milliseconds') 
            .setCheck('Number')
            .appendField('milliseconds');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits a specific number of milliseconds');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.wait');
    }
};
javascript.javascriptGenerator.forBlock['Test_wait'] = (block, generator) => {
    const _milliseconds = dfv(generator.valueToCode(block, 'milliseconds', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.wait(${_milliseconds});\n`;};


// Blockly function
Blockly.Blocks['Test_loadTestScene'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.loadTestScene')
        // Returns data

        // Params data
        this.appendValueInput('sceneFile') 
            .setCheck('String')
            .appendField('sceneFile');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Waits for all pending downloads, parsing and texture transfers to be complete');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.loadTestScene');
    }
};
javascript.javascriptGenerator.forBlock['Test_loadTestScene'] = (block, generator) => {
    const _sceneFile = dfv(generator.valueToCode(block, 'sceneFile', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.loadTestScene(${_sceneFile});\n`;};


// Blockly function
Blockly.Blocks['Test_clear'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.clear')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Clears all caches');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.clear');
    }
};
javascript.javascriptGenerator.forBlock['Test_clear'] = (block, generator) => {


    return `Test.clear();\n`;};


// Blockly function
Blockly.Blocks['Test_startTracing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.startTracing')
        // Returns data

        // Params data
        this.appendValueInput('logrules') 
            .setCheck('String')
            .appendField('logrules');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Start recording Chrome compatible tracing eventslogRules can be used to specify a set of logging category rules to limit what gets captured');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.startTracing');
    }
};
javascript.javascriptGenerator.forBlock['Test_startTracing'] = (block, generator) => {
    const _logrules = dfv(generator.valueToCode(block, 'logrules', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.startTracing(${_logrules});\n`;};


// Blockly function
Blockly.Blocks['Test_stopTracing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.stopTracing')
        // Returns data
        this.setOutput(true, '["bool"]');

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setColour('#0CBC66');
        this.setTooltip('Stop recording Chrome compatible tracing events and serialize recorded events to a fileUsing a filename with a .gz extension will automatically compress the output file');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.stopTracing');
    }
};
javascript.javascriptGenerator.forBlock['Test_stopTracing'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Test.stopTracing(${_filename})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Test_startTraceEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.startTraceEvent')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Starts a specific trace event');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.startTraceEvent');
    }
};
javascript.javascriptGenerator.forBlock['Test_startTraceEvent'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.startTraceEvent(${_name});\n`;};


// Blockly function
Blockly.Blocks['Test_endTraceEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.endTraceEvent')
        // Returns data

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Stop a specific name eventUsing a filename with a .gz extension will automatically compress the output file');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.endTraceEvent');
    }
};
javascript.javascriptGenerator.forBlock['Test_endTraceEvent'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.endTraceEvent(${_filename});\n`;};


// Blockly function
Blockly.Blocks['Test_savePhysicsSimulationStats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.savePhysicsSimulationStats')
        // Returns data

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Write detailed timing stats of next physics stepSimulation() to filename');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.savePhysicsSimulationStats');
    }
};
javascript.javascriptGenerator.forBlock['Test_savePhysicsSimulationStats'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.savePhysicsSimulationStats(${_filename});\n`;};


// Blockly function
Blockly.Blocks['Test_savePhysicsSimulationStatsnamefunction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.savePhysicsSimulationStats')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendStatementInput('function')
            .appendField('function');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Profiles a specific function');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.savePhysicsSimulationStats');
    }
};
javascript.javascriptGenerator.forBlock['Test_savePhysicsSimulationStatsnamefunction'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _function = generator.statementToCode(block, 'function');


    return `Test.savePhysicsSimulationStats(${_name},() => { \n ${_function} });\n`;};


// Blockly function
Blockly.Blocks['Test_clearCaches'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.clearCaches')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Clear all caches (menu command Reload Content)');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.clearCaches');
    }
};
javascript.javascriptGenerator.forBlock['Test_clearCaches'] = (block, generator) => {


    return `Test.clearCaches();\n`;};


// Blockly function
Blockly.Blocks['Test_saveObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.saveObject')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Save a JSON object to a file in the test results location');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.saveObject');
    }
};
javascript.javascriptGenerator.forBlock['Test_saveObject'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Test.saveObject(${_name},${_filename});\n`;};


// Blockly function
Blockly.Blocks['Test_showMaximized'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.showMaximized')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Maximizes the window');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.showMaximized');
    }
};
javascript.javascriptGenerator.forBlock['Test_showMaximized'] = (block, generator) => {


    return `Test.showMaximized();\n`;};


// Blockly function
Blockly.Blocks['Test_setOtherAvatarsReplicaCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.setOtherAvatarsReplicaCount')
        // Returns data

        // Params data
        this.appendValueInput('count') 
            .setCheck('Number')
            .appendField('count');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Values higher than 0 will create replicas of other-avatars when entering a domain for testing purpouses');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.setOtherAvatarsReplicaCount');
    }
};
javascript.javascriptGenerator.forBlock['Test_setOtherAvatarsReplicaCount'] = (block, generator) => {
    const _count = dfv(generator.valueToCode(block, 'count', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Test.setOtherAvatarsReplicaCount(${_count});\n`;};


// Blockly function
Blockly.Blocks['Test_getOtherAvatarsReplicaCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.getOtherAvatarsReplicaCount')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#0CBC66');
        this.setTooltip('Return the number of replicas that are being created of other-avatars when entering a domain');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.getOtherAvatarsReplicaCount');
    }
};
javascript.javascriptGenerator.forBlock['Test_getOtherAvatarsReplicaCount'] = (block, generator) => {

return [`Test.getOtherAvatarsReplicaCount()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Test_setMinimumGPUTextureMemStabilityCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.setMinimumGPUTextureMemStabilityCount')
        // Returns data

        // Params data
        this.appendValueInput('count') 
            .setCheck('Number')
            .appendField('count');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0CBC66');
        this.setTooltip('Set number of cycles texture size is required to be stable');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.setMinimumGPUTextureMemStabilityCount');
    }
};
javascript.javascriptGenerator.forBlock['Test_setMinimumGPUTextureMemStabilityCount'] = (block, generator) => {
    const _count = dfv(generator.valueToCode(block, 'count', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Test.setMinimumGPUTextureMemStabilityCount(${_count});\n`;};


// Blockly function
Blockly.Blocks['Test_isTextureLoadingComplete'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Test.isTextureLoadingComplete')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#0CBC66');
        this.setTooltip('Check whether all textures have been loaded.');
        this.setHelpUrl('https://apidocs.overte.org/Test.html#.isTextureLoadingComplete');
    }
};
javascript.javascriptGenerator.forBlock['Test_isTextureLoadingComplete'] = (block, generator) => {

return [`Test.isTextureLoadingComplete()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Window_MessageBoxButton'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.MessageBoxButton')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#C89686');
        this.setTooltip('<p>The buttons that may be included in a message box created by {@link Window.openMessageBox|openMessageBox} are defined bynumeric values:<table>  <thead>    <tr>      <th>Button</th>      <th>Value</th>      <th>Description</th>    </tr>  </thead>  <tbody>    <tr> <td><strong>NoButton</strong></td> <td><code>0x0</code></td> <td>An invalid button.</td> </tr>    <tr> <td><strong>Ok</strong></td> <td><code>0x400</code></td> <td>"OK"</td> </tr>    <tr> <td><strong>Save</strong></td> <td><code>0x800</code></td> <td>"Save"</td> </tr>    <tr> <td><strong>SaveAll</strong></td> <td><code>0x1000</code></td> <td>"Save All"</td> </tr>    <tr> <td><strong>Open</strong></td> <td><code>0x2000</code></td> <td>"Open"</td> </tr>    <tr> <td><strong>Yes</strong></td> <td><code>0x4000</code></td> <td>"Yes"</td> </tr>    <tr> <td><strong>YesToAll</strong></td> <td><code>0x8000</code></td> <td>"Yes to All"</td> </tr>    <tr> <td><strong>No</strong></td> <td><code>0x10000</code></td> <td>"No"</td> </tr>    <tr> <td><strong>NoToAll</strong></td> <td><code>0x20000</code></td> <td>"No to All"</td> </tr>    <tr> <td><strong>Abort</strong></td> <td><code>0x40000</code></td> <td>"Abort"</td> </tr>    <tr> <td><strong>Retry</strong></td> <td><code>0x80000</code></td> <td>"Retry"</td> </tr>    <tr> <td><strong>Ignore</strong></td> <td><code>0x100000</code></td> <td>"Ignore"</td> </tr>    <tr> <td><strong>Close</strong></td> <td><code>0x200000</code></td> <td>"Close"</td> </tr>    <tr> <td><strong>Cancel</strong></td> <td><code>0x400000</code></td> <td>"Cancel"</td> </tr>    <tr> <td><strong>Discard</strong></td> <td><code>0x800000</code></td> <td>"Discard" or "Don\'t Save"</td> </tr>    <tr> <td><strong>Help</strong></td> <td><code>0x1000000</code></td> <td>"Help"</td> </tr>    <tr> <td><strong>Apply</strong></td> <td><code>0x2000000</code></td> <td>"Apply"</td> </tr>    <tr> <td><strong>Reset</strong></td> <td><code>0x4000000</code></td> <td>"Reset"</td> </tr>    <tr> <td><strong>RestoreDefaults</strong></td> <td><code>0x8000000</code></td> <td>"Restore Defaults"</td> </tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.MessageBoxButton');
    }
};
javascript.javascriptGenerator.forBlock['Window_MessageBoxButton'] = (block, generator) => {

    return [`new Window.MessageBoxButton()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Window_innerWidth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.innerWidth')       
        this.setOutput(true, '');
        this.setColour('#C89686');
        this.setTooltip('The width of the drawable area of the Interface window (i.e., without borders or other    chrome), in pixels. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.innerWidth');
    }
};
javascript.javascriptGenerator.forBlock['Window_innerWidth'] = (block, generator) => {
    return [`Window.innerWidth`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Window_innerHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.innerHeight')       
        this.setOutput(true, '');
        this.setColour('#C89686');
        this.setTooltip('The height of the drawable area of the Interface window (i.e., without borders or other    chrome), in pixels. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.innerHeight');
    }
};
javascript.javascriptGenerator.forBlock['Window_innerHeight'] = (block, generator) => {
    return [`Window.innerHeight`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Window_x'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.x')       
        this.setOutput(true, '');
        this.setColour('#C89686');
        this.setTooltip('The x display coordinate of the top left corner of the drawable area of the Interface window.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.x');
    }
};
javascript.javascriptGenerator.forBlock['Window_x'] = (block, generator) => {
    return [`Window.x`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Window_y'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.y')       
        this.setOutput(true, '');
        this.setColour('#C89686');
        this.setTooltip('The y display coordinate of the top left corner of the drawable area of the Interface window.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.y');
    }
};
javascript.javascriptGenerator.forBlock['Window_y'] = (block, generator) => {
    return [`Window.y`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Window_interstitialModeEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.interstitialModeEnabled')       
        this.setOutput(true, '');
        this.setColour('#C89686');
        this.setTooltip('<code>true</code> if the interstitial graphics are displayed when a     domain is loading, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.interstitialModeEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Window_interstitialModeEnabled'] = (block, generator) => {
    return [`Window.interstitialModeEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Window_location'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.location')       
        this.setOutput(true, '');
        this.setColour('#C89686');
        this.setTooltip('Provides facilities for working with your current directory services location.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.location');
    }
};
javascript.javascriptGenerator.forBlock['Window_location'] = (block, generator) => {
    return [`Window.location`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Window_hasFocus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.hasFocus')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Checks whether the Interface window has focus.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.hasFocus');
    }
};
javascript.javascriptGenerator.forBlock['Window_hasFocus'] = (block, generator) => {

return [`Window.hasFocus()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_setFocus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.setFocus')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Makes the Interface window have focus. On Windows, if Interface doesn\'t already have focus, the task bar icon flashes to indicate that Interface wants attention but focus isn\'t taken away from the application that the user is using.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.setFocus');
    }
};
javascript.javascriptGenerator.forBlock['Window_setFocus'] = (block, generator) => {


    return `Window.setFocus();\n`;};


// Blockly function
Blockly.Blocks['Window_raise'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.raise')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Raises the Interface window if it is minimized. If raised, the window gains focus.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.raise');
    }
};
javascript.javascriptGenerator.forBlock['Window_raise'] = (block, generator) => {


    return `Window.raise();\n`;};


// Blockly function
Blockly.Blocks['Window_alert'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.alert')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Displays a dialog with the specified message and an "OK" button. The dialog is non-modal; the script continues withoutwaiting for a user response.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.alert');
    }
};
javascript.javascriptGenerator.forBlock['Window_alert'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.alert(${_message});\n`;};


// Blockly function
Blockly.Blocks['Window_confirm'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.confirm')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setColour('#C89686');
        this.setTooltip('Prompts the user to confirm something. Displays a modal dialog with a message plus "Yes" and "No" buttons.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.confirm');
    }
};
javascript.javascriptGenerator.forBlock['Window_confirm'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Window.confirm(${_message})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_prompt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.prompt')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');
        this.appendValueInput('defaultText') 
            .setCheck('String')
            .appendField('defaultText');

        this.setColour('#C89686');
        this.setTooltip('Prompts the user to enter some text. Displays a modal dialog with a message and a text box, plus "OK" and "Cancel" buttons.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.prompt');
    }
};
javascript.javascriptGenerator.forBlock['Window_prompt'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultText = dfv(generator.valueToCode(block, 'defaultText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Window.prompt(${_message},${_defaultText})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_promptAsync'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.promptAsync')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');
        this.appendValueInput('defaultText') 
            .setCheck('String')
            .appendField('defaultText');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Prompts the user to enter some text. Displays a non-modal dialog with a message and a text box, plus "OK" and "Cancel" buttons. A {@link Window.promptTextChanged|promptTextChanged} signal is emitted when the user OKs the dialog; no signal is emitted if the user cancels the dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.promptAsync');
    }
};
javascript.javascriptGenerator.forBlock['Window_promptAsync'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _defaultText = dfv(generator.valueToCode(block, 'defaultText', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.promptAsync(${_message},${_defaultText});\n`;};


// Blockly function
Blockly.Blocks['Window_browseDir'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.browseDir')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');

        this.setColour('#C89686');
        this.setTooltip('Prompts the user to choose a directory. Displays a modal dialog that navigates the directory tree.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseDir');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseDir'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Window.browseDir(${_title},${_directory})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_browseDirAsync'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.browseDirAsync')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Prompts the user to choose a directory. Displays a non-modal dialog that navigates the directory tree. A{@link Window.browseDirChanged|browseDirChanged} signal is emitted when a directory is chosen; no signal is emitted ifthe user cancels the dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseDirAsync');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseDirAsync'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.browseDirAsync(${_title},${_directory});\n`;};


// Blockly function
Blockly.Blocks['Window_browse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.browse')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');
        this.appendValueInput('nameFilter') 
            .setCheck('String')
            .appendField('nameFilter');

        this.setColour('#C89686');
        this.setTooltip('Prompts the user to choose a file. Displays a modal dialog that navigates the directory tree.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browse');
    }
};
javascript.javascriptGenerator.forBlock['Window_browse'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _nameFilter = dfv(generator.valueToCode(block, 'nameFilter', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Window.browse(${_title},${_directory},${_nameFilter})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_browseAsync'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.browseAsync')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');
        this.appendValueInput('nameFilter') 
            .setCheck('String')
            .appendField('nameFilter');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Prompts the user to choose a file. Displays a non-modal dialog that navigates the directory tree. A{@link Window.browseChanged|browseChanged} signal is emitted when a file is chosen; no signal is emitted if the usercancels the dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseAsync');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseAsync'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _nameFilter = dfv(generator.valueToCode(block, 'nameFilter', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.browseAsync(${_title},${_directory},${_nameFilter});\n`;};


// Blockly function
Blockly.Blocks['Window_save'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.save')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');
        this.appendValueInput('nameFilter') 
            .setCheck('String')
            .appendField('nameFilter');

        this.setColour('#C89686');
        this.setTooltip('Prompts the user to specify the path and name of a file to save to. Displays a modal dialog that navigates the directorytree and allows the user to type in a file name.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.save');
    }
};
javascript.javascriptGenerator.forBlock['Window_save'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _nameFilter = dfv(generator.valueToCode(block, 'nameFilter', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Window.save(${_title},${_directory},${_nameFilter})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_saveAsync'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.saveAsync')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');
        this.appendValueInput('nameFilter') 
            .setCheck('String')
            .appendField('nameFilter');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Prompts the user to specify the path and name of a file to save to. Displays a non-modal dialog that navigates thedirectory tree and allows the user to type in a file name. A {@link Window.saveFileChanged|saveFileChanged} signal isemitted when a file is specified; no signal is emitted if the user cancels the dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.saveAsync');
    }
};
javascript.javascriptGenerator.forBlock['Window_saveAsync'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _nameFilter = dfv(generator.valueToCode(block, 'nameFilter', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.saveAsync(${_title},${_directory},${_nameFilter});\n`;};


// Blockly function
Blockly.Blocks['Window_browseAssets'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.browseAssets')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');
        this.appendValueInput('nameFilter') 
            .setCheck('String')
            .appendField('nameFilter');

        this.setColour('#C89686');
        this.setTooltip('Prompts the user to choose an Asset Server item. Displays a modal dialog that navigates the tree of assets on the AssetServer.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseAssets');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseAssets'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _nameFilter = dfv(generator.valueToCode(block, 'nameFilter', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Window.browseAssets(${_title},${_directory},${_nameFilter})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_browseAssetsAsync'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.browseAssetsAsync')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('directory') 
            .setCheck('String')
            .appendField('directory');
        this.appendValueInput('nameFilter') 
            .setCheck('String')
            .appendField('nameFilter');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Prompts the user to choose an Asset Server item. Displays a non-modal dialog that navigates the tree of assets on the Asset Server. An {@link Window.assetsDirChanged|assetsDirChanged} signal is emitted when an asset is chosen; no signal isemitted if the user cancels the dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseAssetsAsync');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseAssetsAsync'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _directory = dfv(generator.valueToCode(block, 'directory', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _nameFilter = dfv(generator.valueToCode(block, 'nameFilter', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.browseAssetsAsync(${_title},${_directory},${_nameFilter});\n`;};


// Blockly function
Blockly.Blocks['Window_showAssetServer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.showAssetServer')
        // Returns data

        // Params data
        this.appendValueInput('uploadFile') 
            .setCheck('String')
            .appendField('uploadFile');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Opens the Asset Browser dialog. If a file to upload is specified, the user is prompted to enter the folder and name tomap the file to on the asset server.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.showAssetServer');
    }
};
javascript.javascriptGenerator.forBlock['Window_showAssetServer'] = (block, generator) => {
    const _uploadFile = dfv(generator.valueToCode(block, 'uploadFile', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.showAssetServer(${_uploadFile});\n`;};


// Blockly function
Blockly.Blocks['Window_checkVersion'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.checkVersion')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets Interface\'s build number.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.checkVersion');
    }
};
javascript.javascriptGenerator.forBlock['Window_checkVersion'] = (block, generator) => {

return [`Window.checkVersion()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_getUserAgent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.getUserAgent')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets Interface\'s user agent.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.getUserAgent');
    }
};
javascript.javascriptGenerator.forBlock['Window_getUserAgent'] = (block, generator) => {

return [`Window.getUserAgent()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_protocolSignature'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.protocolSignature')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets the signature for Interface\'s protocol version.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.protocolSignature');
    }
};
javascript.javascriptGenerator.forBlock['Window_protocolSignature'] = (block, generator) => {

return [`Window.protocolSignature()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_copyToClipboard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.copyToClipboard')
        // Returns data

        // Params data
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Copies text to the operating system\'s clipboard.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.copyToClipboard');
    }
};
javascript.javascriptGenerator.forBlock['Window_copyToClipboard'] = (block, generator) => {
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Window.copyToClipboard(${_text});\n`;};


// Blockly function
Blockly.Blocks['Window_takeSnapshot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.takeSnapshot')
        // Returns data

        // Params data
        this.appendValueInput('notify') 
            .setCheck('Boolean')
            .appendField('notify');
        this.appendValueInput('includeAnimated') 
            .setCheck('Boolean')
            .appendField('includeAnimated');
        this.appendValueInput('aspectRatio') 
            .setCheck('Number')
            .appendField('aspectRatio');
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Takes a snapshot of the current Interface view from the primary camera. When a still image only is captured, {@link Window.stillSnapshotTaken|stillSnapshotTaken} is emitted; when a still image plus moving images are captured, {@link Window.processingGifStarted|processingGifStarted} and {@link Window.processingGifCompleted|processingGifCompleted}are emitted.<p>Snapshots are saved to the path specified in Settings &gt; General &gt; Snapshots, which can be accessed via the {@link Snapshot} API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.takeSnapshot');
    }
};
javascript.javascriptGenerator.forBlock['Window_takeSnapshot'] = (block, generator) => {
    const _notify = dfv(generator.valueToCode(block, 'notify', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _includeAnimated = dfv(generator.valueToCode(block, 'includeAnimated', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _aspectRatio = dfv(generator.valueToCode(block, 'aspectRatio', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.takeSnapshot(${_notify},${_includeAnimated},${_aspectRatio},${_filename});\n`;};


// Blockly function
Blockly.Blocks['Window_takeSecondaryCameraSnapshot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.takeSecondaryCameraSnapshot')
        // Returns data

        // Params data
        this.appendValueInput('notify') 
            .setCheck('Boolean')
            .appendField('notify');
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Takes a still snapshot of the current view from the secondary camera that can be set up through the {@link Render} API.<p>Snapshots are saved to the path specified in Settings &gt; General &gt; Snapshots, which can be accessed via the{@link Snapshot} API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.takeSecondaryCameraSnapshot');
    }
};
javascript.javascriptGenerator.forBlock['Window_takeSecondaryCameraSnapshot'] = (block, generator) => {
    const _notify = dfv(generator.valueToCode(block, 'notify', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.takeSecondaryCameraSnapshot(${_notify},${_filename});\n`;};


// Blockly function
Blockly.Blocks['Window_takeSecondaryCamera360Snapshot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.takeSecondaryCamera360Snapshot')
        // Returns data

        // Params data
        this.appendValueInput('cameraPosition') 
            .setCheck('Vec3')
            .appendField('cameraPosition');
        this.appendValueInput('cubemapOutputFormat') 
            .setCheck('Boolean')
            .appendField('cubemapOutputFormat');
        this.appendValueInput('notify') 
            .setCheck('Boolean')
            .appendField('notify');
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Takes a 360&deg; snapshot at a given position for the secondary camera. The secondary camera does not need to have been     set up.<p>Snapshots are saved to the path specified in Settings &gt; General &gt; Snapshots, which can be accessed via the{@link Snapshot} API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.takeSecondaryCamera360Snapshot');
    }
};
javascript.javascriptGenerator.forBlock['Window_takeSecondaryCamera360Snapshot'] = (block, generator) => {
    const _cameraPosition = dfv(generator.valueToCode(block, 'cameraPosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _cubemapOutputFormat = dfv(generator.valueToCode(block, 'cubemapOutputFormat', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _notify = dfv(generator.valueToCode(block, 'notify', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.takeSecondaryCamera360Snapshot(${_cameraPosition},${_cubemapOutputFormat},${_notify},${_filename});\n`;};


// Blockly function
Blockly.Blocks['Window_makeConnection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.makeConnection')
        // Returns data

        // Params data
        this.appendValueInput('success') 
            .setCheck('Boolean')
            .appendField('success');
        this.appendValueInput('description') 
            .setCheck('String')
            .appendField('description');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Emits a {@link Window.connectionAdded|connectionAdded} or a {@link Window.connectionError|connectionError} signal thatindicates whether or not a user connection was successfully made using the Web API.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.makeConnection');
    }
};
javascript.javascriptGenerator.forBlock['Window_makeConnection'] = (block, generator) => {
    const _success = dfv(generator.valueToCode(block, 'success', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _description = dfv(generator.valueToCode(block, 'description', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Window.makeConnection(${_success},${_description});\n`;};


// Blockly function
Blockly.Blocks['Window_displayAnnouncement'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.displayAnnouncement')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Displays a notification message. Notifications are displayed in panels by the default script, nofications.js. An{@link Window.announcement|announcement} signal is emitted when this function is called.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.displayAnnouncement');
    }
};
javascript.javascriptGenerator.forBlock['Window_displayAnnouncement'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Window.displayAnnouncement(${_message});\n`;};


// Blockly function
Blockly.Blocks['Window_shareSnapshot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.shareSnapshot')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('href') 
            .setCheck('String')
            .appendField('href');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Prepares a snapshot ready for sharing. A {@link Window.snapshotShared|snapshotShared} signal is emitted when the snapshothas been prepared.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.shareSnapshot');
    }
};
javascript.javascriptGenerator.forBlock['Window_shareSnapshot'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _href = dfv(generator.valueToCode(block, 'href', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.shareSnapshot(${_path},${_href});\n`;};


// Blockly function
Blockly.Blocks['Window_isPhysicsEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.isPhysicsEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Checks to see if physics is active for you in the domain you\'re visiting - there is a delay between your arrival at adomain and physics becoming active for you in that domain.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.isPhysicsEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Window_isPhysicsEnabled'] = (block, generator) => {

return [`Window.isPhysicsEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_setDisplayTexture'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.setDisplayTexture')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('texture') 
            .setCheck('Window.DisplayTexture')
            .appendField('texture');

        this.setColour('#C89686');
        this.setTooltip('Sets what to show on the PC display. For entity camera view, the entity camera is configured using {@link Camera.setCameraEntity} and {@link Camera|Camera.mode}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.setDisplayTexture');
    }
};
javascript.javascriptGenerator.forBlock['Window_setDisplayTexture'] = (block, generator) => {
    const _texture = dfv(generator.valueToCode(block, 'texture', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Window.setDisplayTexture(${_texture})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_isPointOnDesktopWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.isPointOnDesktopWindow')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('point') 
            .setCheck('Vec2')
            .appendField('point');

        this.setColour('#C89686');
        this.setTooltip('Checks if a 2D point is within the desktop window if in desktop mode, or the drawable area of the HUD overlay if in HMDmode.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.isPointOnDesktopWindow');
    }
};
javascript.javascriptGenerator.forBlock['Window_isPointOnDesktopWindow'] = (block, generator) => {
    const _point = dfv(generator.valueToCode(block, 'point', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Window.isPointOnDesktopWindow(${_point})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_getDeviceSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.getDeviceSize')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets the size of the drawable area of the Interface window if in desktop mode or the HMD rendering surface if in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.getDeviceSize');
    }
};
javascript.javascriptGenerator.forBlock['Window_getDeviceSize'] = (block, generator) => {

return [`Window.getDeviceSize()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_getLastDomainConnectionError'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.getLastDomainConnectionError')
        // Returns data
        this.setOutput(true, '["Window.ConnectionRefusedReason"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets the last domain connection error when a connection is refused.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.getLastDomainConnectionError');
    }
};
javascript.javascriptGenerator.forBlock['Window_getLastDomainConnectionError'] = (block, generator) => {

return [`Window.getLastDomainConnectionError()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_openMessageBox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.openMessageBox')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');
        this.appendValueInput('buttons') 
            .setCheck('Window.MessageBoxButton')
            .appendField('buttons');
        this.appendValueInput('defaultButton') 
            .setCheck('Window.MessageBoxButton')
            .appendField('defaultButton');

        this.setColour('#C89686');
        this.setTooltip('Opens a non-modal message box that can have a variety of button combinations. See also, {@link Window.updateMessageBox|updateMessageBox} and {@link Window.closeMessageBox|closeMessageBox}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.openMessageBox');
    }
};
javascript.javascriptGenerator.forBlock['Window_openMessageBox'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _buttons = dfv(generator.valueToCode(block, 'buttons', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultButton = dfv(generator.valueToCode(block, 'defaultButton', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Window.openMessageBox(${_title},${_text},${_buttons},${_defaultButton})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_openUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.openUrl')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Opens a URL in the Interface window or other application, depending on the URL\'s scheme. The following schemes are supported:<ul>  <li><code>hifi</code>: Navigate to the URL in Interface.</li>  <li><code>hifiapp</code>: Open a system app in Interface.</li></ul><p>Other schemes will either be handled by the OS (e.g. <code>http</code>, <code>https</code>, or <code>mailto</code>) or will display a dialog asking the user to confirm that they want to try to open the URL.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.openUrl');
    }
};
javascript.javascriptGenerator.forBlock['Window_openUrl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Window.openUrl(${_url});\n`;};


// Blockly function
Blockly.Blocks['Window_openAndroidActivity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.openAndroidActivity')
        // Returns data

        // Params data
        this.appendValueInput('activityName') 
            .setCheck('String')
            .appendField('activityName');
        this.appendValueInput('backToScene') 
            .setCheck('Boolean')
            .appendField('backToScene');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Opens an Android activity and optionally return back to the scene when the activity is completed. <em>Android only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.openAndroidActivity');
    }
};
javascript.javascriptGenerator.forBlock['Window_openAndroidActivity'] = (block, generator) => {
    const _activityName = dfv(generator.valueToCode(block, 'activityName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _backToScene = dfv(generator.valueToCode(block, 'backToScene', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Window.openAndroidActivity(${_activityName},${_backToScene});\n`;};


// Blockly function
Blockly.Blocks['Window_updateMessageBox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.updateMessageBox')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');
        this.appendValueInput('buttons') 
            .setCheck('Window.MessageBoxButton')
            .appendField('buttons');
        this.appendValueInput('defaultButton') 
            .setCheck('Window.MessageBoxButton')
            .appendField('defaultButton');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Updates the content of a message box that was opened with {@link Window.openMessageBox|openMessageBox}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.updateMessageBox');
    }
};
javascript.javascriptGenerator.forBlock['Window_updateMessageBox'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _buttons = dfv(generator.valueToCode(block, 'buttons', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultButton = dfv(generator.valueToCode(block, 'defaultButton', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Window.updateMessageBox(${_id},${_title},${_text},${_buttons},${_defaultButton});\n`;};


// Blockly function
Blockly.Blocks['Window_closeMessageBox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.closeMessageBox')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Closes a message box that was opened with {@link Window.openMessageBox|openMessageBox}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.closeMessageBox');
    }
};
javascript.javascriptGenerator.forBlock['Window_closeMessageBox'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Window.closeMessageBox(${_id});\n`;};


// Blockly function
Blockly.Blocks['Window_getDisplayPluginCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.getDisplayPluginCount')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets the number of display plugins currently available.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.getDisplayPluginCount');
    }
};
javascript.javascriptGenerator.forBlock['Window_getDisplayPluginCount'] = (block, generator) => {

return [`Window.getDisplayPluginCount()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_getDisplayPluginName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.getDisplayPluginName')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#C89686');
        this.setTooltip('Gets the name of a display plugin.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.getDisplayPluginName');
    }
};
javascript.javascriptGenerator.forBlock['Window_getDisplayPluginName'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Window.getDisplayPluginName(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_isDisplayPluginHmd'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.isDisplayPluginHmd')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#C89686');
        this.setTooltip('Checks whether a display plugin is an HMD.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.isDisplayPluginHmd');
    }
};
javascript.javascriptGenerator.forBlock['Window_isDisplayPluginHmd'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Window.isDisplayPluginHmd(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_getActiveDisplayPlugin'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.getActiveDisplayPlugin')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#C89686');
        this.setTooltip('Gets the index of the currently active display plugin.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.getActiveDisplayPlugin');
    }
};
javascript.javascriptGenerator.forBlock['Window_getActiveDisplayPlugin'] = (block, generator) => {

return [`Window.getActiveDisplayPlugin()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Window_setActiveDisplayPlugin'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.setActiveDisplayPlugin')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Sets the currently active display plugin.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.setActiveDisplayPlugin');
    }
};
javascript.javascriptGenerator.forBlock['Window_setActiveDisplayPlugin'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Window.setActiveDisplayPlugin(${_index});\n`;};


// Blockly function
Blockly.Blocks['Window_openWebBrowser'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.openWebBrowser')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C89686');
        this.setTooltip('Opens an Interface web browser window.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.openWebBrowser');
    }
};
javascript.javascriptGenerator.forBlock['Window_openWebBrowser'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `Window.openWebBrowser(${_url});\n`;};


// Blockly signal
Blockly.Blocks['Window_domainChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.domainChanged');

        this.appendDummyInput('domainURL')
            .appendField('domainURL:')
            .appendField(new Blockly.FieldVariable('domainChanged_domainURL'), 'domainURL');

        this.setColour('#C89686');
        this.setTooltip('Triggered when you change the domain you\'re visiting.<p><strong>Warning:</strong> Is not emitted if you go to a domain that isn\'t running.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.domainChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_domainChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const domainURL = generator.getVariableName(block.getFieldValue('domainURL'));

return `Window.domainChanged.connect((_domainURL) => { 
  ${domainURL} = _domainURL;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_svoImportRequested'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.svoImportRequested');

        this.appendDummyInput('url')
            .appendField('url:')
            .appendField(new Blockly.FieldVariable('svoImportRequested_url'), 'url');

        this.setColour('#C89686');
        this.setTooltip('Triggered when you try to navigate to a *.json, *.svo, or *.svo.json URL in a Web browser within Interface.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.svoImportRequested');
    }
};
javascript.javascriptGenerator.forBlock['Window_svoImportRequested'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const url = generator.getVariableName(block.getFieldValue('url'));

return `Window.svoImportRequested.connect((_url) => { 
  ${url} = _url;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_domainConnectionRefused'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.domainConnectionRefused');

        this.appendDummyInput('reasonMessage')
            .appendField('reasonMessage:')
            .appendField(new Blockly.FieldVariable('domainConnectionRefused_reasonMessage'), 'reasonMessage');
        this.appendDummyInput('reasonCode')
            .appendField('reasonCode:')
            .appendField(new Blockly.FieldVariable('domainConnectionRefused_reasonCode'), 'reasonCode');
        this.appendDummyInput('extraInfo')
            .appendField('extraInfo:')
            .appendField(new Blockly.FieldVariable('domainConnectionRefused_extraInfo'), 'extraInfo');

        this.setColour('#C89686');
        this.setTooltip('Triggered when you try to visit a domain but are refused connection.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.domainConnectionRefused');
    }
};
javascript.javascriptGenerator.forBlock['Window_domainConnectionRefused'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const reasonMessage = generator.getVariableName(block.getFieldValue('reasonMessage'));
    const reasonCode = generator.getVariableName(block.getFieldValue('reasonCode'));
    const extraInfo = generator.getVariableName(block.getFieldValue('extraInfo'));

return `Window.domainConnectionRefused.connect((_reasonMessage,_reasonCode,_extraInfo) => { 
  ${reasonMessage} = _reasonMessage; 
  ${reasonCode} = _reasonCode; 
  ${extraInfo} = _extraInfo;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_redirectErrorStateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.redirectErrorStateChanged');

        this.appendDummyInput('isInErrorState')
            .appendField('isInErrorState:')
            .appendField(new Blockly.FieldVariable('redirectErrorStateChanged_isInErrorState'), 'isInErrorState');

        this.setColour('#C89686');
        this.setTooltip('Triggered when you try to visit a domain but are redirected into the error state.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.redirectErrorStateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_redirectErrorStateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isInErrorState = generator.getVariableName(block.getFieldValue('isInErrorState'));

return `Window.redirectErrorStateChanged.connect((_isInErrorState) => { 
  ${isInErrorState} = _isInErrorState;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_interstitialModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.interstitialModeChanged');

        this.appendDummyInput('interstitialMode')
            .appendField('interstitialMode:')
            .appendField(new Blockly.FieldVariable('interstitialModeChanged_interstitialMode'), 'interstitialMode');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the interstitial mode changes.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.interstitialModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_interstitialModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const interstitialMode = generator.getVariableName(block.getFieldValue('interstitialMode'));

return `Window.interstitialModeChanged.connect((_interstitialMode) => { 
  ${interstitialMode} = _interstitialMode;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_stillSnapshotTaken'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.stillSnapshotTaken');

        this.appendDummyInput('pathStillSnapshot')
            .appendField('pathStillSnapshot:')
            .appendField(new Blockly.FieldVariable('stillSnapshotTaken_pathStillSnapshot'), 'pathStillSnapshot');
        this.appendDummyInput('notify')
            .appendField('notify:')
            .appendField(new Blockly.FieldVariable('stillSnapshotTaken_notify'), 'notify');

        this.setColour('#C89686');
        this.setTooltip('Triggered when a still snapshot has been taken by calling {@link Window.takeSnapshot|takeSnapshot} with     <code>includeAnimated = false</code> or {@link Window.takeSecondaryCameraSnapshot|takeSecondaryCameraSnapshot}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.stillSnapshotTaken');
    }
};
javascript.javascriptGenerator.forBlock['Window_stillSnapshotTaken'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const pathStillSnapshot = generator.getVariableName(block.getFieldValue('pathStillSnapshot'));
    const notify = generator.getVariableName(block.getFieldValue('notify'));

return `Window.stillSnapshotTaken.connect((_pathStillSnapshot,_notify) => { 
  ${pathStillSnapshot} = _pathStillSnapshot; 
  ${notify} = _notify;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_snapshot360Taken'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.snapshot360Taken');

        this.appendDummyInput('pathStillSnapshot')
            .appendField('pathStillSnapshot:')
            .appendField(new Blockly.FieldVariable('snapshot360Taken_pathStillSnapshot'), 'pathStillSnapshot');
        this.appendDummyInput('notify')
            .appendField('notify:')
            .appendField(new Blockly.FieldVariable('snapshot360Taken_notify'), 'notify');

        this.setColour('#C89686');
        this.setTooltip('Triggered when a still 360&deg; snapshot has been taken by calling     {@link Window.takeSecondaryCamera360Snapshot|takeSecondaryCamera360Snapshot}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.snapshot360Taken');
    }
};
javascript.javascriptGenerator.forBlock['Window_snapshot360Taken'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const pathStillSnapshot = generator.getVariableName(block.getFieldValue('pathStillSnapshot'));
    const notify = generator.getVariableName(block.getFieldValue('notify'));

return `Window.snapshot360Taken.connect((_pathStillSnapshot,_notify) => { 
  ${pathStillSnapshot} = _pathStillSnapshot; 
  ${notify} = _notify;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_snapshotShared'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.snapshotShared');

        this.appendDummyInput('isError')
            .appendField('isError:')
            .appendField(new Blockly.FieldVariable('snapshotShared_isError'), 'isError');
        this.appendDummyInput('reply')
            .appendField('reply:')
            .appendField(new Blockly.FieldVariable('snapshotShared_reply'), 'reply');

        this.setColour('#C89686');
        this.setTooltip('Triggered when a snapshot submitted via {@link Window.shareSnapshot|shareSnapshot} is ready for sharing. The snapshotmay then be shared via the {@link Account.metaverseServerURL} Web API.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.snapshotShared');
    }
};
javascript.javascriptGenerator.forBlock['Window_snapshotShared'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isError = generator.getVariableName(block.getFieldValue('isError'));
    const reply = generator.getVariableName(block.getFieldValue('reply'));

return `Window.snapshotShared.connect((_isError,_reply) => { 
  ${isError} = _isError; 
  ${reply} = _reply;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_processingGifStarted'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.processingGifStarted');

        this.appendDummyInput('pathStillSnapshot')
            .appendField('pathStillSnapshot:')
            .appendField(new Blockly.FieldVariable('processingGifStarted_pathStillSnapshot'), 'pathStillSnapshot');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the snapshot images have been captured by {@link Window.takeSnapshot|takeSnapshot} and the GIF is    starting to be processed.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.processingGifStarted');
    }
};
javascript.javascriptGenerator.forBlock['Window_processingGifStarted'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const pathStillSnapshot = generator.getVariableName(block.getFieldValue('pathStillSnapshot'));

return `Window.processingGifStarted.connect((_pathStillSnapshot) => { 
  ${pathStillSnapshot} = _pathStillSnapshot;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_processingGifCompleted'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.processingGifCompleted');

        this.appendDummyInput('pathAnimatedSnapshot')
            .appendField('pathAnimatedSnapshot:')
            .appendField(new Blockly.FieldVariable('processingGifCompleted_pathAnimatedSnapshot'), 'pathAnimatedSnapshot');

        this.setColour('#C89686');
        this.setTooltip('Triggered when a GIF has been prepared of the snapshot images captured by {@link Window.takeSnapshot|takeSnapshot}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.processingGifCompleted');
    }
};
javascript.javascriptGenerator.forBlock['Window_processingGifCompleted'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const pathAnimatedSnapshot = generator.getVariableName(block.getFieldValue('pathAnimatedSnapshot'));

return `Window.processingGifCompleted.connect((_pathAnimatedSnapshot) => { 
  ${pathAnimatedSnapshot} = _pathAnimatedSnapshot;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_connectionAdded'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.connectionAdded');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('connectionAdded_message'), 'message');

        this.setColour('#C89686');
        this.setTooltip('Triggered when you\'ve successfully made a user connection.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.connectionAdded');
    }
};
javascript.javascriptGenerator.forBlock['Window_connectionAdded'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `Window.connectionAdded.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_connectionError'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.connectionError');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('connectionError_message'), 'message');

        this.setColour('#C89686');
        this.setTooltip('Triggered when you failed to make a user connection.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.connectionError');
    }
};
javascript.javascriptGenerator.forBlock['Window_connectionError'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `Window.connectionError.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_announcement'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.announcement');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('announcement_message'), 'message');

        this.setColour('#C89686');
        this.setTooltip('Triggered when a message is announced by {@link Window.displayAnnouncement|displayAnnouncement}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.announcement');
    }
};
javascript.javascriptGenerator.forBlock['Window_announcement'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `Window.announcement.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_messageBoxClosed'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.messageBoxClosed');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('messageBoxClosed_id'), 'id');
        this.appendDummyInput('button')
            .appendField('button:')
            .appendField(new Blockly.FieldVariable('messageBoxClosed_button'), 'button');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the user closes a message box that was opened with {@link Window.openMessageBox|openMessageBox}.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.messageBoxClosed');
    }
};
javascript.javascriptGenerator.forBlock['Window_messageBoxClosed'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const button = generator.getVariableName(block.getFieldValue('button'));

return `Window.messageBoxClosed.connect((_id,_button) => { 
  ${id} = _id; 
  ${button} = _button;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_browseDirChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.browseDirChanged');

        this.appendDummyInput('directory')
            .appendField('directory:')
            .appendField(new Blockly.FieldVariable('browseDirChanged_directory'), 'directory');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the user chooses a directory in a {@link Window.browseDirAsync|browseDirAsync} dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseDirChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseDirChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const directory = generator.getVariableName(block.getFieldValue('directory'));

return `Window.browseDirChanged.connect((_directory) => { 
  ${directory} = _directory;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_assetsDirChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.assetsDirChanged');

        this.appendDummyInput('asset')
            .appendField('asset:')
            .appendField(new Blockly.FieldVariable('assetsDirChanged_asset'), 'asset');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the user chooses an asset in a {@link Window.browseAssetsAsync|browseAssetsAsync} dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.assetsDirChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_assetsDirChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const asset = generator.getVariableName(block.getFieldValue('asset'));

return `Window.assetsDirChanged.connect((_asset) => { 
  ${asset} = _asset;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_saveFileChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.saveFileChanged');

        this.appendDummyInput('filename')
            .appendField('filename:')
            .appendField(new Blockly.FieldVariable('saveFileChanged_filename'), 'filename');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the user specifies a file in a {@link Window.saveAsync|saveAsync} dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.saveFileChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_saveFileChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const filename = generator.getVariableName(block.getFieldValue('filename'));

return `Window.saveFileChanged.connect((_filename) => { 
  ${filename} = _filename;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_browseChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.browseChanged');

        this.appendDummyInput('filename')
            .appendField('filename:')
            .appendField(new Blockly.FieldVariable('browseChanged_filename'), 'filename');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the user chooses a file in a {@link Window.browseAsync|browseAsync} dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.browseChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_browseChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const filename = generator.getVariableName(block.getFieldValue('filename'));

return `Window.browseChanged.connect((_filename) => { 
  ${filename} = _filename;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_promptTextChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.promptTextChanged');

        this.appendDummyInput('text')
            .appendField('text:')
            .appendField(new Blockly.FieldVariable('promptTextChanged_text'), 'text');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the user OKs a {@link Window.promptAsync|promptAsync} dialog.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.promptTextChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_promptTextChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const text = generator.getVariableName(block.getFieldValue('text'));

return `Window.promptTextChanged.connect((_text) => { 
  ${text} = _text;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_geometryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.geometryChanged');

        this.appendDummyInput('geometry')
            .appendField('geometry:')
            .appendField(new Blockly.FieldVariable('geometryChanged_geometry'), 'geometry');

        this.setColour('#C89686');
        this.setTooltip('Triggered when the position or size of the Interface window changes.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.geometryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_geometryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const geometry = generator.getVariableName(block.getFieldValue('geometry'));

return `Window.geometryChanged.connect((_geometry) => { 
  ${geometry} = _geometry;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Window_minimizedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Window.minimizedChanged');

        this.appendDummyInput('isMinimized')
            .appendField('isMinimized:')
            .appendField(new Blockly.FieldVariable('minimizedChanged_isMinimized'), 'isMinimized');

        this.setColour('#C89686');
        this.setTooltip('Triggered when "minimized" state of the Interface window changes.');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.minimizedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Window_minimizedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isMinimized = generator.getVariableName(block.getFieldValue('isMinimized'));

return `Window.minimizedChanged.connect((_isMinimized) => { 
  ${isMinimized} = _isMinimized;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['AvatarInputs_cameraEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.cameraEnabled')       
        this.setOutput(true, '');
        this.setColour('#D8B6C4');
        this.setTooltip('<code>true</code> if webcam face tracking is enabled, <code>false</code> if it is     disabled.    <em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and has been removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.cameraEnabled');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_cameraEnabled'] = (block, generator) => {
    return [`AvatarInputs.cameraEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AvatarInputs_cameraMuted'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.cameraMuted')       
        this.setOutput(true, '');
        this.setColour('#D8B6C4');
        this.setTooltip('<code>true</code> if webcam face tracking is muted (temporarily disabled),     <code>false</code> it if isn\'t.    <em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and has been removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.cameraMuted');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_cameraMuted'] = (block, generator) => {
    return [`AvatarInputs.cameraMuted`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AvatarInputs_ignoreRadiusEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.ignoreRadiusEnabled')       
        this.setOutput(true, '');
        this.setColour('#D8B6C4');
        this.setTooltip('<code>true</code> if the privacy shield is enabled, <code>false</code> if it    is disabled.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.ignoreRadiusEnabled');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_ignoreRadiusEnabled'] = (block, generator) => {
    return [`AvatarInputs.ignoreRadiusEnabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AvatarInputs_isHMD'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.isHMD')       
        this.setOutput(true, '');
        this.setColour('#D8B6C4');
        this.setTooltip('<code>true</code> if the display mode is HMD, <code>false</code> if it isn\'t.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.isHMD');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_isHMD'] = (block, generator) => {
    return [`AvatarInputs.isHMD`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AvatarInputs_showAudioTools'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.showAudioTools')       
        this.setOutput(true, '');
        this.setColour('#D8B6C4');
        this.setTooltip('<code>true</code> if the microphone mute button and audio level meter are shown,     <code>false</code> if they are hidden.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.showAudioTools');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_showAudioTools'] = (block, generator) => {
    return [`AvatarInputs.showAudioTools`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AvatarInputs_showBubbleTools'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.showBubbleTools')       
        this.setOutput(true, '');
        this.setColour('#D8B6C4');
        this.setTooltip('<code>true</code> if the privacy shield UI button is shown, <code>false</code> if     it is hidden.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.showBubbleTools');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_showBubbleTools'] = (block, generator) => {
    return [`AvatarInputs.showBubbleTools`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['AvatarInputs_loudnessToAudioLevel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.loudnessToAudioLevel')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('loudness') 
            .setCheck('Number')
            .appendField('loudness');

        this.setColour('#D8B6C4');
        this.setTooltip('Converts non-linear audio loudness to a linear audio level.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.loudnessToAudioLevel');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_loudnessToAudioLevel'] = (block, generator) => {
    const _loudness = dfv(generator.valueToCode(block, 'loudness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`AvatarInputs.loudnessToAudioLevel(${_loudness})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarInputs_setShowAudioTools'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.setShowAudioTools')
        // Returns data

        // Params data
        this.appendValueInput('showAudioTools') 
            .setCheck('Boolean')
            .appendField('showAudioTools');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D8B6C4');
        this.setTooltip('Sets whether or not the microphone mute button and audio level meter is shown.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.setShowAudioTools');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_setShowAudioTools'] = (block, generator) => {
    const _showAudioTools = dfv(generator.valueToCode(block, 'showAudioTools', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `AvatarInputs.setShowAudioTools(${_showAudioTools});\n`;};


// Blockly function
Blockly.Blocks['AvatarInputs_setShowBubbleTools'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.setShowBubbleTools')
        // Returns data

        // Params data
        this.appendValueInput('showBubbleTools') 
            .setCheck('Boolean')
            .appendField('showBubbleTools');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D8B6C4');
        this.setTooltip('Sets whether or not the privacy shield button is shown.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.setShowBubbleTools');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_setShowBubbleTools'] = (block, generator) => {
    const _showBubbleTools = dfv(generator.valueToCode(block, 'showBubbleTools', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `AvatarInputs.setShowBubbleTools(${_showBubbleTools});\n`;};


// Blockly signal
Blockly.Blocks['AvatarInputs_isHMDChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarInputs.isHMDChanged');


        this.setColour('#D8B6C4');
        this.setTooltip('Triggered when the display mode changes between desktop and HMD.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.isHMDChanged');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_isHMDChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AvatarInputs.isHMDChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarInputs_showAudioToolsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarInputs.showAudioToolsChanged');

        this.appendDummyInput('show')
            .appendField('show:')
            .appendField(new Blockly.FieldVariable('showAudioToolsChanged_show'), 'show');

        this.setColour('#D8B6C4');
        this.setTooltip('Triggered when the visibility of the microphone mute button and audio level meter changes.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.showAudioToolsChanged');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_showAudioToolsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const show = generator.getVariableName(block.getFieldValue('show'));

return `AvatarInputs.showAudioToolsChanged.connect((_show) => { 
  ${show} = _show;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarInputs_showBubbleToolsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarInputs.showBubbleToolsChanged');

        this.appendDummyInput('show')
            .appendField('show:')
            .appendField(new Blockly.FieldVariable('showBubbleToolsChanged_show'), 'show');

        this.setColour('#D8B6C4');
        this.setTooltip('Triggered when the visibility of the privacy shield button changes.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.showBubbleToolsChanged');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_showBubbleToolsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const show = generator.getVariableName(block.getFieldValue('show'));

return `AvatarInputs.showBubbleToolsChanged.connect((_show) => { 
  ${show} = _show;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarInputs_avatarEnteredIgnoreRadius'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarInputs.avatarEnteredIgnoreRadius');

        this.appendDummyInput('avatarID')
            .appendField('avatarID:')
            .appendField(new Blockly.FieldVariable('avatarEnteredIgnoreRadius_avatarID'), 'avatarID');

        this.setColour('#D8B6C4');
        this.setTooltip('Triggered when another user enters the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.avatarEnteredIgnoreRadius');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_avatarEnteredIgnoreRadius'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const avatarID = generator.getVariableName(block.getFieldValue('avatarID'));

return `AvatarInputs.avatarEnteredIgnoreRadius.connect((_avatarID) => { 
  ${avatarID} = _avatarID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarInputs_ignoreRadiusEnabledChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarInputs.ignoreRadiusEnabledChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('ignoreRadiusEnabledChanged_enabled'), 'enabled');

        this.setColour('#D8B6C4');
        this.setTooltip('Triggered when the privacy shield is enabled or disabled.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.ignoreRadiusEnabledChanged');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_ignoreRadiusEnabledChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `AvatarInputs.ignoreRadiusEnabledChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarInputs_enteredIgnoreRadiusChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarInputs.enteredIgnoreRadiusChanged');


        this.setColour('#D8B6C4');
        this.setTooltip('Triggered when another user enters the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.enteredIgnoreRadiusChanged');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_enteredIgnoreRadiusChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AvatarInputs.enteredIgnoreRadiusChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['AvatarInputs_resetSensors'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.resetSensors')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D8B6C4');
        this.setTooltip('Resets sensors, audio, avatar animations, and the avatar rig.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.resetSensors');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_resetSensors'] = (block, generator) => {


    return `AvatarInputs.resetSensors();\n`;};


// Blockly function
Blockly.Blocks['AvatarInputs_toggleCameraMute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarInputs.toggleCameraMute')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D8B6C4');
        this.setTooltip('Toggles the muting (temporary disablement) of webcam face tracking on/off.<p class="important">Deprecated: This function is deprecated and has been removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarInputs.html#.toggleCameraMute');
    }
};
javascript.javascriptGenerator.forBlock['AvatarInputs_toggleCameraMute'] = (block, generator) => {


    return `AvatarInputs.toggleCameraMute();\n`;};


// Blockly typedef
Blockly.Blocks['InteractiveWindow_WindowProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.WindowProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');
        this.appendValueInput('size') 
            .setCheck('Vec2')
            .appendField('size');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.appendValueInput('presentationMode') 
            .setCheck('InteractiveWindow.PresentationMode')
            .appendField('presentationMode');
        this.appendValueInput('presentationWindowInfo') 
            .setCheck('InteractiveWindow.PresentationWindowInfo')
            .appendField('presentationWindowInfo');
        this.appendValueInput('additionalFlags') 
            .setCheck('InteractiveWindow.Flags')
            .appendField('additionalFlags');
        this.appendValueInput('overrideFlags') 
            .setCheck('InteractiveWindow.OverrideFlags')
            .appendField('overrideFlags');
        this.appendValueInput('relativePositionAnchor') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('relativePositionAnchor');
        this.appendValueInput('relativePosition') 
            .setCheck('Vec2')
            .appendField('relativePosition');
        this.appendValueInput('isFullScreenWindow') 
            .setCheck('Boolean')
            .appendField('isFullScreenWindow');
        this.setColour('#E873CA');
        this.setTooltip('Property values used when creating an <code>InteractiveWindow</code>.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.WindowProperties');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_WindowProperties'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `"InteractiveWindow`);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _presentationMode = dfv(generator.valueToCode(block, 'presentationMode', javascript.javascriptGenerator.ORDER_ATOMIC), `Desktop.PresentationMode.VIRTUAL`);
    const _presentationWindowInfo = dfv(generator.valueToCode(block, 'presentationWindowInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _additionalFlags = dfv(generator.valueToCode(block, 'additionalFlags', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _overrideFlags = dfv(generator.valueToCode(block, 'overrideFlags', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _relativePositionAnchor = dfv(generator.valueToCode(block, 'relativePositionAnchor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _relativePosition = dfv(generator.valueToCode(block, 'relativePosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isFullScreenWindow = dfv(generator.valueToCode(block, 'isFullScreenWindow', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new InteractiveWindow.WindowProperties(${_title},${_position},${_size},${_visible},${_presentationMode},${_presentationWindowInfo},${_additionalFlags},${_overrideFlags},${_relativePositionAnchor},${_relativePosition},${_isFullScreenWindow})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_OverrideFlags'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.OverrideFlags')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#E873CA');
        this.setTooltip('<p>A set of flags customizing <code>InteractiveWindow</code> controls. The value is constructed by using the <code>|</code> (bitwise OR) operator on the individual flag values.</code>.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0x00000001</code></td><td>Window</td><td>Displays the window as a window rather than a dialog.</td></tr>    <tr><td><code>0x00001000</code></td><td>WindowTitleHint</td><td>Adds a title bar.</td><td>    <tr><td><code>0x00002000</code></td><td>WindowSystemMenuHint</td><td>Adds a window system menu.</td><td>    <tr><td><code>0x00004000</code></td><td>WindowMinimizeButtonHint</td><td>Adds a minimize button.</td><td>    <tr><td><code>0x00008000</code></td><td>WindowMaximizeButtonHint</td><td>Adds a maximize button.</td><td>    <tr><td><code>0x00040000</code></td><td>WindowStaysOnTopHint</td><td>The window stays on top of other windows.      <em>Not used on Windows.</em>    <tr><td><code>0x08000000</code></td><td>WindowCloseButtonHint</td><td>Adds a close button.</td><td>  <tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.OverrideFlags');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_OverrideFlags'] = (block, generator) => {

    return [`new InteractiveWindow.OverrideFlags()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_PresentationWindowInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.PresentationWindowInfo')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dockArea') 
            .setCheck('InteractiveWindow.DockArea')
            .appendField('dockArea');
        this.setColour('#E873CA');
        this.setTooltip('Configures how a <code>NATIVE</code> window is displayed.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.PresentationWindowInfo');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_PresentationWindowInfo'] = (block, generator) => {
    const _dockArea = dfv(generator.valueToCode(block, 'dockArea', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new InteractiveWindow.PresentationWindowInfo(${_dockArea})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_Flags'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.Flags')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#E873CA');
        this.setTooltip('<p>A set of  flags controlling <code>InteractiveWindow</code> behavior. The value is constructed by using the <code>|</code> (bitwise OR) operator on the individual flag values.</p><table>  <thead>    <tr><th>Flag Name</th><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td>ALWAYS_ON_TOP</td><td><code>1</code></td><td>The window always displays on top.</td></tr>    <tr><td>CLOSE_BUTTON_HIDES</td><td><code>2</code></td><td>The window hides instead of closing when the user clicks       the "close" button.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.Flags');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_Flags'] = (block, generator) => {

    return [`new InteractiveWindow.Flags()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_PresentationMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.PresentationMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#E873CA');
        this.setTooltip('<p>A display mode for an <code>InteractiveWindow</code>.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>VIRTUAL</td><td>The window is displayed inside Interface: in the desktop window in      desktop mode or on the HUD surface in HMD mode.</td></tr>    <tr><td><code>1</code></td><td>NATIVE</td><td>The window is displayed separately from the Interface window, as its    own separate window.</td></tr>  <tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.PresentationMode');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_PresentationMode'] = (block, generator) => {

    return [`new InteractiveWindow.PresentationMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_DockArea'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.DockArea')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#E873CA');
        this.setTooltip('<p>A docking location of an <code>InteractiveWindow</code>.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>TOP</td><td>Dock to the top edge of the Interface window.</td></tr>    <tr><td><code>1</code></td><td>BOTTOM</td><td>Dock to the bottom edge of the Interface window.</td></tr>    <tr><td><code>2</code></td><td>LEFT</td><td>Dock to the left edge of the Interface window.</td></tr>    <tr><td><code>3</code></td><td>RIGHT</td><td>Dock to the right edge of the Interface window.</td></tr>  <tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.DockArea');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_DockArea'] = (block, generator) => {

    return [`new InteractiveWindow.DockArea()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['InteractiveWindow_RelativePositionAnchor'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.RelativePositionAnchor')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#E873CA');
        this.setTooltip('<p>The anchor for a relative position of an <code>InteractiveWindow</code>.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>NO_ANCHOR</td><td>Position is not relative to any part of the Interface window.</td></tr>    <tr><td><code>1</code></td><td>TOP_LEFT</td><td>Position is offset from the top left of the Interface window.</td></tr>    <tr><td><code>2</code></td><td>TOP_RIGHT</td><td>Position is offset from the top right of the Interface window.</td></tr>    <tr><td><code>3</code></td><td>BOTTOM_RIGHT</td><td>Position offset from the bottom right of the Interface    window.</td></tr>    <tr><td><code>4</code></td><td>BOTTOM_LEFFT</td><td>Position is offset from the bottom left of the Interface        window.</td></tr>  <tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.RelativePositionAnchor');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_RelativePositionAnchor'] = (block, generator) => {

    return [`new InteractiveWindow.RelativePositionAnchor()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['InteractiveWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');
        this.appendValueInput('relativePositionAnchor') 
            .setCheck('InteractiveWindow.RelativePositionAnchor')
            .appendField('relativePositionAnchor');
        this.appendValueInput('relativePosition') 
            .setCheck('Vec2')
            .appendField('relativePosition');
        this.appendValueInput('size') 
            .setCheck('Vec2')
            .appendField('size');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.appendValueInput('presentationMode') 
            .setCheck('InteractiveWindow.PresentationMode')
            .appendField('presentationMode');
        this.setColour('#E873CA');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>An <code>InteractiveWindow</code> can display either inside Interface or in its own window separate from the Interface window. The window content is defined by a QML file, which can optionally include a <code>WebView</code> control that embeds an HTML web page. (The <code>WebView</code> control is defined by a "WebView.qml" file included in the Interface install.)<p>Create using {@link Desktop.createWindow}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _relativePositionAnchor = dfv(generator.valueToCode(block, 'relativePositionAnchor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _relativePosition = dfv(generator.valueToCode(block, 'relativePosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _presentationMode = dfv(generator.valueToCode(block, 'presentationMode', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new InteractiveWindow(${_title},${_position},${_relativePositionAnchor},${_relativePosition},${_size},${_visible},${_presentationMode})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['InteractiveWindow_sendToQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.sendToQml')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E873CA');
        this.setTooltip('Sends a message to the QML page. To receive the message, the QML page must implement a function:<pre class="prettyprint"><code>function fromScript(message) {  ...}</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.sendToQml');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_sendToQml'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `InteractiveWindow.sendToQml(${_message});\n`;};


// Blockly function
Blockly.Blocks['InteractiveWindow_emitScriptEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.emitScriptEvent')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E873CA');
        this.setTooltip('Sends a message to an embedded HTML web page. To receive the message, the HTML page\'s script must connect to the <code>EventBridge</code> that is automatically provided for the script:<pre class="prettyprint"><code>EventBridge.scriptEventReceived.connect(function(message) {    ...});</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.emitScriptEvent');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_emitScriptEvent'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `InteractiveWindow.emitScriptEvent(${_message});\n`;};


// Blockly function
Blockly.Blocks['InteractiveWindow_close'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.close')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E873CA');
        this.setTooltip('Closes the window. It can then no longer be used.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.close');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_close'] = (block, generator) => {


    return `InteractiveWindow.close();\n`;};


// Blockly function
Blockly.Blocks['InteractiveWindow_show'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.show')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E873CA');
        this.setTooltip('Makes the window visible and raises it to the top.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.show');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_show'] = (block, generator) => {


    return `InteractiveWindow.show();\n`;};


// Blockly function
Blockly.Blocks['InteractiveWindow_raise'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('InteractiveWindow.raise')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E873CA');
        this.setTooltip('Raises the window to the top.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.raise');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_raise'] = (block, generator) => {


    return `InteractiveWindow.raise();\n`;};


// Blockly signal
Blockly.Blocks['InteractiveWindow_visibleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.visibleChanged');


        this.setColour('#E873CA');
        this.setTooltip('Triggered when the window is made visible or invisible, or is closed.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.visibleChanged');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_visibleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `InteractiveWindow.visibleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_positionChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.positionChanged');


        this.setColour('#E873CA');
        this.setTooltip('Triggered when the window\'s position changes.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.positionChanged');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_positionChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `InteractiveWindow.positionChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_sizeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.sizeChanged');


        this.setColour('#E873CA');
        this.setTooltip('Triggered when the window\'s size changes.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.sizeChanged');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_sizeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `InteractiveWindow.sizeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_presentationModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.presentationModeChanged');


        this.setColour('#E873CA');
        this.setTooltip('Triggered when the window\'s presentation mode changes.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.presentationModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_presentationModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `InteractiveWindow.presentationModeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_titleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.titleChanged');


        this.setColour('#E873CA');
        this.setTooltip('Triggered when window\'s title changes.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.titleChanged');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_titleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `InteractiveWindow.titleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_closed'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.closed');


        this.setColour('#E873CA');
        this.setTooltip('Triggered when the window is closed.');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.closed');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_closed'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `InteractiveWindow.closed.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_fromQml'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.fromQml');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('fromQml_message'), 'message');

        this.setColour('#E873CA');
        this.setTooltip('Triggered when a message from the QML page is received. The QML page can send a message (string or object) by calling:<pre class="prettyprint"><code>sendToScript(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.fromQml');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_fromQml'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `InteractiveWindow.fromQml.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['InteractiveWindow_webEventReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('InteractiveWindow.webEventReceived');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('webEventReceived_message'), 'message');

        this.setColour('#E873CA');
        this.setTooltip('Triggered when a message from an embedded HTML web page is received. The HTML web page can send a message by calling:<pre class="prettyprint"><code>EventBridge.emitWebEvent(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/InteractiveWindow.html#.webEventReceived');
    }
};
javascript.javascriptGenerator.forBlock['InteractiveWindow_webEventReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `InteractiveWindow.webEventReceived.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Snapshot_snapshotLocationSet'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Snapshot.snapshotLocationSet');

        this.appendDummyInput('location')
            .appendField('location:')
            .appendField(new Blockly.FieldVariable('snapshotLocationSet_location'), 'location');

        this.setColour('#D4E271');
        this.setTooltip('Triggered when the path that snapshots are saved to is changed.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.snapshotLocationSet');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_snapshotLocationSet'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const location = generator.getVariableName(block.getFieldValue('location'));

return `Snapshot.snapshotLocationSet.connect((_location) => { 
  ${location} = _location;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['Snapshot_getSnapshotsLocation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getSnapshotsLocation')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Gets the path that snapshots are saved to.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getSnapshotsLocation');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getSnapshotsLocation'] = (block, generator) => {

return [`Snapshot.getSnapshotsLocation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Snapshot_setSnapshotsLocation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.setSnapshotsLocation')
        // Returns data

        // Params data
        this.appendValueInput('location') 
            .setCheck('String')
            .appendField('location');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D4E271');
        this.setTooltip('Sets the path that snapshots are saved to.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.setSnapshotsLocation');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_setSnapshotsLocation'] = (block, generator) => {
    const _location = dfv(generator.valueToCode(block, 'location', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Snapshot.setSnapshotsLocation(${_location});\n`;};


// Blockly function
Blockly.Blocks['Snapshot_getSnapshotFormat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getSnapshotFormat')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Gets the currently selected snapshot format.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getSnapshotFormat');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getSnapshotFormat'] = (block, generator) => {

return [`Snapshot.getSnapshotFormat()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Snapshot_setSnapshotFormat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.setSnapshotFormat')
        // Returns data

        // Params data
        this.appendValueInput('format') 
            .setCheck('String')
            .appendField('format');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D4E271');
        this.setTooltip('Sets the snapshot format.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.setSnapshotFormat');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_setSnapshotFormat'] = (block, generator) => {
    const _format = dfv(generator.valueToCode(block, 'format', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Snapshot.setSnapshotFormat(${_format});\n`;};


// Blockly function
Blockly.Blocks['Snapshot_getAnimatedSnapshotFormat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getAnimatedSnapshotFormat')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Gets the currently selected animated snapshot format.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getAnimatedSnapshotFormat');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getAnimatedSnapshotFormat'] = (block, generator) => {

return [`Snapshot.getAnimatedSnapshotFormat()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Snapshot_setAnimatedSnapshotFormat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.setAnimatedSnapshotFormat')
        // Returns data

        // Params data
        this.appendValueInput('format') 
            .setCheck('String')
            .appendField('format');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D4E271');
        this.setTooltip('Sets the snapshot format.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.setAnimatedSnapshotFormat');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_setAnimatedSnapshotFormat'] = (block, generator) => {
    const _format = dfv(generator.valueToCode(block, 'format', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Snapshot.setAnimatedSnapshotFormat(${_format});\n`;};


// Blockly function
Blockly.Blocks['Snapshot_getAvailableSnapshotFormats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getAvailableSnapshotFormats')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Returns a list of supported snapshot formats.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getAvailableSnapshotFormats');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getAvailableSnapshotFormats'] = (block, generator) => {

return [`Snapshot.getAvailableSnapshotFormats()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Snapshot_getAvailableSnapshotFormatsWithDescriptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getAvailableSnapshotFormatsWithDescriptions')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Returns a list of supported snapshot formats with short descriptions.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getAvailableSnapshotFormatsWithDescriptions');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getAvailableSnapshotFormatsWithDescriptions'] = (block, generator) => {

return [`Snapshot.getAvailableSnapshotFormatsWithDescriptions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Snapshot_getAvailableAnimatedSnapshotFormats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getAvailableAnimatedSnapshotFormats')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Returns a list of supported animated snapshot formats.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getAvailableAnimatedSnapshotFormats');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getAvailableAnimatedSnapshotFormats'] = (block, generator) => {

return [`Snapshot.getAvailableAnimatedSnapshotFormats()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Snapshot_getAvailableAnimatedSnapshotFormatsWithDescriptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Snapshot.getAvailableAnimatedSnapshotFormatsWithDescriptions')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#D4E271');
        this.setTooltip('Returns a list of supported animated snapshot formats with short descriptions.');
        this.setHelpUrl('https://apidocs.overte.org/Snapshot.html#.getAvailableAnimatedSnapshotFormatsWithDescriptions');
    }
};
javascript.javascriptGenerator.forBlock['Snapshot_getAvailableAnimatedSnapshotFormatsWithDescriptions'] = (block, generator) => {

return [`Snapshot.getAvailableAnimatedSnapshotFormatsWithDescriptions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['Stats_expanded'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.expanded')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<code>true</code> if the statistics overlay should be in expanded form when the overlay is     displayed, <code>false</code> if it shouldn\'t be expanded.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.expanded');
    }
};
javascript.javascriptGenerator.forBlock['Stats_expanded'] = (block, generator) => {
    return [`Stats.expanded`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_timingExpanded'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.timingExpanded')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<code>true</code> if timing details should be displayed when the statistics overlay is     displayed in expanded form, <code>false</code> if timing details should not be displayed. Set by the menu item,     Developer &gt; Timing &gt; Performance Timer &gt; Display Timing Details.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.timingExpanded');
    }
};
javascript.javascriptGenerator.forBlock['Stats_timingExpanded'] = (block, generator) => {
    return [`Stats.timingExpanded`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_monospaceFont'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.monospaceFont')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The name of the monospace font used in the statistics overlay.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.monospaceFont');
    }
};
javascript.javascriptGenerator.forBlock['Stats_monospaceFont'] = (block, generator) => {
    return [`Stats.monospaceFont`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_serverCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.serverCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of servers that Interface is connected to.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverCount'] = (block, generator) => {
    return [`Stats.serverCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_renderrate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.renderrate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The rate at which new GPU frames are being created, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.renderrate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_renderrate'] = (block, generator) => {
    return [`Stats.renderrate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_presentrate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.presentrate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The rate at which the display plugin is presenting to the display device, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.presentrate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_presentrate'] = (block, generator) => {
    return [`Stats.presentrate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_stutterrate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.stutterrate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The rate at which the display plugin is reprojecting old GPU frames, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.stutterrate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_stutterrate'] = (block, generator) => {
    return [`Stats.stutterrate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_appdropped'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.appdropped')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of times a frame has not been provided to the display device in time.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.appdropped');
    }
};
javascript.javascriptGenerator.forBlock['Stats_appdropped'] = (block, generator) => {
    return [`Stats.appdropped`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_longsubmits'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.longsubmits')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of times the display device has taken longer than 11ms to return after being     given a frame.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.longsubmits');
    }
};
javascript.javascriptGenerator.forBlock['Stats_longsubmits'] = (block, generator) => {
    return [`Stats.longsubmits`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_longrenders'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.longrenders')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of times it has taken longer than 11ms to submit a new frame to the display     device.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.longrenders');
    }
};
javascript.javascriptGenerator.forBlock['Stats_longrenders'] = (block, generator) => {
    return [`Stats.longrenders`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_longframes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.longframes')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of times <code>longsubmits + longrenders</code> has taken longer than 15ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.longframes');
    }
};
javascript.javascriptGenerator.forBlock['Stats_longframes'] = (block, generator) => {
    return [`Stats.longframes`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_presentnewrate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.presentnewrate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The rate at which the display plugin is presenting new GPU frames, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.presentnewrate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_presentnewrate'] = (block, generator) => {
    return [`Stats.presentnewrate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_presentdroprate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.presentdroprate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The rate at which the display plugin is dropping GPU frames, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.presentdroprate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_presentdroprate'] = (block, generator) => {
    return [`Stats.presentdroprate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gameLoopRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gameLoopRate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The rate at which the game loop is running, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gameLoopRate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gameLoopRate'] = (block, generator) => {
    return [`Stats.gameLoopRate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_refreshRateTarget'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.refreshRateTarget')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The current target refresh rate, in Hz, per the current <code>refreshRateMode</code>     and <code>refreshRateRegime</code> if in desktop mode; a higher rate if in VR mode.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.refreshRateTarget');
    }
};
javascript.javascriptGenerator.forBlock['Stats_refreshRateTarget'] = (block, generator) => {
    return [`Stats.refreshRateTarget`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_refreshRateMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.refreshRateMode')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The current refresh rate profile.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.refreshRateMode');
    }
};
javascript.javascriptGenerator.forBlock['Stats_refreshRateMode'] = (block, generator) => {
    return [`Stats.refreshRateMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_refreshRateRegime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.refreshRateRegime')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The current refresh rate regime.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.refreshRateRegime');
    }
};
javascript.javascriptGenerator.forBlock['Stats_refreshRateRegime'] = (block, generator) => {
    return [`Stats.refreshRateRegime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_uxMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.uxMode')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The user experience (UX) mode that Interface is running in.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.uxMode');
    }
};
javascript.javascriptGenerator.forBlock['Stats_uxMode'] = (block, generator) => {
    return [`Stats.uxMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of avatars in the domain other than the client\'s.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarCount'] = (block, generator) => {
    return [`Stats.avatarCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_heroAvatarCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.heroAvatarCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number avatars in a "hero" zone in the domain, other than the client\'s.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.heroAvatarCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_heroAvatarCount'] = (block, generator) => {
    return [`Stats.heroAvatarCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_physicsObjectCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.physicsObjectCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of objects that have collisions enabled.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.physicsObjectCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_physicsObjectCount'] = (block, generator) => {
    return [`Stats.physicsObjectCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_updatedAvatarCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.updatedAvatarCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of avatars in the domain, other than the client\'s, that were updated in     the most recent game loop.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.updatedAvatarCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_updatedAvatarCount'] = (block, generator) => {
    return [`Stats.updatedAvatarCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_updatedHeroAvatarCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.updatedHeroAvatarCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of avatars in a "hero" zone in the domain, other than the client\'s,     that were updated in the most recent game loop.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.updatedHeroAvatarCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_updatedHeroAvatarCount'] = (block, generator) => {
    return [`Stats.updatedHeroAvatarCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_notUpdatedAvatarCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.notUpdatedAvatarCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of avatars in the domain, other than the client\'s, that weren\'t able     to be updated in the most recent game loop because there wasn\'t enough time to.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.notUpdatedAvatarCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_notUpdatedAvatarCount'] = (block, generator) => {
    return [`Stats.notUpdatedAvatarCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_packetInCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.packetInCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of packets being received from the domain server, in packets per second.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.packetInCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_packetInCount'] = (block, generator) => {
    return [`Stats.packetInCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_packetOutCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.packetOutCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of packets being sent to the domain server, in packets per second.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.packetOutCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_packetOutCount'] = (block, generator) => {
    return [`Stats.packetOutCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_mbpsIn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.mbpsIn')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being received from the domain server, in megabits per second.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.mbpsIn');
    }
};
javascript.javascriptGenerator.forBlock['Stats_mbpsIn'] = (block, generator) => {
    return [`Stats.mbpsIn`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_mbpsOut'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.mbpsOut')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being sent to the domain server, in megabits per second.   <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.mbpsOut');
    }
};
javascript.javascriptGenerator.forBlock['Stats_mbpsOut'] = (block, generator) => {
    return [`Stats.mbpsOut`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_assetMbpsIn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.assetMbpsIn')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being received from the asset server, in megabits per second.    <code>0.0</code> if not connected to an avatar mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.assetMbpsIn');
    }
};
javascript.javascriptGenerator.forBlock['Stats_assetMbpsIn'] = (block, generator) => {
    return [`Stats.assetMbpsIn`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_assetMbpsOut'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.assetMbpsOut')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being sent to the asset server, in megabits per second.    <code>0.0</code> if not connected to an avatar mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.assetMbpsOut');
    }
};
javascript.javascriptGenerator.forBlock['Stats_assetMbpsOut'] = (block, generator) => {
    return [`Stats.assetMbpsOut`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioPing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioPing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The ping time to the audio mixer, in ms.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioPing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioPing'] = (block, generator) => {
    return [`Stats.audioPing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarPing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarPing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The ping time to the avatar mixer, in ms.    <code>-1</code> if not connected to an avatar mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarPing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarPing'] = (block, generator) => {
    return [`Stats.avatarPing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_entitiesPing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.entitiesPing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The average ping time to the entity servers, in ms.    <code>-1</code> if not connected to an entity server.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.entitiesPing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_entitiesPing'] = (block, generator) => {
    return [`Stats.entitiesPing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_assetPing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.assetPing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The ping time to the asset server, in ms.    <code>-1</code> if not connected to an asset server.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.assetPing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_assetPing'] = (block, generator) => {
    return [`Stats.assetPing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_messagePing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.messagePing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The ping time to the message mixer, in ms.    <code>-1</code> if not connected to a message mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.messagePing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_messagePing'] = (block, generator) => {
    return [`Stats.messagePing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_position'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.position')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The position of the user\'s avatar.    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.position');
    }
};
javascript.javascriptGenerator.forBlock['Stats_position'] = (block, generator) => {
    return [`Stats.position`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_speed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.speed')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The speed of the user\'s avatar, in m/s.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.speed');
    }
};
javascript.javascriptGenerator.forBlock['Stats_speed'] = (block, generator) => {
    return [`Stats.speed`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_yaw'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.yaw')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The yaw of the user\'s avatar body, in degrees.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.yaw');
    }
};
javascript.javascriptGenerator.forBlock['Stats_yaw'] = (block, generator) => {
    return [`Stats.yaw`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarMixerInKbps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarMixerInKbps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being received from the avatar mixer, in kilobits per second.    <code>-1</code> if not connected to an avatar mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerInKbps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerInKbps'] = (block, generator) => {
    return [`Stats.avatarMixerInKbps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarMixerInPps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarMixerInPps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of packets being received from the avatar mixer, in packets per second.    <code>-1</code> if not connected to an avatar mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerInPps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerInPps'] = (block, generator) => {
    return [`Stats.avatarMixerInPps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarMixerOutKbps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarMixerOutKbps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being sent to the avatar mixer, in kilobits per second.     <code>-1</code> if not connected to an avatar mixer.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerOutKbps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerOutKbps'] = (block, generator) => {
    return [`Stats.avatarMixerOutKbps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarMixerOutPps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarMixerOutPps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of packets being sent to the avatar mixer, in packets per second.     <code>-1</code> if not connected to an avatar mixer.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerOutPps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerOutPps'] = (block, generator) => {
    return [`Stats.avatarMixerOutPps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_myAvatarSendRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.myAvatarSendRate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of avatar packets being sent by the user\'s avatar, in packets per second.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.myAvatarSendRate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_myAvatarSendRate'] = (block, generator) => {
    return [`Stats.myAvatarSendRate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioMixerInKbps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioMixerInKbps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being received from the audio mixer, in kilobits per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerInKbps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerInKbps'] = (block, generator) => {
    return [`Stats.audioMixerInKbps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioMixerInPps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioMixerInPps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of packets being received from the audio mixer, in packets per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerInPps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerInPps'] = (block, generator) => {
    return [`Stats.audioMixerInPps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioMixerOutKbps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioMixerOutKbps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of data being sent to the audio mixer, in kilobits per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerOutKbps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerOutKbps'] = (block, generator) => {
    return [`Stats.audioMixerOutKbps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioMixerOutPps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioMixerOutPps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of packets being sent to the audio mixer, in packets per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerOutPps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerOutPps'] = (block, generator) => {
    return [`Stats.audioMixerOutPps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioMixerKbps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioMixerKbps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total amount of data being sent to and received from the audio mixer, in kilobits     per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerKbps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerKbps'] = (block, generator) => {
    return [`Stats.audioMixerKbps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioMixerPps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioMixerPps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total number of packets being sent to and received from the audio mixer, in packets     per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerPps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerPps'] = (block, generator) => {
    return [`Stats.audioMixerPps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioOutboundPPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioOutboundPPS')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of non-silent audio packets being sent by the user, in packets per second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioOutboundPPS');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioOutboundPPS'] = (block, generator) => {
    return [`Stats.audioOutboundPPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioSilentOutboundPPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioSilentOutboundPPS')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of silent audio packets being sent by the user, in packets per     second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioSilentOutboundPPS');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioSilentOutboundPPS'] = (block, generator) => {
    return [`Stats.audioSilentOutboundPPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioInboundPPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioInboundPPS')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of non-silent audio packets being received by the user, in packets per    second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioInboundPPS');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioInboundPPS'] = (block, generator) => {
    return [`Stats.audioInboundPPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioAudioInboundPPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioAudioInboundPPS')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of non-silent audio packets being received by the user, in packets per    second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed. Use <code>audioInboundPPS</code>     instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioAudioInboundPPS');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioAudioInboundPPS'] = (block, generator) => {
    return [`Stats.audioAudioInboundPPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioSilentInboundPPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioSilentInboundPPS')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of silent audio packets being received by the user, in packets per     second.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioSilentInboundPPS');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioSilentInboundPPS'] = (block, generator) => {
    return [`Stats.audioSilentInboundPPS`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioPacketLoss'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioPacketLoss')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of audio packets being lost, sent to or received from the audio mixer, in %.    <code>-1</code> if not connected to an audio mixer.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioPacketLoss');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioPacketLoss'] = (block, generator) => {
    return [`Stats.audioPacketLoss`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioCodec'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioCodec')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The name of the audio codec.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioCodec');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioCodec'] = (block, generator) => {
    return [`Stats.audioCodec`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioNoiseGate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioNoiseGate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The status of the audio noise gate: <code>"Open"</code> or <code>"Closed"</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioNoiseGate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioNoiseGate'] = (block, generator) => {
    return [`Stats.audioNoiseGate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_audioInjectors'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.audioInjectors')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of audio injectors, local and non-local.    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioInjectors');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioInjectors'] = (block, generator) => {
    return [`Stats.audioInjectors`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_entityPacketsInKbps'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.entityPacketsInKbps')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The average amount of data being received from entity servers, in kilobits per     second. (Multiply by the number of entity servers to get the total amount of data being received.)    <code>-1</code> if not connected to an entity server.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.entityPacketsInKbps');
    }
};
javascript.javascriptGenerator.forBlock['Stats_entityPacketsInKbps'] = (block, generator) => {
    return [`Stats.entityPacketsInKbps`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_downloads'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.downloads')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of downloads in progress.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloads');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloads'] = (block, generator) => {
    return [`Stats.downloads`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_downloadLimit'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.downloadLimit')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The maximum number of concurrent downloads.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadLimit');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadLimit'] = (block, generator) => {
    return [`Stats.downloadLimit`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_downloadsPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.downloadsPending')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of downloads pending.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadsPending');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadsPending'] = (block, generator) => {
    return [`Stats.downloadsPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_downloadUrls'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.downloadUrls')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The download URLs.    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadUrls');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadUrls'] = (block, generator) => {
    return [`Stats.downloadUrls`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_processing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.processing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of completed downloads being processed.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.processing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_processing'] = (block, generator) => {
    return [`Stats.processing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_processingPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.processingPending')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of completed downloads waiting to be processed.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.processingPending');
    }
};
javascript.javascriptGenerator.forBlock['Stats_processingPending'] = (block, generator) => {
    return [`Stats.processingPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_triangles'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.triangles')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of triangles in the rendered scene.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.triangles');
    }
};
javascript.javascriptGenerator.forBlock['Stats_triangles'] = (block, generator) => {
    return [`Stats.triangles`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_drawcalls'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.drawcalls')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of draw calls made for the rendered scene.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.drawcalls');
    }
};
javascript.javascriptGenerator.forBlock['Stats_drawcalls'] = (block, generator) => {
    return [`Stats.drawcalls`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_materialSwitches'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.materialSwitches')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of material switches performed for the rendered scene.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.materialSwitches');
    }
};
javascript.javascriptGenerator.forBlock['Stats_materialSwitches'] = (block, generator) => {
    return [`Stats.materialSwitches`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_itemConsidered'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.itemConsidered')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of item considerations made for rendering.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemConsidered');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemConsidered'] = (block, generator) => {
    return [`Stats.itemConsidered`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_itemOutOfView'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.itemOutOfView')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of items out of view.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemOutOfView');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemOutOfView'] = (block, generator) => {
    return [`Stats.itemOutOfView`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_itemTooSmall'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.itemTooSmall')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of items too small to render.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemTooSmall');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemTooSmall'] = (block, generator) => {
    return [`Stats.itemTooSmall`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_itemRendered'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.itemRendered')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of items rendered.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemRendered');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemRendered'] = (block, generator) => {
    return [`Stats.itemRendered`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_shadowConsidered'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.shadowConsidered')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of shadow considerations made for rendering.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowConsidered');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowConsidered'] = (block, generator) => {
    return [`Stats.shadowConsidered`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_shadowOutOfView'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.shadowOutOfView')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of shadows out of view.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowOutOfView');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowOutOfView'] = (block, generator) => {
    return [`Stats.shadowOutOfView`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_shadowTooSmall'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.shadowTooSmall')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of shadows too small to render.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowTooSmall');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowTooSmall'] = (block, generator) => {
    return [`Stats.shadowTooSmall`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_shadowRendered'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.shadowRendered')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of shadows rendered.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowRendered');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowRendered'] = (block, generator) => {
    return [`Stats.shadowRendered`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_sendingMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.sendingMode')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('Description of the octree sending mode.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.sendingMode');
    }
};
javascript.javascriptGenerator.forBlock['Stats_sendingMode'] = (block, generator) => {
    return [`Stats.sendingMode`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_packetStats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.packetStats')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('Description of the octree packet processing state.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.packetStats');
    }
};
javascript.javascriptGenerator.forBlock['Stats_packetStats'] = (block, generator) => {
    return [`Stats.packetStats`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_lodAngle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.lodAngle')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The target LOD angle, in degrees.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.lodAngle');
    }
};
javascript.javascriptGenerator.forBlock['Stats_lodAngle'] = (block, generator) => {
    return [`Stats.lodAngle`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_lodTargetFramerate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.lodTargetFramerate')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The target LOD frame rate, in Hz.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.lodTargetFramerate');
    }
};
javascript.javascriptGenerator.forBlock['Stats_lodTargetFramerate'] = (block, generator) => {
    return [`Stats.lodTargetFramerate`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_lodStatus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.lodStatus')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('Description of the current LOD.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.lodStatus');
    }
};
javascript.javascriptGenerator.forBlock['Stats_lodStatus'] = (block, generator) => {
    return [`Stats.lodStatus`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_numEntityUpdates'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.numEntityUpdates')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of entity updates that happened last frame.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.numEntityUpdates');
    }
};
javascript.javascriptGenerator.forBlock['Stats_numEntityUpdates'] = (block, generator) => {
    return [`Stats.numEntityUpdates`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_numNeededEntityUpdates'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.numNeededEntityUpdates')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total number of entity updates scheduled for last frame.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.numNeededEntityUpdates');
    }
};
javascript.javascriptGenerator.forBlock['Stats_numNeededEntityUpdates'] = (block, generator) => {
    return [`Stats.numNeededEntityUpdates`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_timingStats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.timingStats')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('Details of the average time (ms) spent in and number of calls made to different parts of     the code. Provided only if <code>timingExpanded</code> is <code>true</code>. Only the top 10 items are provided if     Developer &gt; Timing &gt; Performance Timer &gt; Only Display Top 10 is enabled.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.timingStats');
    }
};
javascript.javascriptGenerator.forBlock['Stats_timingStats'] = (block, generator) => {
    return [`Stats.timingStats`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gameUpdateStats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gameUpdateStats')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('Details of the average time (ms) spent in different parts of the game loop.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gameUpdateStats');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gameUpdateStats'] = (block, generator) => {
    return [`Stats.gameUpdateStats`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_serverElements'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.serverElements')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total number of elements in the server octree.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverElements');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverElements'] = (block, generator) => {
    return [`Stats.serverElements`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_serverInternal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.serverInternal')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of internal elements in the server octree.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverInternal');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverInternal'] = (block, generator) => {
    return [`Stats.serverInternal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_serverLeaves'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.serverLeaves')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of leaf elements in the server octree.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverLeaves');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverLeaves'] = (block, generator) => {
    return [`Stats.serverLeaves`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_localElements'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.localElements')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total number of elements in the client octree.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.localElements');
    }
};
javascript.javascriptGenerator.forBlock['Stats_localElements'] = (block, generator) => {
    return [`Stats.localElements`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_localInternal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.localInternal')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of internal elements in the client octree.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.localInternal');
    }
};
javascript.javascriptGenerator.forBlock['Stats_localInternal'] = (block, generator) => {
    return [`Stats.localInternal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_localLeaves'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.localLeaves')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of leaf elements in the client octree.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.localLeaves');
    }
};
javascript.javascriptGenerator.forBlock['Stats_localLeaves'] = (block, generator) => {
    return [`Stats.localLeaves`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_rectifiedTextureCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.rectifiedTextureCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of textures that have been resized so that their dimensions is a power     of 2 if smaller than 128 pixels, or a multiple of 128 if greater than 128 pixels.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rectifiedTextureCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rectifiedTextureCount'] = (block, generator) => {
    return [`Stats.rectifiedTextureCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_decimatedTextureCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.decimatedTextureCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of textures that have been reduced in size because they were over the     maximum allowed dimensions of 8192 pixels on desktop or 2048 pixels on mobile.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.decimatedTextureCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_decimatedTextureCount'] = (block, generator) => {
    return [`Stats.decimatedTextureCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuBuffers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuBuffers')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of OpenGL buffer objects managed by the GPU back-end.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuBuffers');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuBuffers'] = (block, generator) => {
    return [`Stats.gpuBuffers`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuBufferMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuBufferMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total memory size of the <code>gpuBuffers</code>, in MB.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuBufferMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuBufferMemory'] = (block, generator) => {
    return [`Stats.gpuBufferMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextures'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextures')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of OpenGL textures managed by the GPU back-end. This is the sum of the number of     textures managed for <code>gpuTextureResidentMemory</code>,  <code>gpuTextureResourceMemory</code>, and    <code>gpuTextureFramebufferMemory</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextures');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextures'] = (block, generator) => {
    return [`Stats.gpuTextures`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The total memory size of the <code>gpuTextures</code>, in MB. This is the sum of     <code>gpuTextureResidentMemory</code>,  <code>gpuTextureResourceMemory</code>, and     <code>gpuTextureFramebufferMemory</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureMemory'] = (block, generator) => {
    return [`Stats.gpuTextureMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_glContextSwapchainMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.glContextSwapchainMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The estimated memory used by the default OpenGL frame buffer, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.glContextSwapchainMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_glContextSwapchainMemory'] = (block, generator) => {
    return [`Stats.glContextSwapchainMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_qmlTextureMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.qmlTextureMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The memory size of textures managed by the offscreen QML surface, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.qmlTextureMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_qmlTextureMemory'] = (block, generator) => {
    return [`Stats.qmlTextureMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_texturePendingTransfers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.texturePendingTransfers')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The memory size of textures pending transfer to the GPU, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.texturePendingTransfers');
    }
};
javascript.javascriptGenerator.forBlock['Stats_texturePendingTransfers'] = (block, generator) => {
    return [`Stats.texturePendingTransfers`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureResidentMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureResidentMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The memory size of the "strict" textures that always have their full     resolution in GPU memory, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResidentMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResidentMemory'] = (block, generator) => {
    return [`Stats.gpuTextureResidentMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureFramebufferMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureFramebufferMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The memory size of the frame buffer on the GPU, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureFramebufferMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureFramebufferMemory'] = (block, generator) => {
    return [`Stats.gpuTextureFramebufferMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureResourceMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureResourceMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of GPU memory that has been allocated for "variable" textures that     don\'t necessarily always have their full resolution in GPU memory, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResourceMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResourceMemory'] = (block, generator) => {
    return [`Stats.gpuTextureResourceMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureResourceIdealMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureResourceIdealMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of memory that "variable" textures would take up if they were     all completely loaded, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResourceIdealMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResourceIdealMemory'] = (block, generator) => {
    return [`Stats.gpuTextureResourceIdealMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureResourcePopulatedMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureResourcePopulatedMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('How much of the GPU memory allocated has actually been populated, in      MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResourcePopulatedMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResourcePopulatedMemory'] = (block, generator) => {
    return [`Stats.gpuTextureResourcePopulatedMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureMemoryPressureState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureMemoryPressureState')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The stats of the texture transfer engine.    <ul>        <li><code>"Undersubscribed"</code>: There is texture data that can fit in memory but that isn\'t on the GPU, so more         GPU texture memory should be allocated if possible.</li>        <li><code>"Transfer"</code>: More GPU texture memory has been allocated and texture data is being transferred.</li>        <li><code>"Idle"</code>: Either all texture data has been transferred to the GPU or there is nor more space         available.</li>    </ul>    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureMemoryPressureState');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureMemoryPressureState'] = (block, generator) => {
    return [`Stats.gpuTextureMemoryPressureState`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuFreeMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuFreeMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The amount of GPU memory available after all allocations, in MB.     <em>Read-only.</em>    <p><strong>Note:</strong> This is not a reliable number because OpenGL doesn\'t have an official method of getting this     information.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFreeMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFreeMemory'] = (block, generator) => {
    return [`Stats.gpuFreeMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuTextureExternalMemory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuTextureExternalMemory')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The estimated amount of memory consumed by textures being used but that are    not managed by the GPU library, in MB.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureExternalMemory');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureExternalMemory'] = (block, generator) => {
    return [`Stats.gpuTextureExternalMemory`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuFrameSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuFrameSize')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The dimensions of the frames being rendered, in pixels.    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFrameSize');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFrameSize'] = (block, generator) => {
    return [`Stats.gpuFrameSize`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuFrameTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuFrameTime')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The time the GPU is spending on a frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFrameTime');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFrameTime'] = (block, generator) => {
    return [`Stats.gpuFrameTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_gpuFrameTimePerPixel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.gpuFrameTimePerPixel')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The time the GPU is spending on a pixel, in ns.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFrameTimePerPixel');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFrameTimePerPixel'] = (block, generator) => {
    return [`Stats.gpuFrameTimePerPixel`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_batchFrameTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.batchFrameTime')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The time being spent batch processing each frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.batchFrameTime');
    }
};
javascript.javascriptGenerator.forBlock['Stats_batchFrameTime'] = (block, generator) => {
    return [`Stats.batchFrameTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_engineFrameTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.engineFrameTime')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The time being spent in the render engine each frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.engineFrameTime');
    }
};
javascript.javascriptGenerator.forBlock['Stats_engineFrameTime'] = (block, generator) => {
    return [`Stats.engineFrameTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_avatarSimulationTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.avatarSimulationTime')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The time being spent simulating avatars each frame, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarSimulationTime');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarSimulationTime'] = (block, generator) => {
    return [`Stats.avatarSimulationTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_stylusPicksCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.stylusPicksCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of stylus picks currently in effect.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.stylusPicksCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_stylusPicksCount'] = (block, generator) => {
    return [`Stats.stylusPicksCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_rayPicksCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.rayPicksCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of ray picks currently in effect.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rayPicksCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rayPicksCount'] = (block, generator) => {
    return [`Stats.rayPicksCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_parabolaPicksCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.parabolaPicksCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of parabola picks currently in effect.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.parabolaPicksCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_parabolaPicksCount'] = (block, generator) => {
    return [`Stats.parabolaPicksCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_collisionPicksCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.collisionPicksCount')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of collision picks currently in effect.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.collisionPicksCount');
    }
};
javascript.javascriptGenerator.forBlock['Stats_collisionPicksCount'] = (block, generator) => {
    return [`Stats.collisionPicksCount`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_stylusPicksUpdated'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.stylusPicksUpdated')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of stylus pick intersection that were found in the most recent game loop:     <ul>        <li><code>x</code> = entity intersections.</li>        <li><code>y</code> = avatar intersections.</li>        <li><code>z</code> = HUD intersections.</li>    </ul>    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.stylusPicksUpdated');
    }
};
javascript.javascriptGenerator.forBlock['Stats_stylusPicksUpdated'] = (block, generator) => {
    return [`Stats.stylusPicksUpdated`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_rayPicksUpdated'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.rayPicksUpdated')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of ray pick intersections that were found in the most recent game loop:    <ul>        <li><code>x</code> = entity intersections.</li>        <li><code>y</code> = avatar intersections.</li>        <li><code>z</code> = HUD intersections.</li>    </ul>    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rayPicksUpdated');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rayPicksUpdated'] = (block, generator) => {
    return [`Stats.rayPicksUpdated`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_parabolaPicksUpdated'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.parabolaPicksUpdated')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of parabola pick intersections that were found in the most recent game    loop:    <ul>        <li><code>x</code> = entity intersections.</li>        <li><code>y</code> = avatar intersections.</li>        <li><code>z</code> = HUD intersections.</li>    </ul>    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.parabolaPicksUpdated');
    }
};
javascript.javascriptGenerator.forBlock['Stats_parabolaPicksUpdated'] = (block, generator) => {
    return [`Stats.parabolaPicksUpdated`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_collisionPicksUpdated'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.collisionPicksUpdated')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of collision pick intersections that were found in the most recent game    loop:    <ul>        <li><code>x</code> = entity intersections.</li>        <li><code>y</code> = avatar intersections.</li>        <li><code>z</code> = HUD intersections.</li>    </ul>    <em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.collisionPicksUpdated');
    }
};
javascript.javascriptGenerator.forBlock['Stats_collisionPicksUpdated'] = (block, generator) => {
    return [`Stats.collisionPicksUpdated`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_eventQueueDebuggingOn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.eventQueueDebuggingOn')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<code>true</code> if event queue statistics are provided, <code>false</code> if    they\'re not.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.eventQueueDebuggingOn');
    }
};
javascript.javascriptGenerator.forBlock['Stats_eventQueueDebuggingOn'] = (block, generator) => {
    return [`Stats.eventQueueDebuggingOn`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_mainThreadQueueDepth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.mainThreadQueueDepth')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of events in the main thread\'s event queue.    Only provided if <code>eventQueueDebuggingOn</code> is <code>true</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.mainThreadQueueDepth');
    }
};
javascript.javascriptGenerator.forBlock['Stats_mainThreadQueueDepth'] = (block, generator) => {
    return [`Stats.mainThreadQueueDepth`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_nodeListThreadQueueDepth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.nodeListThreadQueueDepth')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('The number of events in the node list thread\'s event queue.    Only provided if <code>eventQueueDebuggingOn</code> is <code>true</code>.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.nodeListThreadQueueDepth');
    }
};
javascript.javascriptGenerator.forBlock['Stats_nodeListThreadQueueDepth'] = (block, generator) => {
    return [`Stats.nodeListThreadQueueDepth`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_bgColor'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.bgColor')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.bgColor');
    }
};
javascript.javascriptGenerator.forBlock['Stats_bgColor'] = (block, generator) => {
    return [`Stats.bgColor`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_activeFocus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.activeFocus')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.activeFocus');
    }
};
javascript.javascriptGenerator.forBlock['Stats_activeFocus'] = (block, generator) => {
    return [`Stats.activeFocus`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_activeFocusOnTab'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.activeFocusOnTab')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.activeFocusOnTab');
    }
};
javascript.javascriptGenerator.forBlock['Stats_activeFocusOnTab'] = (block, generator) => {
    return [`Stats.activeFocusOnTab`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_anchors'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.anchors')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.anchors');
    }
};
javascript.javascriptGenerator.forBlock['Stats_anchors'] = (block, generator) => {
    return [`Stats.anchors`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_antialiasing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.antialiasing')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.antialiasing');
    }
};
javascript.javascriptGenerator.forBlock['Stats_antialiasing'] = (block, generator) => {
    return [`Stats.antialiasing`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_baselineOffset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.baselineOffset')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.baselineOffset');
    }
};
javascript.javascriptGenerator.forBlock['Stats_baselineOffset'] = (block, generator) => {
    return [`Stats.baselineOffset`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_children'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.children')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<em>Read-only.</em>    <p><strong>Note:</strong> Property not available in the API.</p>    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.children');
    }
};
javascript.javascriptGenerator.forBlock['Stats_children'] = (block, generator) => {
    return [`Stats.children`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_clip'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.clip')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.clip');
    }
};
javascript.javascriptGenerator.forBlock['Stats_clip'] = (block, generator) => {
    return [`Stats.clip`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_containmentMask'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.containmentMask')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.containmentMask');
    }
};
javascript.javascriptGenerator.forBlock['Stats_containmentMask'] = (block, generator) => {
    return [`Stats.containmentMask`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_enabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.enabled')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.enabled');
    }
};
javascript.javascriptGenerator.forBlock['Stats_enabled'] = (block, generator) => {
    return [`Stats.enabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_focus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.focus')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.focus');
    }
};
javascript.javascriptGenerator.forBlock['Stats_focus'] = (block, generator) => {
    return [`Stats.focus`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_height'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.height')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.height');
    }
};
javascript.javascriptGenerator.forBlock['Stats_height'] = (block, generator) => {
    return [`Stats.height`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_implicitHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.implicitHeight')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.implicitHeight');
    }
};
javascript.javascriptGenerator.forBlock['Stats_implicitHeight'] = (block, generator) => {
    return [`Stats.implicitHeight`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_implicitWidth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.implicitWidth')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.implicitWidth');
    }
};
javascript.javascriptGenerator.forBlock['Stats_implicitWidth'] = (block, generator) => {
    return [`Stats.implicitWidth`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_layer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.layer')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<em>Read-only.</em>    <p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.layer');
    }
};
javascript.javascriptGenerator.forBlock['Stats_layer'] = (block, generator) => {
    return [`Stats.layer`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_opacity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.opacity')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.opacity');
    }
};
javascript.javascriptGenerator.forBlock['Stats_opacity'] = (block, generator) => {
    return [`Stats.opacity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_rotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.rotation')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rotation');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rotation'] = (block, generator) => {
    return [`Stats.rotation`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_scale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.scale')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.scale');
    }
};
javascript.javascriptGenerator.forBlock['Stats_scale'] = (block, generator) => {
    return [`Stats.scale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_smooth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.smooth')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.smooth');
    }
};
javascript.javascriptGenerator.forBlock['Stats_smooth'] = (block, generator) => {
    return [`Stats.smooth`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_state'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.state')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.state');
    }
};
javascript.javascriptGenerator.forBlock['Stats_state'] = (block, generator) => {
    return [`Stats.state`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_transformOrigin'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.transformOrigin')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.transformOrigin');
    }
};
javascript.javascriptGenerator.forBlock['Stats_transformOrigin'] = (block, generator) => {
    return [`Stats.transformOrigin`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_visible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.visible')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.visible');
    }
};
javascript.javascriptGenerator.forBlock['Stats_visible'] = (block, generator) => {
    return [`Stats.visible`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_width'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.width')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.width');
    }
};
javascript.javascriptGenerator.forBlock['Stats_width'] = (block, generator) => {
    return [`Stats.width`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_x'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.x')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.x');
    }
};
javascript.javascriptGenerator.forBlock['Stats_x'] = (block, generator) => {
    return [`Stats.x`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_y'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.y')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.y');
    }
};
javascript.javascriptGenerator.forBlock['Stats_y'] = (block, generator) => {
    return [`Stats.y`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Stats_z'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.z')       
        this.setOutput(true, '');
        this.setColour('#452A76');
        this.setTooltip('<p class="important">Deprecated: This property is deprecated and will be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.z');
    }
};
javascript.javascriptGenerator.forBlock['Stats_z'] = (block, generator) => {
    return [`Stats.z`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Stats_forceUpdateStats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Stats.forceUpdateStats')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#452A76');
        this.setTooltip('Updates statistics to make current values available to scripts even though the statistics overlay may not be displayed.(Many statistics values are normally updated only if the statistics overlay is displayed.)<p><strong>Note:</strong> Not all statistics values are updated when the statistics overlay isn\'t displayed or expanded.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.forceUpdateStats');
    }
};
javascript.javascriptGenerator.forBlock['Stats_forceUpdateStats'] = (block, generator) => {


    return `Stats.forceUpdateStats();\n`;};


// Blockly signal
Blockly.Blocks['Stats_expandedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.expandedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>expanded</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.expandedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_expandedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.expandedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_timingExpandedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.timingExpandedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>timingExpanded</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.timingExpandedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_timingExpandedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.timingExpandedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_serverCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.serverCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>serverCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.serverCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_renderrateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.renderrateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>renderrate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.renderrateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_renderrateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.renderrateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_presentrateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.presentrateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>presentrate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.presentrateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_presentrateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.presentrateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_stutterrateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.stutterrateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>stutterrate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.stutterrateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_stutterrateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.stutterrateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_appdroppedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.appdroppedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>appdropped</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.appdroppedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_appdroppedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.appdroppedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_longsubmitsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.longsubmitsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>longsubmits</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.longsubmitsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_longsubmitsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.longsubmitsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_longrendersChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.longrendersChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>longrenders</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.longrendersChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_longrendersChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.longrendersChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_longframesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.longframesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>longframes</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.longframesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_longframesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.longframesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_presentnewrateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.presentnewrateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>presentnewrate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.presentnewrateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_presentnewrateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.presentnewrateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_presentdroprateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.presentdroprateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>presentdroprate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.presentdroprateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_presentdroprateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.presentdroprateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gameLoopRateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gameLoopRateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gameLoopRate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gameLoopRateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gameLoopRateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gameLoopRateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_refreshRateTargetChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.refreshRateTargetChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>refreshRateTarget</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.refreshRateTargetChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_refreshRateTargetChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.refreshRateTargetChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_refreshRateModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.refreshRateModeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>refreshRateMode</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.refreshRateModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_refreshRateModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.refreshRateModeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_refreshRateRegimeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.refreshRateRegimeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>refreshRateRegime</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.refreshRateRegimeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_refreshRateRegimeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.refreshRateRegimeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_uxModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.uxModeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>uxMode</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.uxModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_uxModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.uxModeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_heroAvatarCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.heroAvatarCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>heroAvatarCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.heroAvatarCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_heroAvatarCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.heroAvatarCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_physicsObjectCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.physicsObjectCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>physicsObjectCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.physicsObjectCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_physicsObjectCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.physicsObjectCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_updatedAvatarCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.updatedAvatarCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>updatedAvatarCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.updatedAvatarCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_updatedAvatarCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.updatedAvatarCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_updatedHeroAvatarCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.updatedHeroAvatarCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>updatedHeroAvatarCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.updatedHeroAvatarCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_updatedHeroAvatarCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.updatedHeroAvatarCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_notUpdatedAvatarCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.notUpdatedAvatarCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>notUpdatedAvatarCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.notUpdatedAvatarCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_notUpdatedAvatarCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.notUpdatedAvatarCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_packetInCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.packetInCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>packetInCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.packetInCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_packetInCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.packetInCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_packetOutCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.packetOutCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>packetOutCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.packetOutCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_packetOutCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.packetOutCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_mbpsInChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.mbpsInChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>mbpsIn</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.mbpsInChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_mbpsInChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.mbpsInChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_mbpsOutChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.mbpsOutChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>mbpsOut</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.mbpsOutChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_mbpsOutChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.mbpsOutChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_assetMbpsInChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.assetMbpsInChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>assetMbpsIn</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.assetMbpsInChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_assetMbpsInChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.assetMbpsInChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_assetMbpsOutChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.assetMbpsOutChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>assetMbpsOut</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.assetMbpsOutChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_assetMbpsOutChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.assetMbpsOutChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioPingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioPingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioPing</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioPingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioPingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioPingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarPingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarPingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarPing</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarPingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarPingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarPingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_entitiesPingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.entitiesPingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>entitiesPing</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.entitiesPingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_entitiesPingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.entitiesPingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_assetPingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.assetPingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>assetPing</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.assetPingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_assetPingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.assetPingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_messagePingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.messagePingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>messagePing</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.messagePingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_messagePingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.messagePingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_positionChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.positionChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>position</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.positionChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_positionChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.positionChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_speedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.speedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>speed</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.speedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_speedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.speedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_yawChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.yawChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>yaw</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.yawChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_yawChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.yawChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarMixerInKbpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarMixerInKbpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarMixerInKbps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerInKbpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerInKbpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarMixerInKbpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarMixerInPpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarMixerInPpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarMixerInPps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerInPpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerInPpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarMixerInPpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarMixerOutKbpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarMixerOutKbpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarMixerOutKbps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerOutKbpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerOutKbpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarMixerOutKbpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarMixerOutPpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarMixerOutPpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarMixerOutPps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarMixerOutPpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarMixerOutPpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarMixerOutPpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_myAvatarSendRateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.myAvatarSendRateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>myAvatarSendRate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.myAvatarSendRateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_myAvatarSendRateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.myAvatarSendRateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioMixerInKbpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioMixerInKbpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioMixerInKbps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerInKbpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerInKbpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioMixerInKbpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioMixerInPpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioMixerInPpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioMixerInPps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerInPpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerInPpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioMixerInPpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioMixerOutKbpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioMixerOutKbpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioMixerOutKbps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerOutKbpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerOutKbpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioMixerOutKbpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioMixerOutPpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioMixerOutPpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioMixerOutPps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerOutPpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerOutPpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioMixerOutPpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioMixerKbpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioMixerKbpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioMixerKbps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerKbpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerKbpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioMixerKbpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioMixerPpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioMixerPpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioMixerPps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioMixerPpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioMixerPpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioMixerPpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioOutboundPPSChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioOutboundPPSChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioOutboundPPS</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioOutboundPPSChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioOutboundPPSChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioOutboundPPSChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioSilentOutboundPPSChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioSilentOutboundPPSChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioSilentOutboundPPS</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioSilentOutboundPPSChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioSilentOutboundPPSChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioSilentOutboundPPSChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioInboundPPSChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioInboundPPSChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioInboundPPS</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioInboundPPSChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioInboundPPSChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioInboundPPSChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioSilentInboundPPSChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioSilentInboundPPSChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioSilentInboundPPS</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioSilentInboundPPSChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioSilentInboundPPSChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioSilentInboundPPSChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioPacketLossChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioPacketLossChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioPacketLoss</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioPacketLossChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioPacketLossChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioPacketLossChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioCodecChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioCodecChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioCodec</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioCodecChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioCodecChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioCodecChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioNoiseGateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioNoiseGateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioNoiseGate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioNoiseGateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioNoiseGateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioNoiseGateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_audioInjectorsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.audioInjectorsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>audioInjectors</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.audioInjectorsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_audioInjectorsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.audioInjectorsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_entityPacketsInKbpsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.entityPacketsInKbpsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>entityPacketsInKbps</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.entityPacketsInKbpsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_entityPacketsInKbpsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.entityPacketsInKbpsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_downloadsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.downloadsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>downloads</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.downloadsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_downloadLimitChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.downloadLimitChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>downloadLimit</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadLimitChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadLimitChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.downloadLimitChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_downloadsPendingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.downloadsPendingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>downloadsPending</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadsPendingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadsPendingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.downloadsPendingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_downloadUrlsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.downloadUrlsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>downloadUrls</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.downloadUrlsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_downloadUrlsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.downloadUrlsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_processingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.processingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>processing</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.processingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_processingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.processingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_processingPendingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.processingPendingChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>processingPending</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.processingPendingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_processingPendingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.processingPendingChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_trianglesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.trianglesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>triangles</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.trianglesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_trianglesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.trianglesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_drawcallsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.drawcallsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>drawcalls</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.drawcallsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_drawcallsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.drawcallsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_materialSwitchesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.materialSwitchesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>materialSwitches</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.materialSwitchesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_materialSwitchesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.materialSwitchesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_itemConsideredChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.itemConsideredChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>itemConsidered</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemConsideredChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemConsideredChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.itemConsideredChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_itemOutOfViewChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.itemOutOfViewChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>itemOutOfView</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemOutOfViewChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemOutOfViewChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.itemOutOfViewChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_itemTooSmallChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.itemTooSmallChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>itemTooSmall</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemTooSmallChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemTooSmallChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.itemTooSmallChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_itemRenderedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.itemRenderedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>itemRendered</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.itemRenderedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_itemRenderedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.itemRenderedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_shadowConsideredChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.shadowConsideredChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>shadowConsidered</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowConsideredChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowConsideredChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.shadowConsideredChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_shadowOutOfViewChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.shadowOutOfViewChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>shadowOutOfView</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowOutOfViewChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowOutOfViewChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.shadowOutOfViewChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_shadowTooSmallChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.shadowTooSmallChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>shadowTooSmall</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowTooSmallChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowTooSmallChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.shadowTooSmallChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_shadowRenderedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.shadowRenderedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>shadowRendered</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.shadowRenderedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_shadowRenderedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.shadowRenderedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_sendingModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.sendingModeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>sendingMode</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.sendingModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_sendingModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.sendingModeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_packetStatsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.packetStatsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>packetStats</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.packetStatsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_packetStatsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.packetStatsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_lodAngleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.lodAngleChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>lodAngle</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.lodAngleChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_lodAngleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.lodAngleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_lodTargetFramerateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.lodTargetFramerateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>lodTargetFramerate</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.lodTargetFramerateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_lodTargetFramerateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.lodTargetFramerateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_lodStatusChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.lodStatusChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>lodStatus</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.lodStatusChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_lodStatusChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.lodStatusChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_numEntityUpdatesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.numEntityUpdatesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>numEntityUpdates</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.numEntityUpdatesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_numEntityUpdatesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.numEntityUpdatesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_numNeededEntityUpdatesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.numNeededEntityUpdatesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>numNeededEntityUpdates</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.numNeededEntityUpdatesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_numNeededEntityUpdatesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.numNeededEntityUpdatesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_timingStatsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.timingStatsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>timingStats</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.timingStatsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_timingStatsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.timingStatsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gameUpdateStatsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gameUpdateStatsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gameUpdateStats</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gameUpdateStatsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gameUpdateStatsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gameUpdateStatsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_serverElementsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.serverElementsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>serverElements</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverElementsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverElementsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.serverElementsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_serverInternalChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.serverInternalChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>serverInternal</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverInternalChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverInternalChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.serverInternalChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_serverLeavesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.serverLeavesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>serverLeaves</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.serverLeavesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_serverLeavesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.serverLeavesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_localElementsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.localElementsChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>localElements</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.localElementsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_localElementsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.localElementsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_localInternalChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.localInternalChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>localInternal</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.localInternalChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_localInternalChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.localInternalChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_localLeavesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.localLeavesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>localLeaves</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.localLeavesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_localLeavesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.localLeavesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_rectifiedTextureCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.rectifiedTextureCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>rectifiedTextureCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rectifiedTextureCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rectifiedTextureCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.rectifiedTextureCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_decimatedTextureCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.decimatedTextureCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>decimatedTextureCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.decimatedTextureCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_decimatedTextureCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.decimatedTextureCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuBuffersChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuBuffersChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuBuffers</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuBuffersChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuBuffersChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuBuffersChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuBufferMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuBufferMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuBufferMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuBufferMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuBufferMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuBufferMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTexturesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTexturesChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextures</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTexturesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTexturesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTexturesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_glContextSwapchainMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.glContextSwapchainMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>glContextSwapchainMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.glContextSwapchainMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_glContextSwapchainMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.glContextSwapchainMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_qmlTextureMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.qmlTextureMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>qmlTextureMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.qmlTextureMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_qmlTextureMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.qmlTextureMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_texturePendingTransfersChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.texturePendingTransfersChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>texturePendingTransfers</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.texturePendingTransfersChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_texturePendingTransfersChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.texturePendingTransfersChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureResidentMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureResidentMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureResidentMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResidentMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResidentMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureResidentMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureFramebufferMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureFramebufferMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureFramebufferMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureFramebufferMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureFramebufferMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureFramebufferMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureResourceMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureResourceMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureResourceMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResourceMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResourceMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureResourceMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureResourceIdealMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureResourceIdealMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureResourceIdealMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResourceIdealMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResourceIdealMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureResourceIdealMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureResourcePopulatedMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureResourcePopulatedMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureResourcePopulatedMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureResourcePopulatedMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureResourcePopulatedMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureResourcePopulatedMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureExternalMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureExternalMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureExternalMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureExternalMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureExternalMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureExternalMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuTextureMemoryPressureStateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuTextureMemoryPressureStateChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuTextureMemoryPressureState</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuTextureMemoryPressureStateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuTextureMemoryPressureStateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuTextureMemoryPressureStateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuFreeMemoryChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuFreeMemoryChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuFreeMemory</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFreeMemoryChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFreeMemoryChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuFreeMemoryChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuFrameSizeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuFrameSizeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuFrameSize</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFrameSizeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFrameSizeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuFrameSizeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuFrameTimeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuFrameTimeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuFrameTime</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFrameTimeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFrameTimeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuFrameTimeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_gpuFrameTimePerPixelChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.gpuFrameTimePerPixelChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>gpuFrameTimePerPixel</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.gpuFrameTimePerPixelChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_gpuFrameTimePerPixelChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.gpuFrameTimePerPixelChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_batchFrameTimeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.batchFrameTimeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>batchFrameTime</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.batchFrameTimeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_batchFrameTimeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.batchFrameTimeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_engineFrameTimeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.engineFrameTimeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>engineFrameTime</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.engineFrameTimeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_engineFrameTimeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.engineFrameTimeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_avatarSimulationTimeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.avatarSimulationTimeChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>avatarSimulationTime</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.avatarSimulationTimeChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_avatarSimulationTimeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.avatarSimulationTimeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_stylusPicksCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.stylusPicksCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>stylusPicksCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.stylusPicksCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_stylusPicksCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.stylusPicksCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_rayPicksCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.rayPicksCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>rayPicksCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rayPicksCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rayPicksCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.rayPicksCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_parabolaPicksCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.parabolaPicksCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>parabolaPicksCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.parabolaPicksCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_parabolaPicksCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.parabolaPicksCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_collisionPicksCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.collisionPicksCountChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>collisionPicksCount</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.collisionPicksCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_collisionPicksCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.collisionPicksCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_stylusPicksUpdatedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.stylusPicksUpdatedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>stylusPicksUpdated</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.stylusPicksUpdatedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_stylusPicksUpdatedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.stylusPicksUpdatedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_rayPicksUpdatedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.rayPicksUpdatedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>rayPicksUpdated</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.rayPicksUpdatedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_rayPicksUpdatedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.rayPicksUpdatedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_parabolaPicksUpdatedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.parabolaPicksUpdatedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>parabolaPicksUpdated</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.parabolaPicksUpdatedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_parabolaPicksUpdatedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.parabolaPicksUpdatedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_collisionPicksUpdatedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.collisionPicksUpdatedChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>collisionPicksUpdated</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.collisionPicksUpdatedChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_collisionPicksUpdatedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.collisionPicksUpdatedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_mainThreadQueueDepthChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.mainThreadQueueDepthChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>mainThreadQueueDepth</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.mainThreadQueueDepthChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_mainThreadQueueDepthChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.mainThreadQueueDepthChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_nodeListThreadQueueDepth'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.nodeListThreadQueueDepth');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>nodeListThreadQueueDepth</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.nodeListThreadQueueDepth');
    }
};
javascript.javascriptGenerator.forBlock['Stats_nodeListThreadQueueDepth'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.nodeListThreadQueueDepth.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Stats_eventQueueDebuggingOnChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Stats.eventQueueDebuggingOnChanged');


        this.setColour('#452A76');
        this.setTooltip('Triggered when the value of the <code>eventQueueDebuggingOn</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/Stats.html#.eventQueueDebuggingOnChanged');
    }
};
javascript.javascriptGenerator.forBlock['Stats_eventQueueDebuggingOnChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Stats.eventQueueDebuggingOnChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Overlays_OverlayType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.OverlayType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#2B607F');
        this.setTooltip('<p>An overlay may be one of the following types:</p><table>  <thead>    <tr><th>Value</th><th>2D/3D</th><th>Description</th><th>Properties</th></tr>  </thead>  <tbody>    <tr><td><code>"rectangle"</code></td><td>2D</td>      <td>A rectangle.</td>      <td>{@link Overlays.OverlayProperties-Rectangle|OverlayProperties-Rectangle}</td></tr>    <tr><td><code>"image"</code></td><td>2D</td>      <td>An image.</td>      <td>{@link Overlays.OverlayProperties-Image|OverlayProperties-Image}</td></tr>    <tr><td><code>"text"</code></td><td>2D</td>      <td>Some text.</td>      <td>{@link Overlays.OverlayProperties-Text|OverlayProperties-Text}</td></tr>    <tr><td><code>"cube"</code></td><td>3D</td>      <td><p>A cube. A <code>"shape"</code> overlay can also be used to create a cube.</p>  </tbody></table><p>2D overlays are rendered on the display surface in desktop mode and on the HUD surface in HMD mode. 3D overlays arerendered at a position and orientation in-world.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.OverlayType');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_OverlayType'] = (block, generator) => {

    return [`new Overlays.OverlayType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Overlays_OverlayProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.OverlayProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('type') 
            .setCheck('Overlays.OverlayType')
            .appendField('type');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.setColour('#2B607F');
        this.setTooltip('Different overlay types have different properties: some common to all overlays (listed in the table) and some specific to each {@link Overlays.OverlayType|OverlayType} (linked to below).<p>3D overlays are local entities, internally, so they also support the relevant entity\'s properties.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.OverlayProperties');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_OverlayProperties'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

    return [`new Overlays.OverlayProperties(${_id},${_type},${_visible})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Overlays_OverlayProperties-Image'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.OverlayProperties-Image')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('bounds') 
            .setCheck('Rect')
            .appendField('bounds');
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');
        this.appendValueInput('imageURL') 
            .setCheck('String')
            .appendField('imageURL');
        this.appendValueInput('subImage') 
            .setCheck('Rect')
            .appendField('subImage');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.setColour('#2B607F');
        this.setTooltip('The <code>"image"</code> {@link Overlays.OverlayType|OverlayType} is for 2D images.It has properties in addition to the common {@link Overlays.OverlayProperties|OverlayProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.OverlayProperties-Image');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_OverlayProperties-Image'] = (block, generator) => {
    const _bounds = dfv(generator.valueToCode(block, 'bounds', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _imageURL = dfv(generator.valueToCode(block, 'imageURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _subImage = dfv(generator.valueToCode(block, 'subImage', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);

    return [`new Overlays.OverlayProperties-Image(${_bounds},${_x},${_y},${_width},${_height},${_imageURL},${_subImage},${_color},${_alpha})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Overlays_OverlayProperties-Text'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.OverlayProperties-Text')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('bounds') 
            .setCheck('Rect')
            .appendField('bounds');
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');
        this.appendValueInput('margin') 
            .setCheck('Number')
            .appendField('margin');
        this.appendValueInput('leftMargin') 
            .setCheck('Number')
            .appendField('leftMargin');
        this.appendValueInput('topMargin') 
            .setCheck('Number')
            .appendField('topMargin');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');
        this.appendValueInput('fontsize') 
            .setCheck('Number')
            .appendField('fontsize');
        this.appendValueInput('lineHeight') 
            .setCheck('Number')
            .appendField('lineHeight');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('backgroundColor') 
            .setCheck('Color')
            .appendField('backgroundColor');
        this.appendValueInput('backgroundAlpha') 
            .setCheck('Number')
            .appendField('backgroundAlpha');
        this.setColour('#2B607F');
        this.setTooltip('The <code>"text"</code> {@link Overlays.OverlayType|OverlayType} is for 2D text.It has properties in addition to the common {@link Overlays.OverlayProperties|OverlayProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.OverlayProperties-Text');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_OverlayProperties-Text'] = (block, generator) => {
    const _bounds = dfv(generator.valueToCode(block, 'bounds', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _margin = dfv(generator.valueToCode(block, 'margin', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _leftMargin = dfv(generator.valueToCode(block, 'leftMargin', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _topMargin = dfv(generator.valueToCode(block, 'topMargin', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _fontsize = dfv(generator.valueToCode(block, 'fontsize', javascript.javascriptGenerator.ORDER_ATOMIC), `18`);
    const _lineHeight = dfv(generator.valueToCode(block, 'lineHeight', javascript.javascriptGenerator.ORDER_ATOMIC), `18`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _backgroundColor = dfv(generator.valueToCode(block, 'backgroundColor', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _backgroundAlpha = dfv(generator.valueToCode(block, 'backgroundAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0.7`);

    return [`new Overlays.OverlayProperties-Text(${_bounds},${_x},${_y},${_width},${_height},${_margin},${_leftMargin},${_topMargin},${_text},${_fontsize},${_lineHeight},${_color},${_alpha},${_backgroundColor},${_backgroundAlpha})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Overlays_OverlayProperties-Rectangle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.OverlayProperties-Rectangle')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('bounds') 
            .setCheck('Rect')
            .appendField('bounds');
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('borderWidth') 
            .setCheck('Number')
            .appendField('borderWidth');
        this.appendValueInput('borderColor') 
            .setCheck('Color')
            .appendField('borderColor');
        this.appendValueInput('borderAlpha') 
            .setCheck('Number')
            .appendField('borderAlpha');
        this.setColour('#2B607F');
        this.setTooltip('The <code>"rectangle"</code> {@link Overlays.OverlayType|OverlayType} is for 2D rectangles.It has properties in addition to the common {@link Overlays.OverlayProperties|OverlayProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.OverlayProperties-Rectangle');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_OverlayProperties-Rectangle'] = (block, generator) => {
    const _bounds = dfv(generator.valueToCode(block, 'bounds', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _borderWidth = dfv(generator.valueToCode(block, 'borderWidth', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _borderColor = dfv(generator.valueToCode(block, 'borderColor', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _borderAlpha = dfv(generator.valueToCode(block, 'borderAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);

    return [`new Overlays.OverlayProperties-Rectangle(${_bounds},${_x},${_y},${_width},${_height},${_radius},${_color},${_alpha},${_borderWidth},${_borderColor},${_borderAlpha})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Overlays_RayToOverlayIntersectionResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.RayToOverlayIntersectionResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('overlayID') 
            .setCheck('Uuid')
            .appendField('overlayID');
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.appendValueInput('surfaceNormal') 
            .setCheck('Vec3')
            .appendField('surfaceNormal');
        this.appendValueInput('intersection') 
            .setCheck('Vec3')
            .appendField('intersection');
        this.appendValueInput('extraInfo') 
            .setCheck('object')
            .appendField('extraInfo');
        this.setColour('#2B607F');
        this.setTooltip('The result of a {@link PickRay} search using {@link Overlays.findRayIntersection|findRayIntersection}.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.RayToOverlayIntersectionResult');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_RayToOverlayIntersectionResult'] = (block, generator) => {
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _overlayID = dfv(generator.valueToCode(block, 'overlayID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _surfaceNormal = dfv(generator.valueToCode(block, 'surfaceNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _intersection = dfv(generator.valueToCode(block, 'intersection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extraInfo = dfv(generator.valueToCode(block, 'extraInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Overlays.RayToOverlayIntersectionResult(${_intersects},${_overlayID},${_distance},${_surfaceNormal},${_intersection},${_extraInfo})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Overlays_keyboardFocusOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.keyboardFocusOverlay')       
        this.setOutput(true, '');
        this.setColour('#2B607F');
        this.setTooltip('The <code>{@link Overlays.OverlayProperties-Web3D|"web3d"}</code> overlay    ({@link Entities.EntityProperties-Web|Web} entity) that has keyboard focus. If no overlay (entity) has keyboard focus,    returns <code>null</code>; set to <code>null</code> or {@link Uuid|Uuid.NULL} to clear keyboard focus.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.keyboardFocusOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_keyboardFocusOverlay'] = (block, generator) => {
    return [`Overlays.keyboardFocusOverlay`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Overlays_addOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.addOverlay')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('type') 
            .setCheck('Overlays.OverlayType')
            .appendField('type');
        this.appendValueInput('properties') 
            .setCheck('Overlays.OverlayProperties')
            .appendField('properties');

        this.setColour('#2B607F');
        this.setTooltip('Adds an overlay to the scene.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.addOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_addOverlay'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.addOverlay(${_type},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_cloneOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.cloneOverlay')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#2B607F');
        this.setTooltip('Creates a clone of an existing overlay (or entity).<p>Note: For cloning behavior of 3D overlays and entities, see {@link Entities.cloneEntity}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.cloneOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_cloneOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.cloneOverlay(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_editOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.editOverlay')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('properties') 
            .setCheck('Overlays.OverlayProperties')
            .appendField('properties');

        this.setColour('#2B607F');
        this.setTooltip('Edits an overlay\'s (or entity\'s) properties.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.editOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_editOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.editOverlay(${_id},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_editOverlays'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.editOverlays')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('propertiesById') 
            .setCheck('object.<Uuid, Overlays.OverlayProperties>')
            .appendField('propertiesById');

        this.setColour('#2B607F');
        this.setTooltip('Edits the properties of multiple overlays (or entities).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.editOverlays');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_editOverlays'] = (block, generator) => {
    const _propertiesById = dfv(generator.valueToCode(block, 'propertiesById', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.editOverlays(${_propertiesById})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_deleteOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.deleteOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Deletes an overlay (or entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.deleteOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_deleteOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.deleteOverlay(${_id});\n`;};


// Blockly function
Blockly.Blocks['Overlays_getOverlayType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.getOverlayType')
        // Returns data
        this.setOutput(true, '["Overlays.OverlayType"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#2B607F');
        this.setTooltip('Gets the type of an overlay.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.getOverlayType');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_getOverlayType'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.getOverlayType(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_getOverlayObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.getOverlayObject')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('overlayID') 
            .setCheck('Uuid')
            .appendField('overlayID');

        this.setColour('#2B607F');
        this.setTooltip('Gets an overlay\'s (or entity\'s) script object. In particular, this is useful for accessing a<code>{@link Overlays.OverlayProperties-Web3D|"web3d"}</code> overlay\'s <code>EventBridge</code> script object toexchange messages with the web page script.<p>To send a message from an Interface script to a <code>"web3d"</code> overlay over its event bridge:</p><pre class="prettyprint"><code>var overlayObject = Overlays.getOverlayObject(overlayID);overlayObject.emitScriptEvent(message);</code></pre><p>To receive a message from a <code>"web3d"</code> overlay over its event bridge in an Interface script:</p><pre class="prettyprint"><code>var overlayObject = Overlays.getOverlayObject(overlayID);overlayObject.webEventReceived.connect(function(message) {    ...};</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.getOverlayObject');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_getOverlayObject'] = (block, generator) => {
    const _overlayID = dfv(generator.valueToCode(block, 'overlayID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.getOverlayObject(${_overlayID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_getOverlayAtPoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.getOverlayAtPoint')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('point') 
            .setCheck('Vec2')
            .appendField('point');

        this.setColour('#2B607F');
        this.setTooltip('Gets the ID of the 2D overlay at a particular point on the desktop screen or HUD surface.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.getOverlayAtPoint');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_getOverlayAtPoint'] = (block, generator) => {
    const _point = dfv(generator.valueToCode(block, 'point', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.getOverlayAtPoint(${_point})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_findRayIntersection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.findRayIntersection')
        // Returns data
        this.setOutput(true, '["Overlays.RayToOverlayIntersectionResult"]');

        // Params data
        this.appendValueInput('pickRay') 
            .setCheck('PickRay')
            .appendField('pickRay');
        this.appendValueInput('precisionPicking') 
            .setCheck('Boolean')
            .appendField('precisionPicking');
        this.appendValueInput('include') 
            .setCheck('Array')
            .appendField('include');
        this.appendValueInput('discard') 
            .setCheck('Array')
            .appendField('discard');
        this.appendValueInput('visibleOnly') 
            .setCheck('Boolean')
            .appendField('visibleOnly');
        this.appendValueInput('collideableOnly') 
            .setCheck('Boolean')
            .appendField('collideableOnly');

        this.setColour('#2B607F');
        this.setTooltip('Finds the closest 3D overlay (or local entity) intersected by a {@link PickRay}.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.findRayIntersection');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_findRayIntersection'] = (block, generator) => {
    const _pickRay = dfv(generator.valueToCode(block, 'pickRay', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _precisionPicking = dfv(generator.valueToCode(block, 'precisionPicking', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _include = dfv(generator.valueToCode(block, 'include', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _discard = dfv(generator.valueToCode(block, 'discard', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _visibleOnly = dfv(generator.valueToCode(block, 'visibleOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _collideableOnly = dfv(generator.valueToCode(block, 'collideableOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Overlays.findRayIntersection(${_pickRay},${_precisionPicking},${_include},${_discard},${_visibleOnly},${_collideableOnly})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_findOverlays'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.findOverlays')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');

        this.setColour('#2B607F');
        this.setTooltip('Gets a list of visible 3D overlays (local entities) with bounding boxes that touch a search sphere.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.findOverlays');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_findOverlays'] = (block, generator) => {
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Overlays.findOverlays(${_center},${_radius})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_isLoaded'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.isLoaded')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#2B607F');
        this.setTooltip('Checks whether an overlay\'s (or entity\'s) assets have been loaded. For example, for an<code>{@link Overlays.OverlayProperties-Image|"image"}</code> overlay, the result indicates whether its image has beenloaded.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.isLoaded');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_isLoaded'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.isLoaded(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_textSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.textSize')
        // Returns data
        this.setOutput(true, '["Size"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');

        this.setColour('#2B607F');
        this.setTooltip('Calculates the size of some text in a text overlay (or entity). The overlay (or entity) need not be set visible.<p><strong>Note:</strong> The size of text in a 3D overlay (or entity) cannot be calculated immediately after theoverlay (or entity) is created; a short delay is required while the overlay (or entity) finishes being created.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.textSize');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_textSize'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.textSize(${_id},${_text})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_width'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.width')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#2B607F');
        this.setTooltip('Gets the width of the Interface window or HUD surface.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.width');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_width'] = (block, generator) => {

return [`Overlays.width()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_height'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.height')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#2B607F');
        this.setTooltip('Gets the height of the Interface window or HUD surface.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.height');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_height'] = (block, generator) => {

return [`Overlays.height()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_isAddedOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.isAddedOverlay')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#2B607F');
        this.setTooltip('Checks if an overlay (or entity) exists.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.isAddedOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_isAddedOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Overlays.isAddedOverlay(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_sendMousePressOnOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.sendMousePressOnOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Generates a mouse press event on an overlay (or local entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.sendMousePressOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_sendMousePressOnOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.sendMousePressOnOverlay(${_id},${_event});\n`;};


// Blockly function
Blockly.Blocks['Overlays_sendMouseReleaseOnOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.sendMouseReleaseOnOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Generates a mouse release event on an overlay (or local entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.sendMouseReleaseOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_sendMouseReleaseOnOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.sendMouseReleaseOnOverlay(${_id},${_event});\n`;};


// Blockly function
Blockly.Blocks['Overlays_sendMouseMoveOnOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.sendMouseMoveOnOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Generates a mouse move event on an overlay (or local entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.sendMouseMoveOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_sendMouseMoveOnOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.sendMouseMoveOnOverlay(${_id},${_event});\n`;};


// Blockly function
Blockly.Blocks['Overlays_sendHoverEnterOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.sendHoverEnterOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Generates a hover enter event on an overlay (or local entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.sendHoverEnterOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_sendHoverEnterOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.sendHoverEnterOverlay(${_id},${_event});\n`;};


// Blockly function
Blockly.Blocks['Overlays_sendHoverOverOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.sendHoverOverOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Generates a hover over event on an overlay (or entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.sendHoverOverOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_sendHoverOverOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.sendHoverOverOverlay(${_id},${_event});\n`;};


// Blockly function
Blockly.Blocks['Overlays_sendHoverLeaveOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.sendHoverLeaveOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Generates a hover leave event on an overlay (or local entity).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.sendHoverLeaveOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_sendHoverLeaveOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.sendHoverLeaveOverlay(${_id},${_event});\n`;};


// Blockly function
Blockly.Blocks['Overlays_getKeyboardFocusOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.getKeyboardFocusOverlay')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#2B607F');
        this.setTooltip('Gets the ID of the <code>{@link Overlays.OverlayProperties-Web3D|"web3d"}</code> overlay({@link Entities.EntityProperties-Web|Web} entity) that has keyboard focus.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.getKeyboardFocusOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_getKeyboardFocusOverlay'] = (block, generator) => {

return [`Overlays.getKeyboardFocusOverlay()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Overlays_setKeyboardFocusOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Overlays.setKeyboardFocusOverlay')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2B607F');
        this.setTooltip('Sets the <code>{@link Overlays.OverlayProperties-Web3D|"web3d"}</code> overlay({@link Entities.EntityProperties-Web|Web} entity) that has keyboard focus.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.setKeyboardFocusOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_setKeyboardFocusOverlay'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Overlays.setKeyboardFocusOverlay(${_id});\n`;};


// Blockly signal
Blockly.Blocks['Overlays_overlayDeleted'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.overlayDeleted');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('overlayDeleted_id'), 'id');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when an overlay (or entity) is deleted.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.overlayDeleted');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_overlayDeleted'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));

return `Overlays.overlayDeleted.connect((_id) => { 
  ${id} = _id;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_mousePressOnOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.mousePressOnOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('mousePressOnOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mousePressOnOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse press event occurs on an overlay. Only occurs for 3D overlays (unless you use    {@link Overlays.sendMousePressOnOverlay|sendMousePressOnOverlay} for a 2D overlay).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.mousePressOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_mousePressOnOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.mousePressOnOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_mouseDoublePressOnOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.mouseDoublePressOnOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('mouseDoublePressOnOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseDoublePressOnOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse double press event occurs on an overlay. Only occurs for 3D overlays.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.mouseDoublePressOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_mouseDoublePressOnOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.mouseDoublePressOnOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_mouseReleaseOnOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.mouseReleaseOnOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('mouseReleaseOnOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseReleaseOnOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse release event occurs on an overlay. Only occurs for 3D overlays (unless you use    {@link Overlays.sendMouseReleaseOnOverlay|sendMouseReleaseOnOverlay} for a 2D overlay).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.mouseReleaseOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_mouseReleaseOnOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.mouseReleaseOnOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_mouseMoveOnOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.mouseMoveOnOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('mouseMoveOnOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseMoveOnOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse move event occurs on an overlay. Only occurs for 3D overlays (unless you use    {@link Overlays.sendMouseMoveOnOverlay|sendMouseMoveOnOverlay} for a 2D overlay).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.mouseMoveOnOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_mouseMoveOnOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.mouseMoveOnOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_mousePressOffOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.mousePressOffOverlay');


        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse press event occurs on something other than a 3D overlay.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.mousePressOffOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_mousePressOffOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Overlays.mousePressOffOverlay.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_mouseDoublePressOffOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.mouseDoublePressOffOverlay');


        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse double press event occurs on something other than a 3D overlay.');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.mouseDoublePressOffOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_mouseDoublePressOffOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Overlays.mouseDoublePressOffOverlay.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_hoverEnterOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.hoverEnterOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('hoverEnterOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('hoverEnterOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse cursor starts hovering over an overlay. Only occurs for 3D overlays (unless you use    {@link Overlays.sendHoverEnterOverlay|sendHoverEnterOverlay} for a 2D overlay).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.hoverEnterOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_hoverEnterOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.hoverEnterOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_hoverOverOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.hoverOverOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('hoverOverOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('hoverOverOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse cursor continues hovering over an overlay. Only occurs for 3D overlays (unless you use    {@link Overlays.sendHoverOverOverlay|sendHoverOverOverlay} for a 2D overlay).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.hoverOverOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_hoverOverOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.hoverOverOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Overlays_hoverLeaveOverlay'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Overlays.hoverLeaveOverlay');

        this.appendDummyInput('id')
            .appendField('id:')
            .appendField(new Blockly.FieldVariable('hoverLeaveOverlay_id'), 'id');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('hoverLeaveOverlay_event'), 'event');

        this.setColour('#2B607F');
        this.setTooltip('Triggered when a mouse cursor finishes hovering over an overlay. Only occurs for 3D overlays (unless you use    {@link Overlays.sendHoverLeaveOverlay|sendHoverLeaveOverlay} for a 2D overlay).');
        this.setHelpUrl('https://apidocs.overte.org/Overlays.html#.hoverLeaveOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Overlays_hoverLeaveOverlay'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const id = generator.getVariableName(block.getFieldValue('id'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Overlays.hoverLeaveOverlay.connect((_id,_event) => { 
  ${id} = _id; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['MyAvatar_AnimIKSolutionSource'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.AnimIKSolutionSource')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>Specifies the initial conditions of the IK solver.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>RelaxToUnderPoses</td><td>This is a blend: it is 15/16 <code>PreviousSolution</code>       and 1/16 <code>UnderPoses</code>. This provides some of the benefits of using <code>UnderPoses</code> so that the       underlying animation is still visible, while at the same time converging faster then using the       <code>UnderPoses</code> as the only initial solution.</td></tr>    <tr><td><code>1</code></td><td>RelaxToLimitCenterPoses</td><td>This is a blend: it is 15/16       <code>PreviousSolution</code> and 1/16 <code>LimitCenterPoses</code>. This should converge quickly because it is       close to the previous solution, but still provides the benefits of avoiding limb locking.</td></tr>    <tr><td><code>2</code></td><td>PreviousSolution</td><td>      <p>The IK system will begin to solve from the same position and orientations for each joint that was the result       from the previous frame.</p>      <p>Pros: As the end effectors typically do not move much from frame to frame, this is likely to converge quickly       to a valid solution.</p>      <p>Cons: If the previous solution resulted in an awkward or uncomfortable posture, the next frame will also be       awkward and uncomfortable. It can also result in locked elbows and knees.</p>      </td></tr>    <tr><td><code>3</code></td><td>UnderPoses</td><td>The IK occurs at one of the top-most layers. It has access to the       full posture that was computed via canned animations and blends. We call this animated set of poses the "under       pose". The under poses are what would be visible if IK was completely disabled. Using the under poses as the       initial conditions of the CCD solve will cause some of the animated motion to be blended into the result of the       IK. This can result in very natural results, especially if there are only a few IK targets enabled. On the other       hand, because the under poses might be quite far from the desired end effector, it can converge slowly in some       cases, causing it to never reach the IK target in the allotted number of iterations. Also, in situations where all       of the IK targets are being controlled by external sensors, sometimes starting from the under poses can cause       awkward motions from the underlying animations to leak into the IK result.</td></tr>    <tr><td><code>4</code></td><td>LimitCenterPoses</td><td>This pose is taken to be the center of all the joint       constraints. This can prevent the IK solution from getting locked or stuck at a particular constraint. For       example, if the arm is pointing straight outward from the body, as the end effector moves towards the body, at       some point the elbow should bend to accommodate. However, because the CCD solver is stuck at a local maximum, it       will not rotate the elbow, unless the initial conditions already have the elbow bent, which is the case for       <code>LimitCenterPoses</code>. When all the IK targets are enabled, this result will provide a consistent starting       point for each IK solve, hopefully resulting in a consistent, natural result.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.AnimIKSolutionSource');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_AnimIKSolutionSource'] = (block, generator) => {

    return [`new MyAvatar.AnimIKSolutionSource()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_AnimOverlayBoneSet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.AnimOverlayBoneSet')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>Specifies sets of joints.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>FullBodyBoneSet</td><td>All joints.</td></tr>    <tr><td><code>1</code></td><td>UpperBodyBoneSet</td><td>Only the "Spine" joint and its children.</td></tr>    <tr><td><code>2</code></td><td>LowerBodyBoneSet</td><td>Only the leg joints and their children.</td></tr>    <tr><td><code>3</code></td><td>LeftArmBoneSet</td><td>Joints that are the children of the "LeftShoulder"       joint.</td></tr>    <tr><td><code>4</code></td><td>RightArmBoneSet</td><td>Joints that are the children of the "RightShoulder"       joint.</td></tr>    <tr><td><code>5</code></td><td>AboveTheHeadBoneSet</td><td>Joints that are the children of the "Head"       joint.</td></tr>    <tr><td><code>6</code></td><td>BelowTheHeadBoneSet</td><td>Joints that are NOT the children of the "head"       joint.</td></tr>    <tr><td><code>7</code></td><td>HeadOnlyBoneSet</td><td>The "Head" joint.</td></tr>    <tr><td><code>8</code></td><td>SpineOnlyBoneSet</td><td>The "Spine" joint.</td></tr>    <tr><td><code>9</code></td><td>EmptyBoneSet</td><td>No joints.</td></tr>    <tr><td><code>10</code></td><td>LeftHandBoneSet</td><td>joints that are the children of the "LeftHand"       joint.</td></tr>    <tr><td><code>11</code></td><td>RightHandBoneSet</td><td>Joints that are the children of the "RightHand"       joint.</td></tr>    <tr><td><code>12</code></td><td>HipsOnlyBoneSet</td><td>The "Hips" joint.</td></tr>    <tr><td><code>13</code></td><td>BothFeetBoneSet</td><td>The "LeftFoot" and "RightFoot" joints.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.AnimOverlayBoneSet');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_AnimOverlayBoneSet'] = (block, generator) => {

    return [`new MyAvatar.AnimOverlayBoneSet()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['AnimationCache_numTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.numTotal')       
        this.setOutput(true, '');
        this.setColour('#4533CE');
        this.setTooltip('Total number of total resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.numTotal');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_numTotal'] = (block, generator) => {
    return [`AnimationCache.numTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AnimationCache_numCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.numCached')       
        this.setOutput(true, '');
        this.setColour('#4533CE');
        this.setTooltip('Total number of cached resource. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.numCached');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_numCached'] = (block, generator) => {
    return [`AnimationCache.numCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AnimationCache_sizeTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.sizeTotal')       
        this.setOutput(true, '');
        this.setColour('#4533CE');
        this.setTooltip('Size in bytes of all resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.sizeTotal');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_sizeTotal'] = (block, generator) => {
    return [`AnimationCache.sizeTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AnimationCache_sizeCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.sizeCached')       
        this.setOutput(true, '');
        this.setColour('#4533CE');
        this.setTooltip('Size in bytes of all cached resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.sizeCached');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_sizeCached'] = (block, generator) => {
    return [`AnimationCache.sizeCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AnimationCache_numGlobalQueriesPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.numGlobalQueriesPending')       
        this.setOutput(true, '');
        this.setColour('#4533CE');
        this.setTooltip('Total number of global queries pending (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.numGlobalQueriesPending');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_numGlobalQueriesPending'] = (block, generator) => {
    return [`AnimationCache.numGlobalQueriesPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AnimationCache_numGlobalQueriesLoading'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.numGlobalQueriesLoading')       
        this.setOutput(true, '');
        this.setColour('#4533CE');
        this.setTooltip('Total number of global queries loading (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.numGlobalQueriesLoading');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_numGlobalQueriesLoading'] = (block, generator) => {
    return [`AnimationCache.numGlobalQueriesLoading`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['AnimationCache_getAnimation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.getAnimation')
        // Returns data
        this.setOutput(true, '["AnimationObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#4533CE');
        this.setTooltip('Gets information about an animation resource.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.getAnimation');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_getAnimation'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AnimationCache.getAnimation(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['AnimationObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationObject')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('jointNames') 
            .setCheck('Array')
            .appendField('jointNames');
        this.appendValueInput('frames') 
            .setCheck('Array')
            .appendField('frames');
        this.setColour('#693B65');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Information about an animation resource, created by {@link AnimationCache.getAnimation}.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationObject');
    }
};
javascript.javascriptGenerator.forBlock['AnimationObject'] = (block, generator) => {
    const _jointNames = dfv(generator.valueToCode(block, 'jointNames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _frames = dfv(generator.valueToCode(block, 'frames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new AnimationObject(${_jointNames},${_frames})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['AnimationObject_getJointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationObject.getJointNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#693B65');
        this.setTooltip('Gets the names of the joints that are animated.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationObject.html#.getJointNames');
    }
};
javascript.javascriptGenerator.forBlock['AnimationObject_getJointNames'] = (block, generator) => {

return [`AnimationObject.getJointNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AnimationObject_getFrames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationObject.getFrames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#693B65');
        this.setTooltip('Gets the frames in the animation.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationObject.html#.getFrames');
    }
};
javascript.javascriptGenerator.forBlock['AnimationObject_getFrames'] = (block, generator) => {

return [`AnimationObject.getFrames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['AnimationFrameObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationFrameObject')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('rotations') 
            .setCheck('Array')
            .appendField('rotations');
        this.setColour('#BE1BF7');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Joint rotations in one frame of an {@link AnimationObject}.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationFrameObject');
    }
};
javascript.javascriptGenerator.forBlock['AnimationFrameObject'] = (block, generator) => {
    const _rotations = dfv(generator.valueToCode(block, 'rotations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new AnimationFrameObject(${_rotations})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['AnimationFrameObject_getRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationFrameObject.getRotations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#BE1BF7');
        this.setTooltip('Gets the joint rotations in the animation frame.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationFrameObject.html#.getRotations');
    }
};
javascript.javascriptGenerator.forBlock['AnimationFrameObject_getRotations'] = (block, generator) => {

return [`AnimationFrameObject.getRotations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['MyAvatar_IKTargetType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.IKTargetType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>An IK target type.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>RotationAndPosition</td><td>Attempt to reach the rotation and position end       effector.</td></tr>    <tr><td><code>1</code></td><td>RotationOnly</td><td>Attempt to reach the end effector rotation only.</td></tr>    <tr><td><code>2</code></td><td>HmdHead</td><td>      <p>A special mode of IK that would attempt to prevent unnecessary bending of the spine.</p>      <p class="important">Deprecated: This target type is deprecated and will be removed.</p></td></tr>    <tr><td><code>3</code></td><td>HipsRelativeRotationAndPosition</td><td>Attempt to reach a rotation and position end       effector that is not in absolute rig coordinates but is offset by the avatar hips translation.</td></tr>    <tr><td><code>4</code></td><td>Spline</td><td>Use a cubic Hermite spline to model the human spine. This prevents       kinks in the spine and allows for a small amount of stretch and squash.</td></tr>    <tr><td><code>5</code></td><td>Unknown</td><td>IK is disabled.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.IKTargetType');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_IKTargetType'] = (block, generator) => {

    return [`new MyAvatar.IKTargetType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MyAvatar_AnimStateDictionary'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.AnimStateDictionary')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DC476E');
        this.setTooltip('<p>An <code>AnimStateDictionary</code> object may have the following properties. It may also have other properties, set byscripts.</p><p><strong>Warning:</strong> These properties are subject to change.<table>  <thead>    <tr><th>Name</th><th>Type</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>userAnimNone</code></td><td>boolean</td><td><code>true</code> when no user overrideAnimation is      playing.</td></tr>    <tr><td><code>userAnimA</code></td><td>boolean</td><td><code>true</code> when a user overrideAnimation is      playing.</td></tr>    <tr><td><code>userAnimB</code></td><td>boolean</td><td><code>true</code> when a user overrideAnimation is      playing.</td></tr>    <tr><td><code>sine</code></td><td>number</td><td>Oscillating sine wave.</td></tr>    <tr><td><code>moveForwardSpeed</code></td><td>number</td><td>Controls the blend between the various forward walking      &amp; running animations.</td></tr>    <tr><td><code>moveBackwardSpeed</code></td><td>number</td><td>Controls the blend between the various backward walking      &amp; running animations.</td></tr>    <tr><td><code>moveLateralSpeed</code></td><td>number</td><td>Controls the blend between the various sidestep walking      &amp; running animations.</td></tr>    <tr><td><code>isMovingForward</code></td><td>boolean</td><td><code>true</code> if the avatar is moving      forward.</td></tr>    <tr><td><code>isMovingBackward</code></td><td>boolean</td><td><code>true</code> if the avatar is moving      backward.</td></tr>    <tr><td><code>isMovingRight</code></td><td>boolean</td><td><code>true</code> if the avatar is moving to the      right.</td></tr>    <tr><td><code>isMovingLeft</code></td><td>boolean</td><td><code>true</code> if the avatar is moving to the      left.</td></tr>    <tr><td><code>isMovingRightHmd</code></td><td>boolean</td><td><code>true</code> if the avatar is moving to the right      while the user is in HMD mode.</td></tr>    <tr><td><code>isMovingLeftHmd</code></td><td>boolean</td><td><code>true</code> if the avatar is moving to the left while      the user is in HMD mode.</td></tr>    <tr><td><code>isNotMoving</code></td><td>boolean</td><td><code>true</code> if the avatar is stationary.</td></tr>    <tr><td><code>isTurningRight</code></td><td>boolean</td><td><code>true</code> if the avatar is turning      clockwise.</td></tr>    <tr><td><code>isTurningLeft</code></td><td>boolean</td><td><code>true</code> if the avatar is turning      counter-clockwise.</td></tr>    <tr><td><code>isNotTurning</code></td><td>boolean</td><td><code>true</code> if the avatar is not turning.</td></tr>    <tr><td><code>isFlying</code></td><td>boolean</td><td><code>true</code> if the avatar is flying.</td></tr>    <tr><td><code>isNotFlying</code></td><td>boolean</td><td><code>true</code> if the avatar is not flying.</td></tr>    <tr><td><code>isTakeoffStand</code></td><td>boolean</td><td><code>true</code> if the avatar is about to execute a      standing jump.</td></tr>    <tr><td><code>isTakeoffRun</code></td><td>boolean</td><td><code>true</code> if the avatar is about to execute a running      jump.</td></tr>    <tr><td><code>isNotTakeoff</code></td><td>boolean</td><td><code>true</code> if the avatar is not jumping.</td></tr>    <tr><td><code>isInAirStand</code></td><td>boolean</td><td><code>true</code> if the avatar is in the air after a standing      jump.</td></tr>    <tr><td><code>isInAirRun</code></td><td>boolean</td><td><code>true</code> if the avatar is in the air after a running      jump.</td></tr>    <tr><td><code>isNotInAir</code></td><td>boolean</td><td><code>true</code> if the avatar on the ground.</td></tr>    <tr><td><code>inAirAlpha</code></td><td>number</td><td>Used to interpolate between the up, apex, and down in-air      animations.</td></tr>    <tr><td><code>ikOverlayAlpha</code></td><td>number</td><td>The blend between upper body and spline IK versus the      underlying animation</td></tr>    <tr><td><code>headPosition</code></td><td>{@link Vec3}</td><td>The desired position of the <code>Head</code> joint in      rig coordinates.</td></tr>    <tr><td><code>headRotation</code></td><td>{@link Quat}</td><td>The desired orientation of the <code>Head</code> joint in      rig coordinates.</td></tr>    <tr><td><code>headType</code></td><td>{@link MyAvatar.IKTargetType|IKTargetType}</td><td>The type of IK used for the      head.</td></tr>    <tr><td><code>headWeight</code></td><td>number</td><td>How strongly the head chain blends with the other IK      chains.</td></tr>    <tr><td><code>leftHandPosition</code></td><td>{@link Vec3}</td><td>The desired position of the <code>LeftHand</code>      joint in rig coordinates.</td></tr>    <tr><td><code>leftHandRotation</code></td><td>{@link Quat}</td><td>The desired orientation of the <code>LeftHand</code>      joint in rig coordinates.</td></tr>    <tr><td><code>leftHandType</code></td><td>{@link MyAvatar.IKTargetType|IKTargetType}</td><td>The type of IK used for the      left arm.</td></tr>    <tr><td><code>leftHandPoleVectorEnabled</code></td><td>boolean</td><td>When <code>true</code>, the elbow angle is      controlled by the <code>rightHandPoleVector</code> property value. Otherwise the elbow direction comes from the      underlying animation.</td></tr>    <tr><td><code>leftHandPoleReferenceVector</code></td><td>{@link Vec3}</td><td>The direction of the elbow in the local      coordinate system of the elbow.</td></tr>    <tr><td><code>leftHandPoleVector</code></td><td>{@link Vec3}</td><td>The direction the elbow should point in rig      coordinates.</td></tr>    <tr><td><code>rightHandPosition</code></td><td>{@link Vec3}</td><td>The desired position of the <code>RightHand</code>      joint in rig coordinates.</td></tr>    <tr><td><code>rightHandRotation</code></td><td>{@link Quat}</td><td>The desired orientation of the      <code>RightHand</code> joint in rig coordinates.</td></tr>    <tr><td><code>rightHandType</code></td><td>{@link MyAvatar.IKTargetType|IKTargetType}</td><td>The type of IK used for      the right arm.</td></tr>    <tr><td><code>rightHandPoleVectorEnabled</code></td><td>boolean</td><td>When <code>true</code>, the elbow angle is      controlled by the <code>rightHandPoleVector</code> property value. Otherwise the elbow direction comes from the      underlying animation.</td></tr>    <tr><td><code>rightHandPoleReferenceVector</code></td><td>{@link Vec3}</td><td>The direction of the elbow in the local      coordinate system of the elbow.</td></tr>    <tr><td><code>rightHandPoleVector</code></td><td>{@link Vec3}</td><td>The direction the elbow should point in rig      coordinates.</td></tr>    <tr><td><code>leftFootIKEnabled</code></td><td>boolean</td><td><code>true</code> if IK is enabled for the left      foot.</td></tr>    <tr><td><code>rightFootIKEnabled</code></td><td>boolean</td><td><code>true</code> if IK is enabled for the right      foot.</td></tr>    <tr><td><code>leftFootIKPositionVar</code></td><td>string</td><td>The name of the source for the desired position      of the <code>LeftFoot</code> joint. If not set, the foot rotation of the underlying animation will be used.</td></tr>    <tr><td><code>leftFootIKRotationVar</code></td><td>string</td><td>The name of the source for the desired rotation      of the <code>LeftFoot</code> joint. If not set, the foot rotation of the underlying animation will be used.</td></tr>    <tr><td><code>leftFootPoleVectorEnabled</code></td><td>boolean</td><td>When <code>true</code>, the knee angle is      controlled by the <code>leftFootPoleVector</code> property value. Otherwise the knee direction comes from the      underlying animation.</td></tr>    <tr><td><code>leftFootPoleVector</code></td><td>{@link Vec3}</td><td>The direction the knee should face in rig      coordinates.</td></tr>    <tr><td><code>rightFootIKPositionVar</code></td><td>string</td><td>The name of the source for the desired position      of the <code>RightFoot</code> joint. If not set, the foot rotation of the underlying animation will be used.</td></tr>    <tr><td><code>rightFootIKRotationVar</code></td><td>string</td><td>The name of the source for the desired rotation      of the <code>RightFoot</code> joint. If not set, the foot rotation of the underlying animation will be used.</td></tr>    <tr><td><code>rightFootPoleVectorEnabled</code></td><td>boolean</td><td>When <code>true</code>, the knee angle is      controlled by the <code>rightFootPoleVector</code> property value. Otherwise the knee direction comes from the      underlying animation.</td></tr>    <tr><td><code>rightFootPoleVector</code></td><td>{@link Vec3}</td><td>The direction the knee should face in rig      coordinates.</td></tr>    <tr><td><code>isTalking</code></td><td>boolean</td><td><code>true</code> if the avatar is talking.</td></tr>    <tr><td><code>notIsTalking</code></td><td>boolean</td><td><code>true</code> if the avatar is not talking.</td></tr>    <tr><td><code>solutionSource</code></td><td>{@link MyAvatar.AnimIKSolutionSource|AnimIKSolutionSource}</td>      <td>Determines the initial conditions of the IK solver.</td></tr>    <tr><td><code>defaultPoseOverlayAlpha</code></td><td>number</td><td>Controls the blend between the main animation state      machine and the default pose. Mostly used during full body tracking so that walking &amp; jumping animations do not      affect the IK of the figure.</td></tr>    <tr><td><code>defaultPoseOverlayBoneSet</code></td><td>{@link MyAvatar.AnimOverlayBoneSet|AnimOverlayBoneSet}</td>      <td>Specifies which bones will be replace by the source overlay.</td></tr>    <tr><td><code>hipsType</code></td><td>{@link MyAvatar.IKTargetType|IKTargetType}</td><td>The type of IK used for the      hips.</td></tr>    <tr><td><code>hipsPosition</code></td><td>{@link Vec3}</td><td>The desired position of <code>Hips</code> joint in rig      coordinates.</td></tr>    <tr><td><code>hipsRotation</code></td><td>{@link Quat}</td><td>the desired orientation of the <code>Hips</code> joint in      rig coordinates.</td></tr>    <tr><td><code>spine2Type</code></td><td>{@link MyAvatar.IKTargetType|IKTargetType}</td><td>The type of IK used for the      <code>Spine2</code> joint.</td></tr>    <tr><td><code>spine2Position</code></td><td>{@link Vec3}</td><td>The desired position of the <code>Spine2</code> joint      in rig coordinates.</td></tr>    <tr><td><code>spine2Rotation</code></td><td>{@link Quat}</td><td>The desired orientation of the <code>Spine2</code>      joint in rig coordinates.</td></tr>    <tr><td><code>leftFootIKAlpha</code></td><td>number</td><td>Blends between full IK for the leg and the underlying      animation.</td></tr>    <tr><td><code>rightFootIKAlpha</code></td><td>number</td><td>Blends between full IK for the leg and the underlying      animation.</td></tr>    <tr><td><code>hipsWeight</code></td><td>number</td><td>How strongly the hips target blends with the IK solution for      other IK chains.</td></tr>    <tr><td><code>leftHandWeight</code></td><td>number</td><td>How strongly the left hand blends with IK solution of other       IK chains.</td></tr>    <tr><td><code>rightHandWeight</code></td><td>number</td><td>How strongly the right hand blends with IK solution of other      IK chains.</td></tr>    <tr><td><code>spine2Weight</code></td><td>number</td><td>How strongly the spine2 chain blends with the rest of the IK      solution.</td></tr>    <tr><td><code>leftHandOverlayAlpha</code></td><td>number</td><td>Used to blend in the animated hand gesture poses, such      as point and thumbs up.</td></tr>    <tr><td><code>leftHandGraspAlpha</code></td><td>number</td><td>Used to blend between an open hand and a closed hand.      Usually changed as you squeeze the trigger of the hand controller.</td></tr>    <tr><td><code>rightHandOverlayAlpha</code></td><td>number</td><td>Used to blend in the animated hand gesture poses,      such as point and thumbs up.</td></tr>    <tr><td><code>rightHandGraspAlpha</code></td><td>number</td><td>Used to blend between an open hand and a closed hand.      Usually changed as you squeeze the trigger of the hand controller.</td></tr>    <tr><td><code>isLeftIndexPoint</code></td><td>boolean</td><td><code>true</code> if the left hand should be      pointing.</td></tr>    <tr><td><code>isLeftThumbRaise</code></td><td>boolean</td><td><code>true</code> if the left hand should be      thumbs-up.</td></tr>    <tr><td><code>isLeftIndexPointAndThumbRaise</code></td><td>boolean</td><td><code>true</code> if the left hand should be      pointing and thumbs-up.</td></tr>    <tr><td><code>isLeftHandGrasp</code></td><td>boolean</td><td><code>true</code> if the left hand should be at rest,      grasping the controller.</td></tr>    <tr><td><code>isRightIndexPoint</code></td><td>boolean</td><td><code>true</code> if the right hand should be      pointing.</td></tr>    <tr><td><code>isRightThumbRaise</code></td><td>boolean</td><td><code>true</code> if the right hand should be      thumbs-up.</td></tr>    <tr><td><code>isRightIndexPointAndThumbRaise</code></td><td>boolean</td><td><code>true</code> if the right hand should      be pointing and thumbs-up.</td></tr>    <tr><td><code>isRightHandGrasp</code></td><td>boolean</td><td><code>true</code> if the right hand should be at rest,      grasping the controller.</td></tr>  </tbody></table><p>Note: Rig coordinates are <code>+z</code> forward and <code>+y</code> up.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.AnimStateDictionary');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_AnimStateDictionary'] = (block, generator) => {

    return [`new MyAvatar.AnimStateDictionary()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['AudioStats_AudioStreamStats'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.AudioStreamStats')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dropCount') 
            .setCheck('Number')
            .appendField('dropCount');
        this.appendValueInput('framesAvailable') 
            .setCheck('Number')
            .appendField('framesAvailable');
        this.appendValueInput('framesAvailableAvg') 
            .setCheck('Number')
            .appendField('framesAvailableAvg');
        this.appendValueInput('framesDesired') 
            .setCheck('Number')
            .appendField('framesDesired');
        this.appendValueInput('lastStarveDurationCount') 
            .setCheck('Number')
            .appendField('lastStarveDurationCount');
        this.appendValueInput('lossCount') 
            .setCheck('Number')
            .appendField('lossCount');
        this.appendValueInput('lossCountWindow') 
            .setCheck('Number')
            .appendField('lossCountWindow');
        this.appendValueInput('lossRate') 
            .setCheck('Number')
            .appendField('lossRate');
        this.appendValueInput('lossRateWindow') 
            .setCheck('Number')
            .appendField('lossRateWindow');
        this.appendValueInput('overflowCount') 
            .setCheck('Number')
            .appendField('overflowCount');
        this.appendValueInput('starveCount') 
            .setCheck('Number')
            .appendField('starveCount');
        this.appendValueInput('timegapMsAvg') 
            .setCheck('Number')
            .appendField('timegapMsAvg');
        this.appendValueInput('timegapMsAvgWindow') 
            .setCheck('Number')
            .appendField('timegapMsAvgWindow');
        this.appendValueInput('timegapMsMax') 
            .setCheck('Number')
            .appendField('timegapMsMax');
        this.appendValueInput('timegapMsMaxWindow') 
            .setCheck('Number')
            .appendField('timegapMsMaxWindow');
        this.appendValueInput('unplayedMsMax') 
            .setCheck('Number')
            .appendField('unplayedMsMax');
        this.setColour('#8678BB');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>Statistics for an audio stream.<p>Provided in properties of the {@link AudioStats} API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats'] = (block, generator) => {
    const _dropCount = dfv(generator.valueToCode(block, 'dropCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _framesAvailable = dfv(generator.valueToCode(block, 'framesAvailable', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _framesAvailableAvg = dfv(generator.valueToCode(block, 'framesAvailableAvg', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _framesDesired = dfv(generator.valueToCode(block, 'framesDesired', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastStarveDurationCount = dfv(generator.valueToCode(block, 'lastStarveDurationCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lossCount = dfv(generator.valueToCode(block, 'lossCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lossCountWindow = dfv(generator.valueToCode(block, 'lossCountWindow', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lossRate = dfv(generator.valueToCode(block, 'lossRate', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lossRateWindow = dfv(generator.valueToCode(block, 'lossRateWindow', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _overflowCount = dfv(generator.valueToCode(block, 'overflowCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _starveCount = dfv(generator.valueToCode(block, 'starveCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _timegapMsAvg = dfv(generator.valueToCode(block, 'timegapMsAvg', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _timegapMsAvgWindow = dfv(generator.valueToCode(block, 'timegapMsAvgWindow', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _timegapMsMax = dfv(generator.valueToCode(block, 'timegapMsMax', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _timegapMsMaxWindow = dfv(generator.valueToCode(block, 'timegapMsMaxWindow', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _unplayedMsMax = dfv(generator.valueToCode(block, 'unplayedMsMax', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new AudioStats.AudioStreamStats(${_dropCount},${_framesAvailable},${_framesAvailableAvg},${_framesDesired},${_lastStarveDurationCount},${_lossCount},${_lossCountWindow},${_lossRate},${_lossRateWindow},${_overflowCount},${_starveCount},${_timegapMsAvg},${_timegapMsAvgWindow},${_timegapMsMax},${_timegapMsMaxWindow},${_unplayedMsMax})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_lossRateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.lossRateChanged');

        this.appendDummyInput('lossRate')
            .appendField('lossRate:')
            .appendField(new Blockly.FieldVariable('lossRateChanged_lossRate'), 'lossRate');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the ratio of the total number of audio packets lost to the total number of audio packets expected changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.lossRateChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_lossRateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const lossRate = generator.getVariableName(block.getFieldValue('lossRate'));

return `AudioStats.AudioStreamStats.lossRateChanged.connect((_lossRate) => { 
  ${lossRate} = _lossRate;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_lossCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.lossCountChanged');

        this.appendDummyInput('lossCount')
            .appendField('lossCount:')
            .appendField(new Blockly.FieldVariable('lossCountChanged_lossCount'), 'lossCount');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the total number of audio packets lost changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.lossCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_lossCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const lossCount = generator.getVariableName(block.getFieldValue('lossCount'));

return `AudioStats.AudioStreamStats.lossCountChanged.connect((_lossCount) => { 
  ${lossCount} = _lossCount;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_lossRateWindowChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.lossRateWindowChanged');

        this.appendDummyInput('lossRateWindow')
            .appendField('lossRateWindow:')
            .appendField(new Blockly.FieldVariable('lossRateWindowChanged_lossRateWindow'), 'lossRateWindow');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the ratio of the number of audio packets lost to the number of audio packets expected since the previous statistic changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.lossRateWindowChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_lossRateWindowChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const lossRateWindow = generator.getVariableName(block.getFieldValue('lossRateWindow'));

return `AudioStats.AudioStreamStats.lossRateWindowChanged.connect((_lossRateWindow) => { 
  ${lossRateWindow} = _lossRateWindow;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_lossCountWindowChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.lossCountWindowChanged');

        this.appendDummyInput('lossCountWindow')
            .appendField('lossCountWindow:')
            .appendField(new Blockly.FieldVariable('lossCountWindowChanged_lossCountWindow'), 'lossCountWindow');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the number of audio packets lost since the previous statistic changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.lossCountWindowChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_lossCountWindowChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const lossCountWindow = generator.getVariableName(block.getFieldValue('lossCountWindow'));

return `AudioStats.AudioStreamStats.lossCountWindowChanged.connect((_lossCountWindow) => { 
  ${lossCountWindow} = _lossCountWindow;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_framesDesiredChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.framesDesiredChanged');

        this.appendDummyInput('framesDesired')
            .appendField('framesDesired:')
            .appendField(new Blockly.FieldVariable('framesDesiredChanged_framesDesired'), 'framesDesired');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the desired number of audio frames for the jitter buffer changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.framesDesiredChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_framesDesiredChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const framesDesired = generator.getVariableName(block.getFieldValue('framesDesired'));

return `AudioStats.AudioStreamStats.framesDesiredChanged.connect((_framesDesired) => { 
  ${framesDesired} = _framesDesired;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_framesAvailableChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.framesAvailableChanged');

        this.appendDummyInput('framesAvailable')
            .appendField('framesAvailable:')
            .appendField(new Blockly.FieldVariable('framesAvailableChanged_framesAvailable'), 'framesAvailable');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the number of audio frames containing data available changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.framesAvailableChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_framesAvailableChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const framesAvailable = generator.getVariableName(block.getFieldValue('framesAvailable'));

return `AudioStats.AudioStreamStats.framesAvailableChanged.connect((_framesAvailable) => { 
  ${framesAvailable} = _framesAvailable;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_framesAvailableAvgChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.framesAvailableAvgChanged');

        this.appendDummyInput('framesAvailableAvg')
            .appendField('framesAvailableAvg:')
            .appendField(new Blockly.FieldVariable('framesAvailableAvgChanged_framesAvailableAvg'), 'framesAvailableAvg');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the time-weighted average of audio frames containing data available changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.framesAvailableAvgChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_framesAvailableAvgChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const framesAvailableAvg = generator.getVariableName(block.getFieldValue('framesAvailableAvg'));

return `AudioStats.AudioStreamStats.framesAvailableAvgChanged.connect((_framesAvailableAvg) => { 
  ${framesAvailableAvg} = _framesAvailableAvg;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_unplayedMsMaxChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.unplayedMsMaxChanged');

        this.appendDummyInput('unplayedMsMax')
            .appendField('unplayedMsMax:')
            .appendField(new Blockly.FieldVariable('unplayedMsMaxChanged_unplayedMsMax'), 'unplayedMsMax');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the duration of audio waiting to be played changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.unplayedMsMaxChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_unplayedMsMaxChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const unplayedMsMax = generator.getVariableName(block.getFieldValue('unplayedMsMax'));

return `AudioStats.AudioStreamStats.unplayedMsMaxChanged.connect((_unplayedMsMax) => { 
  ${unplayedMsMax} = _unplayedMsMax;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_starveCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.starveCountChanged');

        this.appendDummyInput('starveCount')
            .appendField('starveCount:')
            .appendField(new Blockly.FieldVariable('starveCountChanged_starveCount'), 'starveCount');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the total number of times that audio frames have not been available for processing changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.starveCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_starveCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const starveCount = generator.getVariableName(block.getFieldValue('starveCount'));

return `AudioStats.AudioStreamStats.starveCountChanged.connect((_starveCount) => { 
  ${starveCount} = _starveCount;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_lastStarveDurationCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.lastStarveDurationCountChanged');

        this.appendDummyInput('lastStarveDurationCount')
            .appendField('lastStarveDurationCount:')
            .appendField(new Blockly.FieldVariable('lastStarveDurationCountChanged_lastStarveDurationCount'), 'lastStarveDurationCount');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the most recenbernumber of consecutive times that audio frames have not been available for processing changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.lastStarveDurationCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_lastStarveDurationCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const lastStarveDurationCount = generator.getVariableName(block.getFieldValue('lastStarveDurationCount'));

return `AudioStats.AudioStreamStats.lastStarveDurationCountChanged.connect((_lastStarveDurationCount) => { 
  ${lastStarveDurationCount} = _lastStarveDurationCount;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_dropCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.dropCountChanged');

        this.appendDummyInput('dropCount')
            .appendField('dropCount:')
            .appendField(new Blockly.FieldVariable('dropCountChanged_dropCount'), 'dropCount');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the number of silent or old audio frames dropped changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.dropCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_dropCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const dropCount = generator.getVariableName(block.getFieldValue('dropCount'));

return `AudioStats.AudioStreamStats.dropCountChanged.connect((_dropCount) => { 
  ${dropCount} = _dropCount;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_overflowCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.overflowCountChanged');

        this.appendDummyInput('overflowCount')
            .appendField('overflowCount:')
            .appendField(new Blockly.FieldVariable('overflowCountChanged_overflowCount'), 'overflowCount');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the number of times that the audio ring buffer has overflowed changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.overflowCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_overflowCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const overflowCount = generator.getVariableName(block.getFieldValue('overflowCount'));

return `AudioStats.AudioStreamStats.overflowCountChanged.connect((_overflowCount) => { 
  ${overflowCount} = _overflowCount;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_timegapMsMaxChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.timegapMsMaxChanged');

        this.appendDummyInput('timegapMsMax')
            .appendField('timegapMsMax:')
            .appendField(new Blockly.FieldVariable('timegapMsMaxChanged_timegapMsMax'), 'timegapMsMax');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the overall maximum time between data packets changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.timegapMsMaxChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_timegapMsMaxChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const timegapMsMax = generator.getVariableName(block.getFieldValue('timegapMsMax'));

return `AudioStats.AudioStreamStats.timegapMsMaxChanged.connect((_timegapMsMax) => { 
  ${timegapMsMax} = _timegapMsMax;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_timegapMsAvgChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.timegapMsAvgChanged');

        this.appendDummyInput('timegapMsAvg')
            .appendField('timegapMsAvg:')
            .appendField(new Blockly.FieldVariable('timegapMsAvgChanged_timegapMsAvg'), 'timegapMsAvg');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the overall average time between data packets changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.timegapMsAvgChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_timegapMsAvgChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const timegapMsAvg = generator.getVariableName(block.getFieldValue('timegapMsAvg'));

return `AudioStats.AudioStreamStats.timegapMsAvgChanged.connect((_timegapMsAvg) => { 
  ${timegapMsAvg} = _timegapMsAvg;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_timegapMsMaxWindowChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.timegapMsMaxWindowChanged');

        this.appendDummyInput('timegapMsMaxWindow')
            .appendField('timegapMsMaxWindow:')
            .appendField(new Blockly.FieldVariable('timegapMsMaxWindowChanged_timegapMsMaxWindow'), 'timegapMsMaxWindow');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the recent maximum time between data packets changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.timegapMsMaxWindowChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_timegapMsMaxWindowChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const timegapMsMaxWindow = generator.getVariableName(block.getFieldValue('timegapMsMaxWindow'));

return `AudioStats.AudioStreamStats.timegapMsMaxWindowChanged.connect((_timegapMsMaxWindow) => { 
  ${timegapMsMaxWindow} = _timegapMsMaxWindow;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_AudioStreamStats_timegapMsAvgWindowChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.AudioStreamStats.timegapMsAvgWindowChanged');

        this.appendDummyInput('timegapMsAvgWindow')
            .appendField('timegapMsAvgWindow:')
            .appendField(new Blockly.FieldVariable('timegapMsAvgWindowChanged_timegapMsAvgWindow'), 'timegapMsAvgWindow');

        this.setColour('#149F0B');
        this.setTooltip('Triggered when the recent average time between data packets changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.AudioStreamStats.html#.timegapMsAvgWindowChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_AudioStreamStats_timegapMsAvgWindowChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const timegapMsAvgWindow = generator.getVariableName(block.getFieldValue('timegapMsAvgWindow'));

return `AudioStats.AudioStreamStats.timegapMsAvgWindowChanged.connect((_timegapMsAvgWindow) => { 
  ${timegapMsAvgWindow} = _timegapMsAvgWindow;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['AudioStats_clientStream'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.clientStream')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('Statistics of the client\'s audio stream.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.clientStream');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_clientStream'] = (block, generator) => {
    return [`AudioStats.clientStream`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_inputReadMsMax'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.inputReadMsMax')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The maximum duration of a block of audio data recently read from the microphone, in     ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.inputReadMsMax');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_inputReadMsMax'] = (block, generator) => {
    return [`AudioStats.inputReadMsMax`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_inputUnplayedMsMax'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.inputUnplayedMsMax')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The maximum duration of microphone audio recently in the input buffer waiting to     be played, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.inputUnplayedMsMax');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_inputUnplayedMsMax'] = (block, generator) => {
    return [`AudioStats.inputUnplayedMsMax`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_mixerStream'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.mixerStream')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('Statistics of the audio mixer\'s stream.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.mixerStream');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_mixerStream'] = (block, generator) => {
    return [`AudioStats.mixerStream`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_outputUnplayedMsMax'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.outputUnplayedMsMax')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The maximum duration of output audio recently in the output buffer waiting to     be played, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.outputUnplayedMsMax');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_outputUnplayedMsMax'] = (block, generator) => {
    return [`AudioStats.outputUnplayedMsMax`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_pingMs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.pingMs')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The current ping time to the audio mixer, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.pingMs');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_pingMs'] = (block, generator) => {
    return [`AudioStats.pingMs`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_sentTimegapMsAvg'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.sentTimegapMsAvg')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The overall average time between sending data packets to the audio mixer, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsAvg');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsAvg'] = (block, generator) => {
    return [`AudioStats.sentTimegapMsAvg`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_sentTimegapMsAvgWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.sentTimegapMsAvgWindow')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The recent average time between sending data packets to the audio mixer, in     ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsAvgWindow');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsAvgWindow'] = (block, generator) => {
    return [`AudioStats.sentTimegapMsAvgWindow`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_sentTimegapMsMax'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.sentTimegapMsMax')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The overall maximum time between sending data packets to the audio mixer, in ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsMax');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsMax'] = (block, generator) => {
    return [`AudioStats.sentTimegapMsMax`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['AudioStats_sentTimegapMsMaxWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioStats.sentTimegapMsMaxWindow')       
        this.setOutput(true, '');
        this.setColour('#8678BB');
        this.setTooltip('The recent maximum time between sending data packets to the audio mixer, in     ms.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsMaxWindow');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsMaxWindow'] = (block, generator) => {
    return [`AudioStats.sentTimegapMsMaxWindow`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly signal
Blockly.Blocks['AudioStats_pingMsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.pingMsChanged');

        this.appendDummyInput('pingMs')
            .appendField('pingMs:')
            .appendField(new Blockly.FieldVariable('pingMsChanged_pingMs'), 'pingMs');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the ping time to the audio mixer changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.pingMsChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_pingMsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const pingMs = generator.getVariableName(block.getFieldValue('pingMs'));

return `AudioStats.pingMsChanged.connect((_pingMs) => { 
  ${pingMs} = _pingMs;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_inputReadMsMaxChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.inputReadMsMaxChanged');

        this.appendDummyInput('inputReadMsMax')
            .appendField('inputReadMsMax:')
            .appendField(new Blockly.FieldVariable('inputReadMsMaxChanged_inputReadMsMax'), 'inputReadMsMax');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the maximum duration of a block of audio data recently read from the microphone changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.inputReadMsMaxChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_inputReadMsMaxChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const inputReadMsMax = generator.getVariableName(block.getFieldValue('inputReadMsMax'));

return `AudioStats.inputReadMsMaxChanged.connect((_inputReadMsMax) => { 
  ${inputReadMsMax} = _inputReadMsMax;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_inputUnplayedMsMaxChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.inputUnplayedMsMaxChanged');

        this.appendDummyInput('inputUnplayedMsMax')
            .appendField('inputUnplayedMsMax:')
            .appendField(new Blockly.FieldVariable('inputUnplayedMsMaxChanged_inputUnplayedMsMax'), 'inputUnplayedMsMax');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the maximum duration of microphone audio recently in the input buffer waiting to be played changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.inputUnplayedMsMaxChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_inputUnplayedMsMaxChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const inputUnplayedMsMax = generator.getVariableName(block.getFieldValue('inputUnplayedMsMax'));

return `AudioStats.inputUnplayedMsMaxChanged.connect((_inputUnplayedMsMax) => { 
  ${inputUnplayedMsMax} = _inputUnplayedMsMax;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_outputUnplayedMsMaxChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.outputUnplayedMsMaxChanged');

        this.appendDummyInput('outputUnplayedMsMax')
            .appendField('outputUnplayedMsMax:')
            .appendField(new Blockly.FieldVariable('outputUnplayedMsMaxChanged_outputUnplayedMsMax'), 'outputUnplayedMsMax');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the maximum duration of output audio recently in the output buffer waiting to be played changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.outputUnplayedMsMaxChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_outputUnplayedMsMaxChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const outputUnplayedMsMax = generator.getVariableName(block.getFieldValue('outputUnplayedMsMax'));

return `AudioStats.outputUnplayedMsMaxChanged.connect((_outputUnplayedMsMax) => { 
  ${outputUnplayedMsMax} = _outputUnplayedMsMax;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_sentTimegapMsMaxChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.sentTimegapMsMaxChanged');

        this.appendDummyInput('sentTimegapMsMax')
            .appendField('sentTimegapMsMax:')
            .appendField(new Blockly.FieldVariable('sentTimegapMsMaxChanged_sentTimegapMsMax'), 'sentTimegapMsMax');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the overall maximum time between sending data packets to the audio mixer changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsMaxChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsMaxChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sentTimegapMsMax = generator.getVariableName(block.getFieldValue('sentTimegapMsMax'));

return `AudioStats.sentTimegapMsMaxChanged.connect((_sentTimegapMsMax) => { 
  ${sentTimegapMsMax} = _sentTimegapMsMax;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_sentTimegapMsAvgChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.sentTimegapMsAvgChanged');

        this.appendDummyInput('sentTimegapMsAvg')
            .appendField('sentTimegapMsAvg:')
            .appendField(new Blockly.FieldVariable('sentTimegapMsAvgChanged_sentTimegapMsAvg'), 'sentTimegapMsAvg');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the overall average time between sending data packets to the audio mixer changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsAvgChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsAvgChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sentTimegapMsAvg = generator.getVariableName(block.getFieldValue('sentTimegapMsAvg'));

return `AudioStats.sentTimegapMsAvgChanged.connect((_sentTimegapMsAvg) => { 
  ${sentTimegapMsAvg} = _sentTimegapMsAvg;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_sentTimegapMsMaxWindowChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.sentTimegapMsMaxWindowChanged');

        this.appendDummyInput('sentTimegapMsMaxWindow')
            .appendField('sentTimegapMsMaxWindow:')
            .appendField(new Blockly.FieldVariable('sentTimegapMsMaxWindowChanged_sentTimegapMsMaxWindow'), 'sentTimegapMsMaxWindow');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the recent maximum time between sending data packets to the audio mixer changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsMaxWindowChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsMaxWindowChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sentTimegapMsMaxWindow = generator.getVariableName(block.getFieldValue('sentTimegapMsMaxWindow'));

return `AudioStats.sentTimegapMsMaxWindowChanged.connect((_sentTimegapMsMaxWindow) => { 
  ${sentTimegapMsMaxWindow} = _sentTimegapMsMaxWindow;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_sentTimegapMsAvgWindowChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.sentTimegapMsAvgWindowChanged');

        this.appendDummyInput('sentTimegapMsAvgWindow')
            .appendField('sentTimegapMsAvgWindow:')
            .appendField(new Blockly.FieldVariable('sentTimegapMsAvgWindowChanged_sentTimegapMsAvgWindow'), 'sentTimegapMsAvgWindow');

        this.setColour('#8678BB');
        this.setTooltip('Triggered when the recent average time between sending data packets to the audio mixer changes.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.sentTimegapMsAvgWindowChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_sentTimegapMsAvgWindowChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sentTimegapMsAvgWindow = generator.getVariableName(block.getFieldValue('sentTimegapMsAvgWindow'));

return `AudioStats.sentTimegapMsAvgWindowChanged.connect((_sentTimegapMsAvgWindow) => { 
  ${sentTimegapMsAvgWindow} = _sentTimegapMsAvgWindow;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_mixerStreamChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.mixerStreamChanged');


        this.setColour('#8678BB');
        this.setTooltip('Triggered when the mixer\'s stream statistics have been updated.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.mixerStreamChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_mixerStreamChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AudioStats.mixerStreamChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_clientStreamChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.clientStreamChanged');


        this.setColour('#8678BB');
        this.setTooltip('Triggered when the client\'s stream statisticss have been updated.');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.clientStreamChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_clientStreamChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AudioStats.clientStreamChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AudioStats_injectorStreamsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioStats.injectorStreamsChanged');


        this.setColour('#8678BB');
        this.setTooltip('Triggered when the injector streams\' statistics have been updated.<p><strong>Note:</strong> The injector streams\' statistics are currently not provided.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AudioStats.html#.injectorStreamsChanged');
    }
};
javascript.javascriptGenerator.forBlock['AudioStats_injectorStreamsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AudioStats.injectorStreamsChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['AudioEffectOptions_ReverbOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioEffectOptions.ReverbOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('bandwidth') 
            .setCheck('Number')
            .appendField('bandwidth');
        this.appendValueInput('preDelay') 
            .setCheck('Number')
            .appendField('preDelay');
        this.appendValueInput('lateDelay') 
            .setCheck('Number')
            .appendField('lateDelay');
        this.appendValueInput('reverbTime') 
            .setCheck('Number')
            .appendField('reverbTime');
        this.appendValueInput('earlyDiffusion') 
            .setCheck('Number')
            .appendField('earlyDiffusion');
        this.appendValueInput('lateDiffusion') 
            .setCheck('Number')
            .appendField('lateDiffusion');
        this.appendValueInput('roomSize') 
            .setCheck('Number')
            .appendField('roomSize');
        this.appendValueInput('density') 
            .setCheck('Number')
            .appendField('density');
        this.appendValueInput('bassMult') 
            .setCheck('Number')
            .appendField('bassMult');
        this.appendValueInput('bassFreq') 
            .setCheck('Number')
            .appendField('bassFreq');
        this.appendValueInput('highGain') 
            .setCheck('Number')
            .appendField('highGain');
        this.appendValueInput('highFreq') 
            .setCheck('Number')
            .appendField('highFreq');
        this.appendValueInput('modRate') 
            .setCheck('Number')
            .appendField('modRate');
        this.appendValueInput('modDepth') 
            .setCheck('Number')
            .appendField('modDepth');
        this.appendValueInput('earlyGain') 
            .setCheck('Number')
            .appendField('earlyGain');
        this.appendValueInput('lateGain') 
            .setCheck('Number')
            .appendField('lateGain');
        this.appendValueInput('earlyMixLeft') 
            .setCheck('Number')
            .appendField('earlyMixLeft');
        this.appendValueInput('earlyMixRight') 
            .setCheck('Number')
            .appendField('earlyMixRight');
        this.appendValueInput('lateMixLeft') 
            .setCheck('Number')
            .appendField('lateMixLeft');
        this.appendValueInput('lateMixRight') 
            .setCheck('Number')
            .appendField('lateMixRight');
        this.appendValueInput('wetDryMix') 
            .setCheck('Number')
            .appendField('wetDryMix');
        this.setColour('#55FA9C');
        this.setTooltip('Reverberation options that can be used to initialize an {@link AudioEffectOptions} object when created.');
        this.setHelpUrl('https://apidocs.overte.org/AudioEffectOptions.html#.ReverbOptions');
    }
};
javascript.javascriptGenerator.forBlock['AudioEffectOptions_ReverbOptions'] = (block, generator) => {
    const _bandwidth = dfv(generator.valueToCode(block, 'bandwidth', javascript.javascriptGenerator.ORDER_ATOMIC), `10000`);
    const _preDelay = dfv(generator.valueToCode(block, 'preDelay', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _lateDelay = dfv(generator.valueToCode(block, 'lateDelay', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _reverbTime = dfv(generator.valueToCode(block, 'reverbTime', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);
    const _earlyDiffusion = dfv(generator.valueToCode(block, 'earlyDiffusion', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _lateDiffusion = dfv(generator.valueToCode(block, 'lateDiffusion', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _roomSize = dfv(generator.valueToCode(block, 'roomSize', javascript.javascriptGenerator.ORDER_ATOMIC), `50`);
    const _density = dfv(generator.valueToCode(block, 'density', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _bassMult = dfv(generator.valueToCode(block, 'bassMult', javascript.javascriptGenerator.ORDER_ATOMIC), `1.5`);
    const _bassFreq = dfv(generator.valueToCode(block, 'bassFreq', javascript.javascriptGenerator.ORDER_ATOMIC), `250`);
    const _highGain = dfv(generator.valueToCode(block, 'highGain', javascript.javascriptGenerator.ORDER_ATOMIC), `-6`);
    const _highFreq = dfv(generator.valueToCode(block, 'highFreq', javascript.javascriptGenerator.ORDER_ATOMIC), `3000`);
    const _modRate = dfv(generator.valueToCode(block, 'modRate', javascript.javascriptGenerator.ORDER_ATOMIC), `2.3`);
    const _modDepth = dfv(generator.valueToCode(block, 'modDepth', javascript.javascriptGenerator.ORDER_ATOMIC), `50`);
    const _earlyGain = dfv(generator.valueToCode(block, 'earlyGain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lateGain = dfv(generator.valueToCode(block, 'lateGain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _earlyMixLeft = dfv(generator.valueToCode(block, 'earlyMixLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _earlyMixRight = dfv(generator.valueToCode(block, 'earlyMixRight', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _lateMixLeft = dfv(generator.valueToCode(block, 'lateMixLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `90`);
    const _lateMixRight = dfv(generator.valueToCode(block, 'lateMixRight', javascript.javascriptGenerator.ORDER_ATOMIC), `90`);
    const _wetDryMix = dfv(generator.valueToCode(block, 'wetDryMix', javascript.javascriptGenerator.ORDER_ATOMIC), `50`);

    return [`new AudioEffectOptions.ReverbOptions(${_bandwidth},${_preDelay},${_lateDelay},${_reverbTime},${_earlyDiffusion},${_lateDiffusion},${_roomSize},${_density},${_bassMult},${_bassFreq},${_highGain},${_highFreq},${_modRate},${_modDepth},${_earlyGain},${_lateGain},${_earlyMixLeft},${_earlyMixRight},${_lateMixLeft},${_lateMixRight},${_wetDryMix})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['AudioEffectOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioEffectOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('bandwidth') 
            .setCheck('Number')
            .appendField('bandwidth');
        this.appendValueInput('preDelay') 
            .setCheck('Number')
            .appendField('preDelay');
        this.appendValueInput('lateDelay') 
            .setCheck('Number')
            .appendField('lateDelay');
        this.appendValueInput('reverbTime') 
            .setCheck('Number')
            .appendField('reverbTime');
        this.appendValueInput('earlyDiffusion') 
            .setCheck('Number')
            .appendField('earlyDiffusion');
        this.appendValueInput('lateDiffusion') 
            .setCheck('Number')
            .appendField('lateDiffusion');
        this.appendValueInput('roomSize') 
            .setCheck('Number')
            .appendField('roomSize');
        this.appendValueInput('density') 
            .setCheck('Number')
            .appendField('density');
        this.appendValueInput('bassMult') 
            .setCheck('Number')
            .appendField('bassMult');
        this.appendValueInput('bassFreq') 
            .setCheck('Number')
            .appendField('bassFreq');
        this.appendValueInput('highGain') 
            .setCheck('Number')
            .appendField('highGain');
        this.appendValueInput('highFreq') 
            .setCheck('Number')
            .appendField('highFreq');
        this.appendValueInput('modRate') 
            .setCheck('Number')
            .appendField('modRate');
        this.appendValueInput('modDepth') 
            .setCheck('Number')
            .appendField('modDepth');
        this.appendValueInput('earlyGain') 
            .setCheck('Number')
            .appendField('earlyGain');
        this.appendValueInput('lateGain') 
            .setCheck('Number')
            .appendField('lateGain');
        this.appendValueInput('earlyMixLeft') 
            .setCheck('Number')
            .appendField('earlyMixLeft');
        this.appendValueInput('earlyMixRight') 
            .setCheck('Number')
            .appendField('earlyMixRight');
        this.appendValueInput('lateMixLeft') 
            .setCheck('Number')
            .appendField('lateMixLeft');
        this.appendValueInput('lateMixRight') 
            .setCheck('Number')
            .appendField('lateMixRight');
        this.appendValueInput('wetDryMix') 
            .setCheck('Number')
            .appendField('wetDryMix');
        this.setColour('#55FA9C');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Audio effect options used by the {@link Audio} API.<p>Create using <code>new AudioEffectOptions(...)</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AudioEffectOptions');
    }
};
javascript.javascriptGenerator.forBlock['AudioEffectOptions'] = (block, generator) => {
    const _bandwidth = dfv(generator.valueToCode(block, 'bandwidth', javascript.javascriptGenerator.ORDER_ATOMIC), `10000`);
    const _preDelay = dfv(generator.valueToCode(block, 'preDelay', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _lateDelay = dfv(generator.valueToCode(block, 'lateDelay', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _reverbTime = dfv(generator.valueToCode(block, 'reverbTime', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);
    const _earlyDiffusion = dfv(generator.valueToCode(block, 'earlyDiffusion', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _lateDiffusion = dfv(generator.valueToCode(block, 'lateDiffusion', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _roomSize = dfv(generator.valueToCode(block, 'roomSize', javascript.javascriptGenerator.ORDER_ATOMIC), `50`);
    const _density = dfv(generator.valueToCode(block, 'density', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _bassMult = dfv(generator.valueToCode(block, 'bassMult', javascript.javascriptGenerator.ORDER_ATOMIC), `1.5`);
    const _bassFreq = dfv(generator.valueToCode(block, 'bassFreq', javascript.javascriptGenerator.ORDER_ATOMIC), `250`);
    const _highGain = dfv(generator.valueToCode(block, 'highGain', javascript.javascriptGenerator.ORDER_ATOMIC), `-6`);
    const _highFreq = dfv(generator.valueToCode(block, 'highFreq', javascript.javascriptGenerator.ORDER_ATOMIC), `3000`);
    const _modRate = dfv(generator.valueToCode(block, 'modRate', javascript.javascriptGenerator.ORDER_ATOMIC), `2.3`);
    const _modDepth = dfv(generator.valueToCode(block, 'modDepth', javascript.javascriptGenerator.ORDER_ATOMIC), `50`);
    const _earlyGain = dfv(generator.valueToCode(block, 'earlyGain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lateGain = dfv(generator.valueToCode(block, 'lateGain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _earlyMixLeft = dfv(generator.valueToCode(block, 'earlyMixLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _earlyMixRight = dfv(generator.valueToCode(block, 'earlyMixRight', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _lateMixLeft = dfv(generator.valueToCode(block, 'lateMixLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `90`);
    const _lateMixRight = dfv(generator.valueToCode(block, 'lateMixRight', javascript.javascriptGenerator.ORDER_ATOMIC), `90`);
    const _wetDryMix = dfv(generator.valueToCode(block, 'wetDryMix', javascript.javascriptGenerator.ORDER_ATOMIC), `50`);

    return [`new AudioEffectOptions(${_bandwidth},${_preDelay},${_lateDelay},${_reverbTime},${_earlyDiffusion},${_lateDiffusion},${_roomSize},${_density},${_bassMult},${_bassFreq},${_highGain},${_highFreq},${_modRate},${_modDepth},${_earlyGain},${_lateGain},${_earlyMixLeft},${_earlyMixRight},${_lateMixLeft},${_lateMixRight},${_wetDryMix})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AudioInjector_AudioInjectorOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.AudioInjectorOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('volume') 
            .setCheck('Number')
            .appendField('volume');
        this.appendValueInput('pitch') 
            .setCheck('Number')
            .appendField('pitch');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('secondOffset') 
            .setCheck('Number')
            .appendField('secondOffset');
        this.appendValueInput('localOnly') 
            .setCheck('Boolean')
            .appendField('localOnly');
        this.appendValueInput('ignorePenumbra') 
            .setCheck('Boolean')
            .appendField('ignorePenumbra');
        this.setColour('#0E62F1');
        this.setTooltip('Configures where and how an audio injector plays its audio.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.AudioInjectorOptions');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_AudioInjectorOptions'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), `Vec3.ZERO`);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), `Quat.IDENTITY`);
    const _volume = dfv(generator.valueToCode(block, 'volume', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _pitch = dfv(generator.valueToCode(block, 'pitch', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _secondOffset = dfv(generator.valueToCode(block, 'secondOffset', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _localOnly = dfv(generator.valueToCode(block, 'localOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _ignorePenumbra = dfv(generator.valueToCode(block, 'ignorePenumbra', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new AudioInjector.AudioInjectorOptions(${_position},${_orientation},${_volume},${_pitch},${_loop},${_secondOffset},${_localOnly},${_ignorePenumbra})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Audio_addToSoloList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.addToSoloList')
        // Returns data

        // Params data
        this.appendValueInput('ids') 
            .setCheck('Array')
            .appendField('ids');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Adds avatars to the audio solo list. If the audio solo list is not empty, only audio from the avatars in the list isplayed.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.addToSoloList');
    }
};
javascript.javascriptGenerator.forBlock['Audio_addToSoloList'] = (block, generator) => {
    const _ids = dfv(generator.valueToCode(block, 'ids', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Audio.addToSoloList(${_ids});\n`;};


// Blockly function
Blockly.Blocks['Audio_removeFromSoloList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.removeFromSoloList')
        // Returns data

        // Params data
        this.appendValueInput('ids') 
            .setCheck('Array')
            .appendField('ids');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Removes avatars from the audio solo list. If the audio solo list is not empty, only audio from the avatars in the listis played.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.removeFromSoloList');
    }
};
javascript.javascriptGenerator.forBlock['Audio_removeFromSoloList'] = (block, generator) => {
    const _ids = dfv(generator.valueToCode(block, 'ids', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Audio.removeFromSoloList(${_ids});\n`;};


// Blockly function
Blockly.Blocks['Audio_resetSoloList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.resetSoloList')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Clears the audio solo list.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.resetSoloList');
    }
};
javascript.javascriptGenerator.forBlock['Audio_resetSoloList'] = (block, generator) => {


    return `Audio.resetSoloList();\n`;};


// Blockly function
Blockly.Blocks['Audio_getServerEcho'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getServerEcho')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets whether your microphone audio is echoed back to you from the server. When enabled, microphone audio is echoed onlyif you\'re unmuted or are using push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getServerEcho');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getServerEcho'] = (block, generator) => {

return [`Audio.getServerEcho()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setServerEcho'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setServerEcho')
        // Returns data

        // Params data
        this.appendValueInput('serverEcho') 
            .setCheck('Boolean')
            .appendField('serverEcho');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets whether your microphone audio is echoed back to you from the server. When enabled, microphone audio is echoedonly if you\'re unmuted or are using push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setServerEcho');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setServerEcho'] = (block, generator) => {
    const _serverEcho = dfv(generator.valueToCode(block, 'serverEcho', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Audio.setServerEcho(${_serverEcho});\n`;};


// Blockly function
Blockly.Blocks['Audio_toggleServerEcho'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.toggleServerEcho')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Toggles the echoing of microphone audio back to you from the server. When enabled, microphone audio is echoed only ifyou\'re unmuted or are using push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.toggleServerEcho');
    }
};
javascript.javascriptGenerator.forBlock['Audio_toggleServerEcho'] = (block, generator) => {


    return `Audio.toggleServerEcho();\n`;};


// Blockly function
Blockly.Blocks['Audio_getLocalEcho'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.getLocalEcho')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets whether your microphone audio is echoed back to you by the client. When enabled, microphone audio is echoedeven if you\'re muted or not using push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.getLocalEcho');
    }
};
javascript.javascriptGenerator.forBlock['Audio_getLocalEcho'] = (block, generator) => {

return [`Audio.getLocalEcho()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setLocalEcho'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setLocalEcho')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets whether your microphone audio is echoed back to you by the client. When enabled, microphone audio is echoedeven if you\'re muted or not using push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setLocalEcho');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setLocalEcho'] = (block, generator) => {


    return `Audio.setLocalEcho();\n`;};


// Blockly function
Blockly.Blocks['Audio_toggleLocalEcho'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.toggleLocalEcho')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Toggles the echoing of microphone audio back to you by the client. When enabled, microphone audio is echoed even ifyou\'re muted or not using push-to-talk.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.toggleLocalEcho');
    }
};
javascript.javascriptGenerator.forBlock['Audio_toggleLocalEcho'] = (block, generator) => {


    return `Audio.toggleLocalEcho();\n`;};


// Blockly function
Blockly.Blocks['Audio_playSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.playSound')
        // Returns data
        this.setOutput(true, '["AudioInjector"]');

        // Params data
        this.appendValueInput('sound') 
            .setCheck('SoundObject')
            .appendField('sound');
        this.appendValueInput('injectorOptions') 
            .setCheck('AudioInjector.AudioInjectorOptions')
            .appendField('injectorOptions');

        this.setColour('#B22F04');
        this.setTooltip('Starts playing or "injecting" the content of an audio file. The sound is played globally (sent to the audiomixer) so that everyone hears it, unless the <code>injectorOptions</code> has <code>localOnly</code> set to<code>true</code> in which case only the client hears the sound played. No sound is played if sent to the audio mixerbut the client is not connected to an audio mixer. The {@link AudioInjector} object returned by the function can be usedto control the playback and get information about its current state.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.playSound');
    }
};
javascript.javascriptGenerator.forBlock['Audio_playSound'] = (block, generator) => {
    const _sound = dfv(generator.valueToCode(block, 'sound', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _injectorOptions = dfv(generator.valueToCode(block, 'injectorOptions', javascript.javascriptGenerator.ORDER_ATOMIC), `{}`);

return [`Audio.playSound(${_sound},${_injectorOptions})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_playSystemSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.playSystemSound')
        // Returns data
        this.setOutput(true, '["AudioInjector"]');

        // Params data
        this.appendValueInput('sound') 
            .setCheck('SoundObject')
            .appendField('sound');

        this.setColour('#B22F04');
        this.setTooltip('Starts playing the content of an audio file locally (isn\'t sent to the audio mixer). This is the same as calling{@link Audio.playSound} with {@link AudioInjector.AudioInjectorOptions} <code>localOnly</code> set <code>true</code> andthe specified <code>position</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.playSystemSound');
    }
};
javascript.javascriptGenerator.forBlock['Audio_playSystemSound'] = (block, generator) => {
    const _sound = dfv(generator.valueToCode(block, 'sound', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Audio.playSystemSound(${_sound})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Audio_setStereoInput'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.setStereoInput')
        // Returns data

        // Params data
        this.appendValueInput('stereo') 
            .setCheck('Boolean')
            .appendField('stereo');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#B22F04');
        this.setTooltip('Sets whether the audio input should be used in stereo. If the audio input doesn\'t support stereo then setting a valueof <code>true</code> has no effect.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.setStereoInput');
    }
};
javascript.javascriptGenerator.forBlock['Audio_setStereoInput'] = (block, generator) => {
    const _stereo = dfv(generator.valueToCode(block, 'stereo', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Audio.setStereoInput(${_stereo});\n`;};


// Blockly function
Blockly.Blocks['Audio_isStereoInput'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Audio.isStereoInput')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#B22F04');
        this.setTooltip('Gets whether the audio input is used in stereo.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.isStereoInput');
    }
};
javascript.javascriptGenerator.forBlock['Audio_isStereoInput'] = (block, generator) => {

return [`Audio.isStereoInput()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Audio_mutedByMixer'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.mutedByMixer');


        this.setColour('#B22F04');
        this.setTooltip('Triggered when the client is muted by the mixer because their loudness value for the noise background has reached thethreshold set for the domain (in the server settings).');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.mutedByMixer');
    }
};
javascript.javascriptGenerator.forBlock['Audio_mutedByMixer'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Audio.mutedByMixer.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_environmentMuted'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.environmentMuted');


        this.setColour('#B22F04');
        this.setTooltip('Triggered when the client is muted by the mixer because they\'re within a certain radius (50m) of someone who requestedthe mute through Developer &gt; Audio &gt; Mute Environment.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.environmentMuted');
    }
};
javascript.javascriptGenerator.forBlock['Audio_environmentMuted'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Audio.environmentMuted.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_receivedFirstPacket'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.receivedFirstPacket');


        this.setColour('#B22F04');
        this.setTooltip('Triggered when the client receives its first packet from the audio mixer.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.receivedFirstPacket');
    }
};
javascript.javascriptGenerator.forBlock['Audio_receivedFirstPacket'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Audio.receivedFirstPacket.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_disconnected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.disconnected');


        this.setColour('#B22F04');
        this.setTooltip('Triggered when the client is disconnected from the audio mixer.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.disconnected');
    }
};
javascript.javascriptGenerator.forBlock['Audio_disconnected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Audio.disconnected.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_noiseGateOpened'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.noiseGateOpened');


        this.setColour('#B22F04');
        this.setTooltip('Triggered when the noise gate is opened. The input audio signal is no longer blocked (fully attenuated) because it hasrisen above an adaptive threshold set just above the noise floor. Only occurs if <code>Audio.noiseReduction</code> is<code>true</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseGateOpened');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseGateOpened'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Audio.noiseGateOpened.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_noiseGateClosed'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.noiseGateClosed');


        this.setColour('#B22F04');
        this.setTooltip('Triggered when the noise gate is closed. The input audio signal is blocked (fully attenuated) because it has fallenbelow an adaptive threshold set just above the noise floor. Only occurs if <code>Audio.noiseReduction</code> is<code>true</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.noiseGateClosed');
    }
};
javascript.javascriptGenerator.forBlock['Audio_noiseGateClosed'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Audio.noiseGateClosed.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_inputReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.inputReceived');

        this.appendDummyInput('inputSamples')
            .appendField('inputSamples:')
            .appendField(new Blockly.FieldVariable('inputReceived_inputSamples'), 'inputSamples');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when a frame of audio input is processed.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.inputReceived');
    }
};
javascript.javascriptGenerator.forBlock['Audio_inputReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const inputSamples = generator.getVariableName(block.getFieldValue('inputSamples'));

return `Audio.inputReceived.connect((_inputSamples) => { 
  ${inputSamples} = _inputSamples;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Audio_isStereoInputChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Audio.isStereoInputChanged');

        this.appendDummyInput('isStereo')
            .appendField('isStereo:')
            .appendField(new Blockly.FieldVariable('isStereoInputChanged_isStereo'), 'isStereo');

        this.setColour('#B22F04');
        this.setTooltip('Triggered when the input audio use changes between mono and stereo.');
        this.setHelpUrl('https://apidocs.overte.org/Audio.html#.isStereoInputChanged');
    }
};
javascript.javascriptGenerator.forBlock['Audio_isStereoInputChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isStereo = generator.getVariableName(block.getFieldValue('isStereo'));

return `Audio.isStereoInputChanged.connect((_isStereo) => { 
  ${isStereo} = _isStereo;
${innerCode}
});\n`;};

// Blockly class
Blockly.Blocks['AudioInjector'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('playing') 
            .setCheck('Boolean')
            .appendField('playing');
        this.appendValueInput('loudness') 
            .setCheck('Number')
            .appendField('loudness');
        this.appendValueInput('options') 
            .setCheck('AudioInjector.AudioInjectorOptions')
            .appendField('options');
        this.setColour('#0E62F1');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Plays or "injects" the content of an audio file.<p>Create using {@link Audio} API methods.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector'] = (block, generator) => {
    const _playing = dfv(generator.valueToCode(block, 'playing', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _loudness = dfv(generator.valueToCode(block, 'loudness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new AudioInjector(${_playing},${_loudness},${_options})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['AudioInjector_restart'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.restart')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0E62F1');
        this.setTooltip('Stops current playback, if any, and starts playing from the beginning.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.restart');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_restart'] = (block, generator) => {


    return `AudioInjector.restart();\n`;};


// Blockly function
Blockly.Blocks['AudioInjector_stop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.stop')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0E62F1');
        this.setTooltip('Stops audio playback.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.stop');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_stop'] = (block, generator) => {


    return `AudioInjector.stop();\n`;};


// Blockly function
Blockly.Blocks['AudioInjector_getOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.getOptions')
        // Returns data
        this.setOutput(true, '["AudioInjector.AudioInjectorOptions"]');

        // Params data

        this.setColour('#0E62F1');
        this.setTooltip('Gets the current configuration of the audio injector.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.getOptions');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_getOptions'] = (block, generator) => {

return [`AudioInjector.getOptions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AudioInjector_setOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.setOptions')
        // Returns data

        // Params data
        this.appendValueInput('options') 
            .setCheck('AudioInjector.AudioInjectorOptions')
            .appendField('options');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#0E62F1');
        this.setTooltip('Configures how the injector plays the audio.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.setOptions');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_setOptions'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `AudioInjector.setOptions(${_options});\n`;};


// Blockly function
Blockly.Blocks['AudioInjector_getLoudness'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.getLoudness')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#0E62F1');
        this.setTooltip('Gets the loudness of the most recent frame of audio played.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.getLoudness');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_getLoudness'] = (block, generator) => {

return [`AudioInjector.getLoudness()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AudioInjector_isPlaying'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AudioInjector.isPlaying')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#0E62F1');
        this.setTooltip('Gets whether or not the audio is currently playing.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.isPlaying');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_isPlaying'] = (block, generator) => {

return [`AudioInjector.isPlaying()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['AudioInjector_finished'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AudioInjector.finished');


        this.setColour('#0E62F1');
        this.setTooltip('Triggered when the audio has finished playing.');
        this.setHelpUrl('https://apidocs.overte.org/AudioInjector.html#.finished');
    }
};
javascript.javascriptGenerator.forBlock['AudioInjector_finished'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AudioInjector.finished.connect(() => {
${innerCode}
});\n`;};

// Blockly class
Blockly.Blocks['SoundObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundObject')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('downloaded') 
            .setCheck('Boolean')
            .appendField('downloaded');
        this.appendValueInput('duration') 
            .setCheck('Number')
            .appendField('duration');
        this.setColour('#90172C');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>An audio resource, created by {@link SoundCache.getSound}, to be played back using {@link Audio.playSound}.<p>Supported formats:</p><ul>  <li>WAV: 16-bit uncompressed at any sample rate, with 1 (mono), 2 (stereo), or 4 (ambisonic) channels.</li>  <li>MP3: Mono or stereo, at any sample rate.</li>  <li>RAW: 48khz 16-bit mono or stereo. File name must include <code>".stereo"</code> to be interpreted as stereo.</li></ul>');
        this.setHelpUrl('https://apidocs.overte.org/SoundObject');
    }
};
javascript.javascriptGenerator.forBlock['SoundObject'] = (block, generator) => {
    const _downloaded = dfv(generator.valueToCode(block, 'downloaded', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _duration = dfv(generator.valueToCode(block, 'duration', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new SoundObject(${_downloaded},${_duration})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly signal
Blockly.Blocks['SoundObject_ready'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('SoundObject.ready');


        this.setColour('#90172C');
        this.setTooltip('Triggered when the sound has been downloaded and is ready to be played.');
        this.setHelpUrl('https://apidocs.overte.org/SoundObject.html#.ready');
    }
};
javascript.javascriptGenerator.forBlock['SoundObject_ready'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `SoundObject.ready.connect(() => {
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['SoundCache_numTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.numTotal')       
        this.setOutput(true, '');
        this.setColour('#DB1159');
        this.setTooltip('Total number of total resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.numTotal');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_numTotal'] = (block, generator) => {
    return [`SoundCache.numTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['SoundCache_numCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.numCached')       
        this.setOutput(true, '');
        this.setColour('#DB1159');
        this.setTooltip('Total number of cached resource. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.numCached');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_numCached'] = (block, generator) => {
    return [`SoundCache.numCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['SoundCache_sizeTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.sizeTotal')       
        this.setOutput(true, '');
        this.setColour('#DB1159');
        this.setTooltip('Size in bytes of all resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.sizeTotal');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_sizeTotal'] = (block, generator) => {
    return [`SoundCache.sizeTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['SoundCache_sizeCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.sizeCached')       
        this.setOutput(true, '');
        this.setColour('#DB1159');
        this.setTooltip('Size in bytes of all cached resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.sizeCached');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_sizeCached'] = (block, generator) => {
    return [`SoundCache.sizeCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['SoundCache_numGlobalQueriesPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.numGlobalQueriesPending')       
        this.setOutput(true, '');
        this.setColour('#DB1159');
        this.setTooltip('Total number of global queries pending (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.numGlobalQueriesPending');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_numGlobalQueriesPending'] = (block, generator) => {
    return [`SoundCache.numGlobalQueriesPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['SoundCache_numGlobalQueriesLoading'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.numGlobalQueriesLoading')       
        this.setOutput(true, '');
        this.setColour('#DB1159');
        this.setTooltip('Total number of global queries loading (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.numGlobalQueriesLoading');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_numGlobalQueriesLoading'] = (block, generator) => {
    return [`SoundCache.numGlobalQueriesLoading`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['SoundCache_getSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.getSound')
        // Returns data
        this.setOutput(true, '["SoundObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#DB1159');
        this.setTooltip('Loads the content of an audio file into a {@link SoundObject}, ready for playback by {@link Audio.playSound}.');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.getSound');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_getSound'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`SoundCache.getSound(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['AvatarDataRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarDataRate')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#317EB0');
        this.setTooltip('<p>The avatar mixer data comprises different types of data, with the data rates of each being tracked in kbps.</p><table>  <thead>    <tr><th>Rate Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"globalPosition"</code></td><td>Incoming global position.</td></tr>    <tr><td><code>"localPosition"</code></td><td>Incoming local position.</td></tr>    <tr><td><code>"handControllers"</code></td><td>Incoming hand controllers.</td></tr>    <tr><td><code>"avatarBoundingBox"</code></td><td>Incoming avatar bounding box.</td></tr>    <tr><td><code>"avatarOrientation"</code></td><td>Incoming avatar orientation.</td></tr>    <tr><td><code>"avatarScale"</code></td><td>Incoming avatar scale.</td></tr>    <tr><td><code>"lookAtPosition"</code></td><td>Incoming look-at position.</td></tr>    <tr><td><code>"audioLoudness"</code></td><td>Incoming audio loudness.</td></tr>    <tr><td><code>"sensorToWorkMatrix"</code></td><td>Incoming sensor-to-world matrix.</td></tr>    <tr><td><code>"additionalFlags"</code></td><td>Incoming additional avatar flags.</td></tr>    <tr><td><code>"parentInfo"</code></td><td>Incoming parent information.</td></tr>    <tr><td><code>"faceTracker"</code></td><td>Incoming face tracker data.</td></tr>    <tr><td><code>"jointData"</code></td><td>Incoming joint data.</td></tr>    <tr><td><code>"jointDefaultPoseFlagsRate"</code></td><td>Incoming joint default pose flags.</td></tr>    <tr><td><code>"farGrabJointRate"</code></td><td>Incoming far grab joint.</td></tr>    <tr><td><code>"globalPositionOutbound"</code></td><td>Outgoing global position.</td></tr>    <tr><td><code>"localPositionOutbound"</code></td><td>Outgoing local position.</td></tr>    <tr><td><code>"avatarBoundingBoxOutbound"</code></td><td>Outgoing avatar bounding box.</td></tr>    <tr><td><code>"avatarOrientationOutbound"</code></td><td>Outgoing avatar orientation.</td></tr>    <tr><td><code>"avatarScaleOutbound"</code></td><td>Outgoing avatar scale.</td></tr>    <tr><td><code>"lookAtPositionOutbound"</code></td><td>Outgoing look-at position.</td></tr>    <tr><td><code>"audioLoudnessOutbound"</code></td><td>Outgoing audio loudness.</td></tr>    <tr><td><code>"sensorToWorkMatrixOutbound"</code></td><td>Outgoing sensor-to-world matrix.</td></tr>    <tr><td><code>"additionalFlagsOutbound"</code></td><td>Outgoing additional avatar flags.</td></tr>    <tr><td><code>"parentInfoOutbound"</code></td><td>Outgoing parent information.</td></tr>    <tr><td><code>"faceTrackerOutbound"</code></td><td>Outgoing face tracker data.</td></tr>    <tr><td><code>"jointDataOutbound"</code></td><td>Outgoing joint data.</td></tr>    <tr><td><code>"jointDefaultPoseFlagsOutbound"</code></td><td>Outgoing joint default pose flags.</td></tr>    <tr><td><code>""</code></td><td>When no rate name is specified, the total incoming data rate is provided.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarDataRate');
    }
};
javascript.javascriptGenerator.forBlock['AvatarDataRate'] = (block, generator) => {

    return [`new AvatarDataRate()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AvatarUpdateRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarUpdateRate')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F8FB81');
        this.setTooltip('<p>The avatar mixer data comprises different types of data updated at different rates, in Hz.</p><table>  <thead>    <tr><th>Rate Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"globalPosition"</code></td><td>Global position.</td></tr>    <tr><td><code>"localPosition"</code></td><td>Local position.</td></tr>    <tr><td><code>"handControllers"</code></td><td>Hand controller positions and orientations.</td></tr>    <tr><td><code>"avatarBoundingBox"</code></td><td>Avatar bounding box.</td></tr>    <tr><td><code>"avatarOrientation"</code></td><td>Avatar orientation.</td></tr>    <tr><td><code>"avatarScale"</code></td><td>Avatar scale.</td></tr>    <tr><td><code>"lookAtPosition"</code></td><td>Look-at position.</td></tr>    <tr><td><code>"audioLoudness"</code></td><td>Audio loudness.</td></tr>    <tr><td><code>"sensorToWorkMatrix"</code></td><td>Sensor-to-world matrix.</td></tr>    <tr><td><code>"additionalFlags"</code></td><td>Additional avatar flags.</td></tr>    <tr><td><code>"parentInfo"</code></td><td>Parent information.</td></tr>    <tr><td><code>"faceTracker"</code></td><td>Face tracker data.</td></tr>    <tr><td><code>"jointData"</code></td><td>Joint data.</td></tr>    <tr><td><code>"farGrabJointData"</code></td><td>Far grab joint data.</td></tr>    <tr><td><code>""</code></td><td>When no rate name is specified, the overall update rate is provided.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarUpdateRate');
    }
};
javascript.javascriptGenerator.forBlock['AvatarUpdateRate'] = (block, generator) => {

    return [`new AvatarUpdateRate()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AttachmentData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AttachmentData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('modelUrl') 
            .setCheck('String')
            .appendField('modelUrl');
        this.appendValueInput('jointName') 
            .setCheck('String')
            .appendField('jointName');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');
        this.appendValueInput('rotation') 
            .setCheck('Vec3')
            .appendField('rotation');
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');
        this.appendValueInput('soft') 
            .setCheck('Boolean')
            .appendField('soft');
        this.setColour('#517180');
        this.setTooltip('Information on an attachment worn by the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/AttachmentData');
    }
};
javascript.javascriptGenerator.forBlock['AttachmentData'] = (block, generator) => {
    const _modelUrl = dfv(generator.valueToCode(block, 'modelUrl', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointName = dfv(generator.valueToCode(block, 'jointName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _soft = dfv(generator.valueToCode(block, 'soft', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new AttachmentData(${_modelUrl},${_jointName},${_translation},${_rotation},${_scale},${_soft})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['RayToAvatarIntersectionResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RayToAvatarIntersectionResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('avatarID') 
            .setCheck('String')
            .appendField('avatarID');
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.appendValueInput('face') 
            .setCheck('String')
            .appendField('face');
        this.appendValueInput('intersection') 
            .setCheck('Vec3')
            .appendField('intersection');
        this.appendValueInput('surfaceNormal') 
            .setCheck('Vec3')
            .appendField('surfaceNormal');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');
        this.appendValueInput('extraInfo') 
            .setCheck('SubmeshIntersection')
            .appendField('extraInfo');
        this.setColour('#388B32');
        this.setTooltip('Information about a ray-to-avatar intersection.');
        this.setHelpUrl('https://apidocs.overte.org/RayToAvatarIntersectionResult');
    }
};
javascript.javascriptGenerator.forBlock['RayToAvatarIntersectionResult'] = (block, generator) => {
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _avatarID = dfv(generator.valueToCode(block, 'avatarID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _face = dfv(generator.valueToCode(block, 'face', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _intersection = dfv(generator.valueToCode(block, 'intersection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _surfaceNormal = dfv(generator.valueToCode(block, 'surfaceNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _extraInfo = dfv(generator.valueToCode(block, 'extraInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new RayToAvatarIntersectionResult(${_intersects},${_avatarID},${_distance},${_face},${_intersection},${_surfaceNormal},${_jointIndex},${_extraInfo})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['AvatarEntityMap'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarEntityMap')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F09035');
        this.setTooltip('An object with the UUIDs of avatar entities as keys and avatar entity properties objects as values.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarEntityMap');
    }
};
javascript.javascriptGenerator.forBlock['AvatarEntityMap'] = (block, generator) => {

    return [`new AvatarEntityMap()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['HandState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HandState')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#666018');
        this.setTooltip('<p>The pointing state of the hands is specified by the following values:</p><table>  <thead>    <tr><th>Value</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>No hand is pointing.</td></tr>    <tr><td><code>1</code></td><td>The left hand is pointing.</td></tr>    <tr><td><code>2</code></td><td>The right hand is pointing.</td></tr>    <tr><td><code>4</code></td><td>It is the index finger that is pointing.</td></tr>  </tbody></table><p>The values for the hand states are added together to give the <code>HandState</code> value. For example, if the lefthand\'s finger is pointing, the value is <code>1 + 4 == 5</code>.');
        this.setHelpUrl('https://apidocs.overte.org/HandState');
    }
};
javascript.javascriptGenerator.forBlock['HandState'] = (block, generator) => {

    return [`new HandState()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Avatar_getDomainMinScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getDomainMinScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the minimum scale allowed for this avatar in the current domain.This value can change as the user changes avatars or when changing domains.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getDomainMinScale');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getDomainMinScale'] = (block, generator) => {

return [`Avatar.getDomainMinScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getDomainMaxScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getDomainMaxScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the maximum scale allowed for this avatar in the current domain.This value can change as the user changes avatars or when changing domains.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getDomainMaxScale');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getDomainMaxScale'] = (block, generator) => {

return [`Avatar.getDomainMaxScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getEyeHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getEyeHeight')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the current eye height of the avatar.This height is only an estimate and might be incorrect for avatars that are missing standard joints.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getEyeHeight');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getEyeHeight'] = (block, generator) => {

return [`Avatar.getEyeHeight()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getHeight')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the current height of the avatar.This height is only an estimate and might be incorrect for avatars that are missing standard joints.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getHeight');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getHeight'] = (block, generator) => {

return [`Avatar.getHeight()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setHandState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setHandState')
        // Returns data

        // Params data
        this.appendValueInput('state') 
            .setCheck('HandState')
            .appendField('state');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets the pointing state of the hands to control where the laser emanates from. If the right index finger is pointing, thelaser emanates from the tip of that finger, otherwise it emanates from the palm.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setHandState');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setHandState'] = (block, generator) => {
    const _state = dfv(generator.valueToCode(block, 'state', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setHandState(${_state});\n`;};


// Blockly function
Blockly.Blocks['Avatar_getHandState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getHandState')
        // Returns data
        this.setOutput(true, '["HandState"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the pointing state of the hands to control where the laser emanates from. If the right index finger is pointing, thelaser emanates from the tip of that finger, otherwise it emanates from the palm.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getHandState');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getHandState'] = (block, generator) => {

return [`Avatar.getHandState()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setJointData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointData')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets a specific joint\'s rotation and position relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointData'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointData(${_index},${_rotation},${_translation});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointRotation')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets a specific joint\'s rotation relative to its parent.<p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointRotation(${_index},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointTranslation')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets a specific joint\'s translation relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointTranslation(${_index},${_translation});\n`;};


// Blockly function
Blockly.Blocks['Avatar_clearJointData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.clearJointData')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Clears joint translations and rotations set by script for a specific joint. This restores all motion from the defaultanimation system including inverse kinematics for that joint.<p>Note: This is slightly faster than the function variation that specifies the joint name.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.clearJointData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_clearJointData'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Avatar.clearJointData(${_index});\n`;};


// Blockly function
Blockly.Blocks['Avatar_isJointDataValid'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.isJointDataValid')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#320360');
        this.setTooltip('Checks that the data for a joint are valid.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.isJointDataValid');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_isJointDataValid'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Avatar.isJointDataValid(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#320360');
        this.setTooltip('Gets the rotation of a joint relative to its parent. For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Avatar.getJointRotation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#320360');
        this.setTooltip('Gets the translation of a joint relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Avatar.getJointTranslation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setJointDatanamerotationtranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointData')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets a specific joint\'s rotation and position relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointDatanamerotationtranslation'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointData(${_name},${_rotation},${_translation});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setJointRotationnamerotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointRotation')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets a specific joint\'s rotation relative to its parent.<p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointRotationnamerotation'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointRotation(${_name},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setJointTranslationnametranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointTranslation')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets a specific joint\'s translation relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointTranslationnametranslation'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointTranslation(${_name},${_translation});\n`;};


// Blockly function
Blockly.Blocks['Avatar_clearJointDataname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.clearJointData')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Clears joint translations and rotations set by script for a specific joint. This restores all motion from the defaultanimation system including inverse kinematics for that joint.<p>Note: This is slightly slower than the function variation that specifies the joint index.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.clearJointData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_clearJointDataname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.clearJointData(${_name});\n`;};


// Blockly function
Blockly.Blocks['Avatar_isJointDataValidname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.isJointDataValid')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#320360');
        this.setTooltip('Checks if the data for a joint are valid.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.isJointDataValid');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_isJointDataValidname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Avatar.isJointDataValid(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointRotationname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#320360');
        this.setTooltip('Gets the rotation of a joint relative to its parent. For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointRotationname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Avatar.getJointRotation(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointTranslationname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Number')
            .appendField('name');

        this.setColour('#320360');
        this.setTooltip('Gets the translation of a joint relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointTranslationname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Avatar.getJointTranslation(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointRotations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the rotations of all joints in the current avatar. Each joint\'s rotation is relative to its parent joint.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointRotations');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointRotations'] = (block, generator) => {

return [`Avatar.getJointRotations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointTranslations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointTranslations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the translations of all joints in the current avatar. Each joint\'s translation is relative to its parent joint, inmodel coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointTranslations');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointTranslations'] = (block, generator) => {

return [`Avatar.getJointTranslations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setJointRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointRotations')
        // Returns data

        // Params data
        this.appendValueInput('jointRotations') 
            .setCheck('Array')
            .appendField('jointRotations');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets the rotations of all joints in the current avatar. Each joint\'s rotation is relative to its parent joint.<p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointRotations');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointRotations'] = (block, generator) => {
    const _jointRotations = dfv(generator.valueToCode(block, 'jointRotations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointRotations(${_jointRotations});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setJointTranslations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setJointTranslations')
        // Returns data

        // Params data
        this.appendValueInput('translations') 
            .setCheck('Array')
            .appendField('translations');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets the translations of all joints in the current avatar. Each joint\'s translation is relative to its parent joint, inmodel coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setJointTranslations');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setJointTranslations'] = (block, generator) => {
    const _translations = dfv(generator.valueToCode(block, 'translations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setJointTranslations(${_translations});\n`;};


// Blockly function
Blockly.Blocks['Avatar_clearJointsData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.clearJointsData')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Clears all joint translations and rotations that have been set by script. This restores all motion from the defaultanimation system including inverse kinematics for all joints.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.clearJointsData');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_clearJointsData'] = (block, generator) => {


    return `Avatar.clearJointsData();\n`;};


// Blockly function
Blockly.Blocks['Avatar_getJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointIndex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#320360');
        this.setTooltip('Gets the joint index for a named joint. The joint index value is the position of the joint in the array returned by{@link MyAvatar.getJointNames}, or {@link Avatar.getJointNames} if using the <code>Avatar</code> API.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointIndex'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Avatar.getJointIndex(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getJointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getJointNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the names of all the joints in the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getJointNames');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getJointNames'] = (block, generator) => {

return [`Avatar.getJointNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setBlendshape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setBlendshape')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets the value of a blend shape to animate your avatar\'s face. In order for other users to see the resulting animationson your avatar\'s face, set <code>hasScriptedBlendshapes</code> to <code>true</code>. When you are done using this API,set <code>hasScriptedBlendshapes</code> back to <code>false</code> when the animation is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setBlendshape');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setBlendshape'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Avatar.setBlendshape(${_name},${_value});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setForceFaceTrackerConnected'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setForceFaceTrackerConnected')
        // Returns data

        // Params data
        this.appendValueInput('connected') 
            .setCheck('Boolean')
            .appendField('connected');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Enables blend shapes set using {@link Avatar.setBlendshape} or {@link MyAvatar.setBlendshape} to be transmitted to otherusers so that they can see the animation of your avatar\'s face.<p class="important">Deprecated: This method is deprecated and will be removed. Use the<code>Avatar.hasScriptedBlendshapes</code> or <code>MyAvatar.hasScriptedBlendshapes</code>  property instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setForceFaceTrackerConnected');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setForceFaceTrackerConnected'] = (block, generator) => {
    const _connected = dfv(generator.valueToCode(block, 'connected', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Avatar.setForceFaceTrackerConnected(${_connected});\n`;};


// Blockly function
Blockly.Blocks['Avatar_setSkeletonModelURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setSkeletonModelURL')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#320360');
        this.setTooltip('Sets the avatar\'s skeleton model.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setSkeletonModelURL');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setSkeletonModelURL'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Avatar.setSkeletonModelURL(${_url});\n`;};


// Blockly function
Blockly.Blocks['Avatar_getSensorToWorldMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getSensorToWorldMatrix')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the transform from the user\'s real world to the avatar\'s size, orientation, and position in the virtual world.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getSensorToWorldMatrix');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getSensorToWorldMatrix'] = (block, generator) => {

return [`Avatar.getSensorToWorldMatrix()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getSensorToWorldScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getSensorToWorldScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the scale that transforms dimensions in the user\'s real world to the avatar\'s size in the virtual world.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getSensorToWorldScale');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getSensorToWorldScale'] = (block, generator) => {

return [`Avatar.getSensorToWorldScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getControllerLeftHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getControllerLeftHandMatrix')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the rotation and translation of the left hand controller relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getControllerLeftHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getControllerLeftHandMatrix'] = (block, generator) => {

return [`Avatar.getControllerLeftHandMatrix()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getControllerRightHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getControllerRightHandMatrix')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the rotation and translation of the right hand controller relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getControllerRightHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getControllerRightHandMatrix'] = (block, generator) => {

return [`Avatar.getControllerRightHandMatrix()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getDataRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getDataRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('rateName') 
            .setCheck('AvatarDataRate')
            .appendField('rateName');

        this.setColour('#320360');
        this.setTooltip('Gets the amount of avatar mixer data being generated by the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getDataRate');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getDataRate'] = (block, generator) => {
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Avatar.getDataRate(${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getUpdateRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getUpdateRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('rateName') 
            .setCheck('AvatarUpdateRate')
            .appendField('rateName');

        this.setColour('#320360');
        this.setTooltip('Gets the update rate of avatar mixer data being generated by the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getUpdateRate');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getUpdateRate'] = (block, generator) => {
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`Avatar.getUpdateRate(${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Avatar_displayNameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Avatar.displayNameChanged');


        this.setColour('#320360');
        this.setTooltip('Triggered when the avatar\'s <code>displayName</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.displayNameChanged');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_displayNameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Avatar.displayNameChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Avatar_sessionDisplayNameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Avatar.sessionDisplayNameChanged');


        this.setColour('#320360');
        this.setTooltip('Triggered when the avatar\'s <code>sessionDisplayName</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.sessionDisplayNameChanged');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_sessionDisplayNameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Avatar.sessionDisplayNameChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Avatar_skeletonModelURLChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Avatar.skeletonModelURLChanged');


        this.setColour('#320360');
        this.setTooltip('Triggered when the avatar\'s model (i.e., <code>skeletonModelURL</code> property value) changes.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.skeletonModelURLChanged');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_skeletonModelURLChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Avatar.skeletonModelURLChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Avatar_lookAtSnappingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Avatar.lookAtSnappingChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('lookAtSnappingChanged_enabled'), 'enabled');

        this.setColour('#320360');
        this.setTooltip('Triggered when the avatar\'s <code>lookAtSnappingEnabled</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.lookAtSnappingChanged');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_lookAtSnappingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `Avatar.lookAtSnappingChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Avatar_sessionUUIDChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Avatar.sessionUUIDChanged');


        this.setColour('#320360');
        this.setTooltip('Triggered when the avatar\'s <code>sessionUUID</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.sessionUUIDChanged');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_sessionUUIDChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Avatar.sessionUUIDChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['Avatar_getAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#320360');
        this.setTooltip('Gets the rotation of a joint relative to the avatar.<p><strong>Warning:</strong> Not able to be used in the <code>Avatar</code> API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Avatar.getAbsoluteJointRotationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#320360');
        this.setTooltip('Gets the translation of a joint relative to the avatar.<p><strong>Warning:</strong> Not able to be used in the <code>Avatar</code> API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Avatar.getAbsoluteJointTranslationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setColour('#320360');
        this.setTooltip('Sets the rotation of a joint relative to the avatar.<p><strong>Warning:</strong> Not able to be used in the <code>Avatar</code> API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Avatar.setAbsoluteJointRotationInObjectFrame(${_index},${_rotation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_setAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.setAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setColour('#320360');
        this.setTooltip('Sets the translation of a joint relative to the avatar.<p><strong>Warning:</strong> Not able to be used in the <code>Avatar</code> API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.setAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_setAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Avatar.setAbsoluteJointTranslationInObjectFrame(${_index},${_translation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Avatar_getTargetScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.getTargetScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#320360');
        this.setTooltip('Gets the target scale of the avatar without any restrictions on permissible values imposed by the domain. In contrast, the<code>scale</code> property\'s value may be limited by the domain\'s settings.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.getTargetScale');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_getTargetScale'] = (block, generator) => {

return [`Avatar.getTargetScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarList_getAvatarIdentifiers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarList.getAvatarIdentifiers')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#D17C60');
        this.setTooltip('Gets the IDs of all avatars in the domain.<p><strong>Warning:</strong> If the AC script is acting as an avatar (i.e., <code>Agent.isAvatar == true</code>) the avatar\'s ID is NOT included in results.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.getAvatarIdentifiers');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_getAvatarIdentifiers'] = (block, generator) => {

return [`AvatarList.getAvatarIdentifiers()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarList_getAvatarsInRange'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarList.getAvatarsInRange')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('range') 
            .setCheck('Number')
            .appendField('range');

        this.setColour('#D17C60');
        this.setTooltip('Gets the IDs of all avatars within a specified distance from a point.<p><strong>Warning:</strong> If the AC script is acting as an avatar (i.e., <code>Agent.isAvatar == true</code>) theavatar\'s ID is NOT included in results.</p>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.getAvatarsInRange');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_getAvatarsInRange'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _range = dfv(generator.valueToCode(block, 'range', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`AvatarList.getAvatarsInRange(${_position},${_range})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AvatarList_getAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarList.getAvatar')
        // Returns data
        this.setOutput(true, '["ScriptAvatar"]');

        // Params data
        this.appendValueInput('avatarID') 
            .setCheck('Uuid')
            .appendField('avatarID');

        this.setColour('#D17C60');
        this.setTooltip('Gets information about an avatar.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.getAvatar');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_getAvatar'] = (block, generator) => {
    const _avatarID = dfv(generator.valueToCode(block, 'avatarID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AvatarList.getAvatar(${_avatarID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['AvatarList_avatarAddedEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarList.avatarAddedEvent');

        this.appendDummyInput('sessionUUID')
            .appendField('sessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarAddedEvent_sessionUUID'), 'sessionUUID');

        this.setColour('#D17C60');
        this.setTooltip('Triggered when an avatar arrives in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.avatarAddedEvent');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_avatarAddedEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sessionUUID = generator.getVariableName(block.getFieldValue('sessionUUID'));

return `AvatarList.avatarAddedEvent.connect((_sessionUUID) => { 
  ${sessionUUID} = _sessionUUID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarList_avatarRemovedEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarList.avatarRemovedEvent');

        this.appendDummyInput('sessionUUID')
            .appendField('sessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarRemovedEvent_sessionUUID'), 'sessionUUID');

        this.setColour('#D17C60');
        this.setTooltip('Triggered when an avatar leaves the domain.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.avatarRemovedEvent');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_avatarRemovedEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sessionUUID = generator.getVariableName(block.getFieldValue('sessionUUID'));

return `AvatarList.avatarRemovedEvent.connect((_sessionUUID) => { 
  ${sessionUUID} = _sessionUUID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarList_avatarSessionChangedEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarList.avatarSessionChangedEvent');

        this.appendDummyInput('newSessionUUID')
            .appendField('newSessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarSessionChangedEvent_newSessionUUID'), 'newSessionUUID');
        this.appendDummyInput('oldSessionUUID')
            .appendField('oldSessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarSessionChangedEvent_oldSessionUUID'), 'oldSessionUUID');

        this.setColour('#D17C60');
        this.setTooltip('Triggered when an avatar\'s session ID changes.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.avatarSessionChangedEvent');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_avatarSessionChangedEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const newSessionUUID = generator.getVariableName(block.getFieldValue('newSessionUUID'));
    const oldSessionUUID = generator.getVariableName(block.getFieldValue('oldSessionUUID'));

return `AvatarList.avatarSessionChangedEvent.connect((_newSessionUUID,_oldSessionUUID) => { 
  ${newSessionUUID} = _newSessionUUID; 
  ${oldSessionUUID} = _oldSessionUUID;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['AvatarList_isAvatarInRange'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarList.isAvatarInRange')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('String')
            .appendField('position');
        this.appendValueInput('range') 
            .setCheck('String')
            .appendField('range');

        this.setColour('#D17C60');
        this.setTooltip('Checks whether there is an avatar within a specified distance from a point.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarList.html#.isAvatarInRange');
    }
};
javascript.javascriptGenerator.forBlock['AvatarList_isAvatarInRange'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _range = dfv(generator.valueToCode(block, 'range', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AvatarList.isAvatarInRange(${_position},${_range})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getHandState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getHandState')
        // Returns data
        this.setOutput(true, '["HandState"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the pointing state of the hands to control where the laser emanates from. If the right index finger is pointing, thelaser emanates from the tip of that finger, otherwise it emanates from the palm.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getHandState');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getHandState'] = (block, generator) => {

return [`ScriptAvatar.getHandState()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the rotation of a joint relative to its parent. For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getJointRotation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the translation of a joint relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getJointTranslation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointRotationname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#F98983');
        this.setTooltip('Gets the rotation of a joint relative to its parent. For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointRotationname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ScriptAvatar.getJointRotation(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointTranslationname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Number')
            .appendField('name');

        this.setColour('#F98983');
        this.setTooltip('Gets the translation of a joint relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointTranslationname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getJointTranslation(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointRotations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the rotations of all joints in the avatar. Each joint\'s rotation is relative to its parent joint.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointRotations');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointRotations'] = (block, generator) => {

return [`ScriptAvatar.getJointRotations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointTranslations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointTranslations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the translations of all joints in the avatar. Each joint\'s translation is relative to its parent joint, inmodel coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointTranslations');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointTranslations'] = (block, generator) => {

return [`ScriptAvatar.getJointTranslations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_isJointDataValid'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.isJointDataValid')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Checks that the data for a joint are valid.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.isJointDataValid');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_isJointDataValid'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.isJointDataValid(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointIndex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#F98983');
        this.setTooltip('Gets the joint index for a named joint. The joint index value is the position of the joint in the array returned by{@linkScriptAvatar.getJointNames}.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointIndex'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ScriptAvatar.getJointIndex(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the names of all the joints in the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointNames');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointNames'] = (block, generator) => {

return [`ScriptAvatar.getJointNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['ScriptAvatar_displayNameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptAvatar.displayNameChanged');


        this.setColour('#F98983');
        this.setTooltip('Triggered when the avatar\'s <code>displayName</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.displayNameChanged');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_displayNameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ScriptAvatar.displayNameChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptAvatar_sessionDisplayNameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptAvatar.sessionDisplayNameChanged');


        this.setColour('#F98983');
        this.setTooltip('Triggered when the avatar\'s <code>sessionDisplayName</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.sessionDisplayNameChanged');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_sessionDisplayNameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ScriptAvatar.sessionDisplayNameChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptAvatar_skeletonModelURLChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptAvatar.skeletonModelURLChanged');


        this.setColour('#F98983');
        this.setTooltip('Triggered when the avatar\'s model (i.e., <code>skeletonModelURL</code> property value) changes.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.skeletonModelURLChanged');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_skeletonModelURLChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ScriptAvatar.skeletonModelURLChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptAvatar_lookAtSnappingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptAvatar.lookAtSnappingChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('lookAtSnappingChanged_enabled'), 'enabled');

        this.setColour('#F98983');
        this.setTooltip('Triggered when the avatar\'s <code>lookAtSnappingEnabled</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.lookAtSnappingChanged');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_lookAtSnappingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `ScriptAvatar.lookAtSnappingChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['ScriptAvatar_getAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the rotation of a joint relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getAbsoluteJointRotationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the translation of a joint relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getAbsoluteJointTranslationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['AvatarSimulationRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarSimulationRate')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#43C348');
        this.setTooltip('<p>An avatar has different types of data simulated at different rates, in Hz.</p><table>  <thead>    <tr><th>Rate Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"avatar" or ""</code></td><td>The rate at which the avatar is updated even if not in view.</td></tr>    <tr><td><code>"avatarInView"</code></td><td>The rate at which the avatar is updated if in view.</td></tr>    <tr><td><code>"skeletonModel"</code></td><td>The rate at which the skeleton model is being updated, even if there are no      joint data available.</td></tr>    <tr><td><code>"jointData"</code></td><td>The rate at which joint data are being updated.</td></tr>    <tr><td><code>""</code></td><td>When no rate name is specified, the <code>"avatar"</code> update rate is      provided.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/AvatarSimulationRate');
    }
};
javascript.javascriptGenerator.forBlock['AvatarSimulationRate'] = (block, generator) => {

    return [`new AvatarSimulationRate()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['SkeletonJoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SkeletonJoint')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('parentIndex') 
            .setCheck('Number')
            .appendField('parentIndex');
        this.setColour('#C0CEA1');
        this.setTooltip('Information about a joint in an avatar\'s skeleton hierarchy.');
        this.setHelpUrl('https://apidocs.overte.org/SkeletonJoint');
    }
};
javascript.javascriptGenerator.forBlock['SkeletonJoint'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _parentIndex = dfv(generator.valueToCode(block, 'parentIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new SkeletonJoint(${_name},${_index},${_parentIndex})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['MyAvatar_getDefaultJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDefaultJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the default rotation of a joint (in the current avatar) relative to its parent.<p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDefaultJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDefaultJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getDefaultJointRotation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getDefaultJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDefaultJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the default translation of a joint (in the current avatar) relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDefaultJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDefaultJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getDefaultJointTranslation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAbsoluteDefaultJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAbsoluteDefaultJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the default joint rotations in avatar coordinates.The default pose of the avatar is defined by the position and orientation of all bonesin the avatar\'s model file. Typically this is a T-pose.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAbsoluteDefaultJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAbsoluteDefaultJointRotationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getAbsoluteDefaultJointRotationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAbsoluteDefaultJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAbsoluteDefaultJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the default joint translations in avatar coordinates.The default pose of the avatar is defined by the position and orientation of all bonesin the avatar\'s model file. Typically this is a T-pose.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAbsoluteDefaultJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAbsoluteDefaultJointTranslationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getAbsoluteDefaultJointTranslationInObjectFrame(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setColour('#DC476E');
        this.setTooltip('Sets the rotation of a joint relative to the avatar.<p><strong>Warning:</strong> Not able to be used in the <code>MyAvatar</code> API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.setAbsoluteJointRotationInObjectFrame(${_index},${_rotation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setColour('#DC476E');
        this.setTooltip('Sets the translation of a joint relative to the avatar.<p><strong>Warning:</strong> Not able to be used in the <code>MyAvatar</code> API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.setAbsoluteJointTranslationInObjectFrame(${_index},${_translation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_worldToJointPoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.worldToJointPoint')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#DC476E');
        this.setTooltip('Transforms a position in world coordinates to a position in a joint\'s coordinates, or avatar coordinates if no joint isspecified.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.worldToJointPoint');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_worldToJointPoint'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`MyAvatar.worldToJointPoint(${_position},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_worldToJointDirection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.worldToJointDirection')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#DC476E');
        this.setTooltip('Transforms a direction in world coordinates to a direction in a joint\'s coordinates, or avatar coordinates if no jointis specified.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.worldToJointDirection');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_worldToJointDirection'] = (block, generator) => {
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`MyAvatar.worldToJointDirection(${_direction},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_worldToJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.worldToJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#DC476E');
        this.setTooltip('Transforms a rotation in world coordinates to a rotation in a joint\'s coordinates, or avatar coordinates if no joint isspecified.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.worldToJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_worldToJointRotation'] = (block, generator) => {
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`MyAvatar.worldToJointRotation(${_rotation},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_jointToWorldPoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.jointToWorldPoint')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#DC476E');
        this.setTooltip('Transforms a position in a joint\'s coordinates, or avatar coordinates if no joint is specified, to a position in worldcoordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.jointToWorldPoint');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_jointToWorldPoint'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`MyAvatar.jointToWorldPoint(${_position},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_jointToWorldDirection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.jointToWorldDirection')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#DC476E');
        this.setTooltip('Transforms a direction in a joint\'s coordinates, or avatar coordinates if no joint is specified, to a direction in worldcoordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.jointToWorldDirection');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_jointToWorldDirection'] = (block, generator) => {
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`MyAvatar.jointToWorldDirection(${_direction},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_jointToWorldRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.jointToWorldRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#DC476E');
        this.setTooltip('Transforms a rotation in a joint\'s coordinates, or avatar coordinates if no joint is specified, to a rotation in worldcoordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.jointToWorldRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_jointToWorldRotation'] = (block, generator) => {
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`MyAvatar.jointToWorldRotation(${_rotation},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setSkeletonOffset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setSkeletonOffset')
        // Returns data

        // Params data
        this.appendValueInput('offset') 
            .setCheck('Vec3')
            .appendField('offset');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the offset applied to the current avatar. The offset adjusts the position that the avatar is rendered. For example,with an offset of <code>{ x: 0, y: 0.1, z: 0 }</code>, your avatar will appear to be raised off the ground slightly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setSkeletonOffset');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setSkeletonOffset'] = (block, generator) => {
    const _offset = dfv(generator.valueToCode(block, 'offset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setSkeletonOffset(${_offset});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getSkeletonOffset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getSkeletonOffset')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the offset applied to the current avatar. The offset adjusts the position that the avatar is rendered. For example,with an offset of <code>{ x: 0, y: 0.1, z: 0 }</code>, your avatar will appear to be raised off the ground slightly.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getSkeletonOffset');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getSkeletonOffset'] = (block, generator) => {

return [`MyAvatar.getSkeletonOffset()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of a joint in the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointPosition'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getJointPosition(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointPositionname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of a joint in the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointPositionname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.getJointPosition(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getNeckPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getNeckPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the current avatar\'s neck in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getNeckPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getNeckPosition'] = (block, generator) => {

return [`MyAvatar.getNeckPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getAcceleration'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getAcceleration')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current acceleration of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getAcceleration');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getAcceleration'] = (block, generator) => {

return [`MyAvatar.getAcceleration()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getWorldFeetPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getWorldFeetPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the current avatar\'s feet (or rather, bottom of its collision capsule) in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getWorldFeetPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getWorldFeetPosition'] = (block, generator) => {

return [`MyAvatar.getWorldFeetPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getParentID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getParentID')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the ID of the entity or avatar that the avatar is parented to.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getParentID');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getParentID'] = (block, generator) => {

return [`MyAvatar.getParentID()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setParentID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setParentID')
        // Returns data

        // Params data
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the ID of the entity or avatar that the avatar is parented to.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setParentID');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setParentID'] = (block, generator) => {
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setParentID(${_parentID});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getParentJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getParentJointIndex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the joint of the entity or avatar that the avatar is parented to.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getParentJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getParentJointIndex'] = (block, generator) => {

return [`MyAvatar.getParentJointIndex()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setParentJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setParentJointIndex')
        // Returns data

        // Params data
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the joint of the entity or avatar that the avatar is parented to.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setParentJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setParentJointIndex'] = (block, generator) => {
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setParentJointIndex(${_parentJointIndex});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getSkeleton'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getSkeleton')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets information on all the joints in the avatar\'s skeleton.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getSkeleton');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getSkeleton'] = (block, generator) => {

return [`MyAvatar.getSkeleton()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_targetScaleChanged'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.targetScaleChanged')
        // Returns data

        // Params data
        this.appendValueInput('targetScale') 
            .setCheck('Number')
            .appendField('targetScale');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s target scale is changed. The target scale is the desired scale of the avatar without anyrestrictions on permissible scale values imposed by the domain.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.targetScaleChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_targetScaleChanged'] = (block, generator) => {
    const _targetScale = dfv(generator.valueToCode(block, 'targetScale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.targetScaleChanged(${_targetScale});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getLeftPalmPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getLeftPalmPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the left palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getLeftPalmPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getLeftPalmPosition'] = (block, generator) => {

return [`MyAvatar.getLeftPalmPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getLeftPalmRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getLeftPalmRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotation of the left palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getLeftPalmRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getLeftPalmRotation'] = (block, generator) => {

return [`MyAvatar.getLeftPalmRotation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getRightPalmPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRightPalmPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the position of the right palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRightPalmPosition');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRightPalmPosition'] = (block, generator) => {

return [`MyAvatar.getRightPalmPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getRightPalmRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getRightPalmRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Get the rotation of the right palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getRightPalmRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getRightPalmRotation'] = (block, generator) => {

return [`MyAvatar.getRightPalmRotation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['ScriptAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');
        this.appendValueInput('handPosition') 
            .setCheck('Vec3')
            .appendField('handPosition');
        this.appendValueInput('bodyPitch') 
            .setCheck('Number')
            .appendField('bodyPitch');
        this.appendValueInput('bodyYaw') 
            .setCheck('Number')
            .appendField('bodyYaw');
        this.appendValueInput('bodyRoll') 
            .setCheck('Number')
            .appendField('bodyRoll');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('headOrientation') 
            .setCheck('Quat')
            .appendField('headOrientation');
        this.appendValueInput('headPitch') 
            .setCheck('Number')
            .appendField('headPitch');
        this.appendValueInput('headYaw') 
            .setCheck('Number')
            .appendField('headYaw');
        this.appendValueInput('headRoll') 
            .setCheck('Number')
            .appendField('headRoll');
        this.appendValueInput('velocity') 
            .setCheck('Vec3')
            .appendField('velocity');
        this.appendValueInput('angularVelocity') 
            .setCheck('Vec3')
            .appendField('angularVelocity');
        this.appendValueInput('sessionUUID') 
            .setCheck('Uuid')
            .appendField('sessionUUID');
        this.appendValueInput('displayName') 
            .setCheck('String')
            .appendField('displayName');
        this.appendValueInput('sessionDisplayName') 
            .setCheck('String')
            .appendField('sessionDisplayName');
        this.appendValueInput('isReplicated') 
            .setCheck('Boolean')
            .appendField('isReplicated');
        this.appendValueInput('lookAtSnappingEnabled') 
            .setCheck('Boolean')
            .appendField('lookAtSnappingEnabled');
        this.appendValueInput('skeletonModelURL') 
            .setCheck('String')
            .appendField('skeletonModelURL');
        this.appendValueInput('attachmentData') 
            .setCheck('Array')
            .appendField('attachmentData');
        this.appendValueInput('jointNames') 
            .setCheck('Array')
            .appendField('jointNames');
        this.appendValueInput('audioLoudness') 
            .setCheck('Number')
            .appendField('audioLoudness');
        this.appendValueInput('audioAverageLoudness') 
            .setCheck('Number')
            .appendField('audioAverageLoudness');
        this.appendValueInput('sensorToWorldMatrix') 
            .setCheck('Mat4')
            .appendField('sensorToWorldMatrix');
        this.appendValueInput('controllerLeftHandMatrix') 
            .setCheck('Mat4')
            .appendField('controllerLeftHandMatrix');
        this.appendValueInput('controllerRightHandMatrix') 
            .setCheck('Mat4')
            .appendField('controllerRightHandMatrix');
        this.appendValueInput('skeletonOffset') 
            .setCheck('Vec3')
            .appendField('skeletonOffset');
        this.setColour('#F98983');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Information about an avatar.<p>Create using {@link MyAvatar.getTargetAvatar} or {@link AvatarList.getAvatar}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _handPosition = dfv(generator.valueToCode(block, 'handPosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _bodyPitch = dfv(generator.valueToCode(block, 'bodyPitch', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _bodyYaw = dfv(generator.valueToCode(block, 'bodyYaw', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _bodyRoll = dfv(generator.valueToCode(block, 'bodyRoll', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _headOrientation = dfv(generator.valueToCode(block, 'headOrientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _headPitch = dfv(generator.valueToCode(block, 'headPitch', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _headYaw = dfv(generator.valueToCode(block, 'headYaw', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _headRoll = dfv(generator.valueToCode(block, 'headRoll', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _angularVelocity = dfv(generator.valueToCode(block, 'angularVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _sessionUUID = dfv(generator.valueToCode(block, 'sessionUUID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _displayName = dfv(generator.valueToCode(block, 'displayName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _sessionDisplayName = dfv(generator.valueToCode(block, 'sessionDisplayName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isReplicated = dfv(generator.valueToCode(block, 'isReplicated', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _lookAtSnappingEnabled = dfv(generator.valueToCode(block, 'lookAtSnappingEnabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _skeletonModelURL = dfv(generator.valueToCode(block, 'skeletonModelURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _attachmentData = dfv(generator.valueToCode(block, 'attachmentData', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointNames = dfv(generator.valueToCode(block, 'jointNames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _audioLoudness = dfv(generator.valueToCode(block, 'audioLoudness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _audioAverageLoudness = dfv(generator.valueToCode(block, 'audioAverageLoudness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _sensorToWorldMatrix = dfv(generator.valueToCode(block, 'sensorToWorldMatrix', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _controllerLeftHandMatrix = dfv(generator.valueToCode(block, 'controllerLeftHandMatrix', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _controllerRightHandMatrix = dfv(generator.valueToCode(block, 'controllerRightHandMatrix', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _skeletonOffset = dfv(generator.valueToCode(block, 'skeletonOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ScriptAvatar(${_position},${_scale},${_handPosition},${_bodyPitch},${_bodyYaw},${_bodyRoll},${_orientation},${_headOrientation},${_headPitch},${_headYaw},${_headRoll},${_velocity},${_angularVelocity},${_sessionUUID},${_displayName},${_sessionDisplayName},${_isReplicated},${_lookAtSnappingEnabled},${_skeletonModelURL},${_attachmentData},${_jointNames},${_audioLoudness},${_audioAverageLoudness},${_sensorToWorldMatrix},${_controllerLeftHandMatrix},${_controllerRightHandMatrix},${_skeletonOffset})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['ScriptAvatar_getDefaultJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getDefaultJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the default rotation of a joint in the avatar relative to its parent.<p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getDefaultJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getDefaultJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getDefaultJointRotation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getDefaultJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getDefaultJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the default translation of a joint in the avatar relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getDefaultJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getDefaultJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getDefaultJointTranslation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getSkeletonOffset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getSkeletonOffset')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the offset applied to the avatar for rendering.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getSkeletonOffset');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getSkeletonOffset'] = (block, generator) => {

return [`ScriptAvatar.getSkeletonOffset()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#F98983');
        this.setTooltip('Gets the position of a joint in the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointPosition');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointPosition'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`ScriptAvatar.getJointPosition(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getJointPositionname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getJointPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#F98983');
        this.setTooltip('Gets the position of a joint in the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getJointPosition');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getJointPositionname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ScriptAvatar.getJointPosition(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getNeckPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getNeckPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the position of the current avatar\'s neck in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getNeckPosition');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getNeckPosition'] = (block, generator) => {

return [`ScriptAvatar.getNeckPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getAcceleration'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getAcceleration')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the current acceleration of the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getAcceleration');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getAcceleration'] = (block, generator) => {

return [`ScriptAvatar.getAcceleration()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getParentID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getParentID')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the ID of the entity or avatar that the avatar is parented to.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getParentID');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getParentID'] = (block, generator) => {

return [`ScriptAvatar.getParentID()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getParentJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getParentJointIndex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the joint of the entity or avatar that the avatar is parented to.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getParentJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getParentJointIndex'] = (block, generator) => {

return [`ScriptAvatar.getParentJointIndex()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getSkeleton'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getSkeleton')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets information on all the joints in the avatar\'s skeleton.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getSkeleton');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getSkeleton'] = (block, generator) => {

return [`ScriptAvatar.getSkeleton()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getLeftPalmPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getLeftPalmPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the position of the left palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getLeftPalmPosition');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getLeftPalmPosition'] = (block, generator) => {

return [`ScriptAvatar.getLeftPalmPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getLeftPalmRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getLeftPalmRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the rotation of the left palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getLeftPalmRotation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getLeftPalmRotation'] = (block, generator) => {

return [`ScriptAvatar.getLeftPalmRotation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getLeftPalmPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getLeftPalmPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the position of the right palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getLeftPalmPosition');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getLeftPalmPosition'] = (block, generator) => {

return [`ScriptAvatar.getLeftPalmPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptAvatar_getLeftPalmRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptAvatar.getLeftPalmRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#F98983');
        this.setTooltip('Gets the rotation of the right palm in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptAvatar.html#.getLeftPalmRotation');
    }
};
javascript.javascriptGenerator.forBlock['ScriptAvatar_getLeftPalmRotation'] = (block, generator) => {

return [`ScriptAvatar.getLeftPalmRotation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Controller_Actions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Actions')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Actions</code> object has properties representing predefined actions on the user\'s avatar and Interface. The property values are integer IDs, uniquely identifying each action. <em>Read-only.</em></p><p>These actions can be used as end points in the routes of a {@link MappingObject}. The data item routed to each action is either a number or a {@link Pose}.</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Data</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td colSpan=4><strong>Avatar Movement</strong></td></tr>    <tr><td><code>TranslateX</code></td><td>number</td><td>number</td><td>Move the user\'s avatar in the direction of its       x-axis, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>TranslateY</code></td><td>number</td><td>number</td><td>Move the user\'s avatar in the direction of its       y-axis, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>TranslateZ</code></td><td>number</td><td>number</td><td>Move the user\'s avatar in the direction of its       z-axis, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>Pitch</code></td><td>number</td><td>number</td><td>Rotate the user\'s avatar head and attached camera       about its negative x-axis (i.e., positive values pitch down) at a rate proportional to the control value, if the       camera isn\'t in HMD, independent, or mirror modes.</td></tr>    <tr><td><code>Yaw</code></td><td>number</td><td>number</td><td>Rotate the user\'s avatar about its y-axis at a rate       proportional to the control value, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>Roll</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td><code>DeltaPitch</code></td><td>number</td><td>number</td><td>Rotate the user\'s avatar head and attached       camera about its negative x-axis (i.e., positive values pitch down) by an amount proportional to the control value,       if the camera isn\'t in HMD, independent, or mirror modes.</td></tr>    <tr><td><code>DeltaYaw</code></td><td>number</td><td>number</td><td>Rotate the user\'s avatar about its y-axis by an       amount proportional to the control value, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>DeltaRoll</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td><code>StepTranslateX</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td><code>StepTranslateY</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td><code>StepTranslateZ</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td><code>StepPitch</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td><code>StepYaw</code></td><td>number</td><td>number</td><td>Rotate the user\'s avatar about its y-axis in a       step increment, if the camera isn\'t in independent or mirror modes.</td></tr>    <tr><td><code>StepRoll</code></td><td>number</td><td>number</td><td>No action.</td></tr>    <tr><td colSpan=4><strong>Avatar Skeleton</strong></td></tr>    <tr><td><code>Hips</code></td><td>number</td><td>{@link Pose}</td><td>Set the hips pose of the user\'s avatar.      </td></tr>    <tr><td><code>Spine2</code></td><td>number</td><td>{@link Pose}</td><td>Set the spine2 pose of the user\'s avatar.      </td></tr>    <tr><td><code>Head</code></td><td>number</td><td>{@link Pose}</td><td>Set the head pose of the user\'s avatar.      </td></tr>    <tr><td><code>LeftArm</code></td><td>number</td><td>{@link Pose}</td><td>Set the left arm pose of the user\'s avatar.      </td></tr>    <tr><td><code>RightArm</code></td><td>number</td><td>{@link Pose}</td><td>Set the right arm pose of the user\'s       avatar.</td></tr>    <tr><td><code>LeftHand</code></td><td>number</td><td>{@link Pose}</td><td>Set the left hand pose of the user\'s      avatar.</td></tr>    <tr><td><code>LeftHandThumb1</code></td><td>number</td><td>{@link Pose}</td><td>Set the left thumb 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandThumb2</code></td><td>number</td><td>{@link Pose}</td><td>Set the left thumb 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandThumb3</code></td><td>number</td><td>{@link Pose}</td><td>Set the left thumb 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandThumb4</code></td><td>number</td><td>{@link Pose}</td><td>Set the left thumb 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandIndex1</code></td><td>number</td><td>{@link Pose}</td><td>Set the left index 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandIndex2</code></td><td>number</td><td>{@link Pose}</td><td>Set the left index 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandIndex3</code></td><td>number</td><td>{@link Pose}</td><td>Set the left index 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandIndex4</code></td><td>number</td><td>{@link Pose}</td><td>Set the left index 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandMiddle1</code></td><td>number</td><td>{@link Pose}</td><td>Set the left middle 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandMiddle2</code></td><td>number</td><td>{@link Pose}</td><td>Set the left middle 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandMiddle3</code></td><td>number</td><td>{@link Pose}</td><td>Set the left middle 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandMiddle4</code></td><td>number</td><td>{@link Pose}</td><td>Set the left middle 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandRing1</code></td><td>number</td><td>{@link Pose}</td><td>Set the left ring 1 finger joint pose       of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandRing2</code></td><td>number</td><td>{@link Pose}</td><td>Set the left ring 2 finger joint pose       of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandRing3</code></td><td>number</td><td>{@link Pose}</td><td>Set the left ring 3 finger joint pose       of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandRing4</code></td><td>number</td><td>{@link Pose}</td><td>Set the left ring 4 finger joint pose       of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandPinky1</code></td><td>number</td><td>{@link Pose}</td><td>Set the left pinky 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandPinky2</code></td><td>number</td><td>{@link Pose}</td><td>Set the left pinky 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandPinky3</code></td><td>number</td><td>{@link Pose}</td><td>Set the left pinky 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftHandPinky4</code></td><td>number</td><td>{@link Pose}</td><td>Set the left pinky 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHand</code></td><td>number</td><td>{@link Pose}</td><td>Set the right hand of the user\'s avatar.      </td></tr>    <tr><td><code>RightHandThumb1</code></td><td>number</td><td>{@link Pose}</td><td>Set the right thumb 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandThumb2</code></td><td>number</td><td>{@link Pose}</td><td>Set the right thumb 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandThumb3</code></td><td>number</td><td>{@link Pose}</td><td>Set the right thumb 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandThumb4</code></td><td>number</td><td>{@link Pose}</td><td>Set the right thumb 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandIndex1</code></td><td>number</td><td>{@link Pose}</td><td>Set the right index 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandIndex2</code></td><td>number</td><td>{@link Pose}</td><td>Set the right index 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandIndex3</code></td><td>number</td><td>{@link Pose}</td><td>Set the right index 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandIndex4</code></td><td>number</td><td>{@link Pose}</td><td>Set the right index 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandMiddle1</code></td><td>number</td><td>{@link Pose}</td><td>Set the right middle 1 finger       joint pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandMiddle2</code></td><td>number</td><td>{@link Pose}</td><td>Set the right middle 2 finger       joint pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandMiddle3</code></td><td>number</td><td>{@link Pose}</td><td>Set the right middle 3 finger       joint pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandMiddle4</code></td><td>number</td><td>{@link Pose}</td><td>Set the right middle 4 finger       joint pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandRing1</code></td><td>number</td><td>{@link Pose}</td><td>Set the right ring 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandRing2</code></td><td>number</td><td>{@link Pose}</td><td>Set the right ring 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandRing3</code></td><td>number</td><td>{@link Pose}</td><td>Set the right ring 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandRing4</code></td><td>number</td><td>{@link Pose}</td><td>Set the right ring 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandPinky1</code></td><td>number</td><td>{@link Pose}</td><td>Set the right pinky 1 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandPinky2</code></td><td>number</td><td>{@link Pose}</td><td>Set the right pinky 2 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandPinky3</code></td><td>number</td><td>{@link Pose}</td><td>Set the right pinky 3 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>RightHandPinky4</code></td><td>number</td><td>{@link Pose}</td><td>Set the right pinky 4 finger joint       pose of the user\'s avatar.</td></tr>    <tr><td><code>LeftFoot</code></td><td>number</td><td>{@link Pose}</td><td>Set the left foot pose of the user\'s      avatar.</td></tr>    <tr><td><code>RightFoot</code></td><td>number</td><td>{@link Pose}</td><td>Set the right foot pose of the user\'s      avatar.</td></tr>    <tr><td colSpan=4><strong>Application</strong></td></tr>    <tr><td><code>BoomIn</code></td><td>number</td><td>number</td><td>Zoom camera in from third person toward first       person view.</td></tr>    <tr><td><code>BoomOut</code></td><td>number</td><td>number</td><td>Zoom camera out from first person to third       person view.</td></tr>    <tr><td><code>CycleCamera</code></td><td>number</td><td>number</td><td>Cycle the camera view from first person look       at, to (third person) look at, to selfie if in desktop mode, then back to first person and repeat.</td></tr>    <tr><td><code>ContextMenu</code></td><td>number</td><td>number</td><td>Show/hide the tablet.</td></tr>    <tr><td><code>ToggleMute</code></td><td>number</td><td>number</td><td>Toggle the microphone mute.</td></tr>    <tr><td><code>TogglePushToTalk</code></td><td>number</td><td>number</td><td>Toggle push to talk.</td></tr>    <tr><td><code>ToggleOverlay</code></td><td>number</td><td>number</td><td>Toggle the display of overlays.</td></tr>    <tr><td><code>Sprint</code></td><td>number</td><td>number</td><td>Set avatar sprint mode.</td></tr>    <tr><td><code>ReticleClick</code></td><td>number</td><td>number</td><td>Set mouse-pressed.</td></tr>    <tr><td><code>ReticleX</code></td><td>number</td><td>number</td><td>Move the cursor left/right in the x direction.      </td></tr>    <tr><td><code>ReticleY</code></td><td>number</td><td>number</td><td>move the cursor up/down in the y direction.      </td></tr>    <tr><td><code>ReticleLeft</code></td><td>number</td><td>number</td><td>Move the cursor left.</td></tr>    <tr><td><code>ReticleRight</code></td><td>number</td><td>number</td><td>Move the cursor right.</td></tr>    <tr><td><code>ReticleUp</code></td><td>number</td><td>number</td><td>Move the cursor up.</td></tr>    <tr><td><code>ReticleDown</code></td><td>number</td><td>number</td><td>Move the cursor down.</td></tr>    <tr><td><code>UiNavLateral</code></td><td>number</td><td>number</td><td>Generate a keyboard left or right arrow key       event.</td></tr>    <tr><td><code>UiNavVertical</code></td><td>number</td><td>number</td><td>Generate a keyboard up or down arrow key       event.</td></tr>    <tr><td><code>UiNavGroup</code></td><td>number</td><td>number</td><td>Generate a keyboard tab or back-tab key event.      </td></tr>    <tr><td><code>UiNavSelect</code></td><td>number</td><td>number</td><td>Generate a keyboard Enter key event.      </td></tr>    <tr><td><code>UiNavBack</code></td><td>number</td><td>number</td><td>Generate a keyboard Esc key event.</td></tr>    <tr><td><code>LeftHandClick</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>RightHandClick</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>Shift</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>PrimaryAction</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>SecondaryAction</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td colSpan=4><strong>Aliases</strong></td></tr>    <tr><td><code>Backward</code></td><td>number</td><td>number</td><td>Alias for <code>TranslateZ</code> in the       positive direction.</td></tr>    <tr><td><code>Forward</code></td><td>number</td><td>number</td><td>Alias for <code>TranslateZ</code> in the negative       direction.</td></tr>    <tr><td><code>StrafeRight</code></td><td>number</td><td>number</td><td>Alias for <code>TranslateX</code> in the      positive direction.</td></tr>    <tr><td><code>StrafeLeft</code></td><td>number</td><td>number</td><td>Alias for <code>TranslateX</code> in the      negative direction.</td></tr>    <tr><td><code>Up</code></td><td>number</td><td>number</td><td>Alias for <code>TranslateY</code> in the positive      direction.</td></tr>    <tr><td><code>Down</code></td><td>number</td><td>number</td><td>Alias for <code>TranslateY</code> in the negative       direction.</td></tr>    <tr><td><code>PitchDown</code></td><td>number</td><td>number</td><td>Alias for <code>Pitch</code> in the positive       direction.</td></tr>    <tr><td><code>PitchUp</code></td><td>number</td><td>number</td><td>Alias for <code>Pitch</code> in the negative      direction.</td></tr>    <tr><td><code>YawLeft</code></td><td>number</td><td>number</td><td>Alias for <code>Yaw</code> in the positive      direction.</td></tr>    <tr><td><code>YawRight</code></td><td>number</td><td>number</td><td>Alias for <code>Yaw</code> in the negative       direction.</td></tr>    <tr><td colSpan=4><strong>Deprecated Aliases</strong></td></tr>    <tr><td><code>LEFT_HAND</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>LeftHand</code> instead.</span></td></tr>    <tr><td><code>RIGHT_HAND</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>RightHand</code> instead.</span></td></tr>    <tr><td><code>BOOM_IN</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>BoomIn</code> instead.</span></td></tr>    <tr><td><code>BOOM_OUT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>BoomOut</code> instead.</span></td></tr>    <tr><td><code>CONTEXT_MENU</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>ContextMenu</code> instead.</span></td></tr>    <tr><td><code>TOGGLE_MUTE</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>ToggleMute</code> instead.</span></td></tr>    <tr><td><code>TOGGLE_PUSHTOTALK</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>TogglePushToTalk</code> instead.</span></td></tr>    <tr><td><code>SPRINT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>Sprint</code> instead.</span></td></tr>    <tr><td><code>LONGITUDINAL_BACKWARD</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>Backward</code> instead.</span></td></tr>    <tr><td><code>LONGITUDINAL_FORWARD</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>Forward</code> instead.</span></td></tr>    <tr><td><code>LATERAL_LEFT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>StrafeLeft</code> instead.</span></td></tr>    <tr><td><code>LATERAL_RIGHT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>StrafeRight</code> instead.</span></td></tr>    <tr><td><code>VERTICAL_UP</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>Up</code> instead.</span></td></tr>    <tr><td><code>VERTICAL_DOWN</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>Down</code> instead.</span></td></tr>    <tr><td><code>PITCH_DOWN</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>PitchDown</code> instead.</span></td></tr>    <tr><td><code>PITCH_UP</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>PitchUp</code> instead.</span></td></tr>    <tr><td><code>YAW_LEFT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>YawLeft</code> instead.</span></td></tr>    <tr><td><code>YAW_RIGHT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>YawRight</code> instead.</span></td></tr>    <tr><td><code>LEFT_HAND_CLICK</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>LeftHandClick</code> instead.</span></td></tr>    <tr><td><code>RIGHT_HAND_CLICK</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>RightHandClick</code> instead.</span></td></tr>    <tr><td><code>SHIFT</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>Shift</code> instead.</span></td></tr>    <tr><td><code>ACTION1</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>PrimaryAction</code> instead.</span></td></tr>    <tr><td><code>ACTION2</code></td><td>number</td><td>number</td><td><span class="important">Deprecated: This       action is deprecated and will be removed. Use <code>SecondaryAction</code> instead.</span></td></tr>    <tr><td colSpan=4><strong>Deprecated Trackers</strong></td><tr>    <tr><td><code>TrackedObject00</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject01</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject02</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject03</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject04</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject05</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject06</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject07</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject08</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject09</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject10</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject11</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject12</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject13</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject14</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>    <tr><td><code>TrackedObject15</code></td><td>number</td><td>{@link Pose}</td><td><span class="important">Deprecated:       This action is deprecated and will be removed. It takes no action.</span></td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Actions');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Actions'] = (block, generator) => {

    return [`new Controller.Actions()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_Hand'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hand')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>Some controller actions may be associated with one or both hands:</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>Left hand.</td></tr>    <tr><td><code>1</code></td><td>Right hand.</td></tr>    <tr><td><code>2</code></td><td>Both hands.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hand');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hand'] = (block, generator) => {

    return [`new Controller.Hand()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_Hardware'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hardware')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Hardware</code> object has properties representing standard and hardware-specific controller and computer outputs, plus predefined actions on Interface and the user\'s avatar. <em>Read-only.</em></p><p>The outputs can be mapped to actions or functions in a {@link RouteObject} mapping. Additionally, hardware-specific controller outputs can be mapped to standard controller outputs. <p>Controllers typically implement a subset of the {@link Controller.Standard} controls, plus they may implement some extras. Some common controllers are included in the table. You can see the outputs provided by these and others by viewing their {@link Controller.MappingJSON|MappingJSON} files at <a href="https://github.com/highfidelity/hifi/tree/master/interface/resources/controllers">https://github.com/highfidelity/hifi/tree/master/interface/resources/controllers</a>.</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>Controller.Hardware.Actions</code></td><td>object</td><td>Synonym for {@link Controller.Actions}.</td></tr>    <tr><td><code>Controller.Hardware.Application</code></td><td>object</td><td>Interface state outputs. See       {@link Controller.Hardware-Application}.</td></tr>    <tr><td><code>Controller.Hardware.Keyboard</code></td><td>object</td><td>Keyboard, mouse, and touch pad outputs. See      {@link Controller.Hardware-Keyboard}.</td></tr>    <tr><td><code>Controller.Hardware.OculusTouch</code></td><td>object</td><td>Oculus Rift HMD outputs. See      {@link Controller.Hardware-OculusTouch}.</td></tr>    <tr><td><code>Controller.Hardware.Vive</code></td><td>object</td><td>Vive HMD outputs. See      {@link Controller.Hardware-Vive}.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hardware');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hardware'] = (block, generator) => {

    return [`new Controller.Hardware()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Pose'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Pose')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('velocity') 
            .setCheck('Vec3')
            .appendField('velocity');
        this.appendValueInput('angularVelocity') 
            .setCheck('Vec3')
            .appendField('angularVelocity');
        this.appendValueInput('valid') 
            .setCheck('Boolean')
            .appendField('valid');
        this.setColour('#8109C9');
        this.setTooltip('The pose of a joint or other item relative to the world or a parent.');
        this.setHelpUrl('https://apidocs.overte.org/Pose');
    }
};
javascript.javascriptGenerator.forBlock['Pose'] = (block, generator) => {
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _angularVelocity = dfv(generator.valueToCode(block, 'angularVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _valid = dfv(generator.valueToCode(block, 'valid', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Pose(${_translation},${_rotation},${_velocity},${_angularVelocity},${_valid})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Controller_getDeviceName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getDeviceName')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('deviceID') 
            .setCheck('Number')
            .appendField('deviceID');

        this.setColour('#9BBF37');
        this.setTooltip('Finds the name of a particular controller from its device ID.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getDeviceName');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getDeviceName'] = (block, generator) => {
    const _deviceID = dfv(generator.valueToCode(block, 'deviceID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Controller.getDeviceName(${_deviceID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getActionValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getActionValue')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('actionID') 
            .setCheck('Number')
            .appendField('actionID');

        this.setColour('#9BBF37');
        this.setTooltip('Gets the current value of an action.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getActionValue');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getActionValue'] = (block, generator) => {
    const _actionID = dfv(generator.valueToCode(block, 'actionID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Controller.getActionValue(${_actionID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_findDevice'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.findDevice')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('deviceName') 
            .setCheck('String')
            .appendField('deviceName');

        this.setColour('#9BBF37');
        this.setTooltip('Finds the ID of a specific controller from its device name.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.findDevice');
    }
};
javascript.javascriptGenerator.forBlock['Controller_findDevice'] = (block, generator) => {
    const _deviceName = dfv(generator.valueToCode(block, 'deviceName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Controller.findDevice(${_deviceName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getDeviceNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getDeviceNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the names of all currently available controller devices plus "Actions", "Application", and "Standard".');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getDeviceNames');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getDeviceNames'] = (block, generator) => {

return [`Controller.getDeviceNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_findAction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.findAction')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('actionName') 
            .setCheck('String')
            .appendField('actionName');

        this.setColour('#9BBF37');
        this.setTooltip('Finds the ID of an action from its name.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.findAction');
    }
};
javascript.javascriptGenerator.forBlock['Controller_findAction'] = (block, generator) => {
    const _actionName = dfv(generator.valueToCode(block, 'actionName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Controller.findAction(${_actionName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getActionNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getActionNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the names of all actions available as properties of {@link Controller.Actions}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getActionNames');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getActionNames'] = (block, generator) => {

return [`Controller.getActionNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getValue')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('source') 
            .setCheck('Number')
            .appendField('source');

        this.setColour('#9BBF37');
        this.setTooltip('Gets the value of a controller button or axis output. Note: Also gets the value of a controller axis output.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getValue');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getValue'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Controller.getValue(${_source})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getAxisValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getAxisValue')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('source') 
            .setCheck('Number')
            .appendField('source');

        this.setColour('#9BBF37');
        this.setTooltip('Gets the value of a controller axis output. Note: Also gets the value of a controller button output.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getAxisValue');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getAxisValue'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Controller.getAxisValue(${_source})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getPoseValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getPoseValue')
        // Returns data
        this.setOutput(true, '["Pose"]');

        // Params data
        this.appendValueInput('source') 
            .setCheck('Number')
            .appendField('source');

        this.setColour('#9BBF37');
        this.setTooltip('Gets the value of a controller pose output.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getPoseValue');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getPoseValue'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Controller.getPoseValue(${_source})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_triggerHapticPulse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.triggerHapticPulse')
        // Returns data

        // Params data
        this.appendValueInput('strength') 
            .setCheck('Number')
            .appendField('strength');
        this.appendValueInput('duration') 
            .setCheck('Number')
            .appendField('duration');
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Triggers a haptic pulse on connected and enabled devices that have the capability.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.triggerHapticPulse');
    }
};
javascript.javascriptGenerator.forBlock['Controller_triggerHapticPulse'] = (block, generator) => {
    const _strength = dfv(generator.valueToCode(block, 'strength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _duration = dfv(generator.valueToCode(block, 'duration', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);


    return `Controller.triggerHapticPulse(${_strength},${_duration},${_index});\n`;};


// Blockly function
Blockly.Blocks['Controller_triggerShortHapticPulse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.triggerShortHapticPulse')
        // Returns data

        // Params data
        this.appendValueInput('strength') 
            .setCheck('Number')
            .appendField('strength');
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Triggers a 250ms haptic pulse on connected and enabled devices that have the capability.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.triggerShortHapticPulse');
    }
};
javascript.javascriptGenerator.forBlock['Controller_triggerShortHapticPulse'] = (block, generator) => {
    const _strength = dfv(generator.valueToCode(block, 'strength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);


    return `Controller.triggerShortHapticPulse(${_strength},${_index});\n`;};


// Blockly function
Blockly.Blocks['Controller_triggerHapticPulseOnDevice'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.triggerHapticPulseOnDevice')
        // Returns data

        // Params data
        this.appendValueInput('deviceID') 
            .setCheck('Number')
            .appendField('deviceID');
        this.appendValueInput('strength') 
            .setCheck('Number')
            .appendField('strength');
        this.appendValueInput('duration') 
            .setCheck('Number')
            .appendField('duration');
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Triggers a haptic pulse on a particular device if connected and enabled and it has the capability.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.triggerHapticPulseOnDevice');
    }
};
javascript.javascriptGenerator.forBlock['Controller_triggerHapticPulseOnDevice'] = (block, generator) => {
    const _deviceID = dfv(generator.valueToCode(block, 'deviceID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _strength = dfv(generator.valueToCode(block, 'strength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _duration = dfv(generator.valueToCode(block, 'duration', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);


    return `Controller.triggerHapticPulseOnDevice(${_deviceID},${_strength},${_duration},${_index});\n`;};


// Blockly function
Blockly.Blocks['Controller_triggerShortHapticPulseOnDevice'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.triggerShortHapticPulseOnDevice')
        // Returns data

        // Params data
        this.appendValueInput('deviceID') 
            .setCheck('Number')
            .appendField('deviceID');
        this.appendValueInput('strength') 
            .setCheck('Number')
            .appendField('strength');
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Triggers a 250ms haptic pulse on a particular device if connected and enabled and it has the capability.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.triggerShortHapticPulseOnDevice');
    }
};
javascript.javascriptGenerator.forBlock['Controller_triggerShortHapticPulseOnDevice'] = (block, generator) => {
    const _deviceID = dfv(generator.valueToCode(block, 'deviceID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _strength = dfv(generator.valueToCode(block, 'strength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);


    return `Controller.triggerShortHapticPulseOnDevice(${_deviceID},${_strength},${_index});\n`;};


// Blockly function
Blockly.Blocks['Controller_newMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.newMapping')
        // Returns data
        this.setOutput(true, '["MappingObject"]');

        // Params data
        this.appendValueInput('mappingName') 
            .setCheck('String')
            .appendField('mappingName');

        this.setColour('#9BBF37');
        this.setTooltip('Creates a new controller mapping. Routes can then be added to the mapping using {@link MappingObject} methods and routed to <code>Standard</code> controls, <code>Actions</code>, or script functions using {@link RouteObject} methods. The mapping can then be enabled using {@link Controller.enableMapping|enableMapping} for it to take effect.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.newMapping');
    }
};
javascript.javascriptGenerator.forBlock['Controller_newMapping'] = (block, generator) => {
    const _mappingName = dfv(generator.valueToCode(block, 'mappingName', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.generate()`);

return [`Controller.newMapping(${_mappingName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_enableMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.enableMapping')
        // Returns data

        // Params data
        this.appendValueInput('mappingName') 
            .setCheck('String')
            .appendField('mappingName');
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Enables or disables a controller mapping. When enabled, the routes in the mapping have effect.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.enableMapping');
    }
};
javascript.javascriptGenerator.forBlock['Controller_enableMapping'] = (block, generator) => {
    const _mappingName = dfv(generator.valueToCode(block, 'mappingName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);


    return `Controller.enableMapping(${_mappingName},${_enable});\n`;};


// Blockly function
Blockly.Blocks['Controller_disableMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.disableMapping')
        // Returns data

        // Params data
        this.appendValueInput('mappingName') 
            .setCheck('String')
            .appendField('mappingName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables a controller mapping. When disabled, the routes in the mapping have no effect.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.disableMapping');
    }
};
javascript.javascriptGenerator.forBlock['Controller_disableMapping'] = (block, generator) => {
    const _mappingName = dfv(generator.valueToCode(block, 'mappingName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Controller.disableMapping(${_mappingName});\n`;};


// Blockly function
Blockly.Blocks['Controller_parseMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.parseMapping')
        // Returns data
        this.setOutput(true, '["MappingObject"]');

        // Params data
        this.appendValueInput('jsonString') 
            .setCheck('String')
            .appendField('jsonString');

        this.setColour('#9BBF37');
        this.setTooltip('Creates a new controller mapping from a {@link Controller.MappingJSON|MappingJSON} string. Use {@link Controller.enableMapping|enableMapping} to enable the mapping for it to take effect.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.parseMapping');
    }
};
javascript.javascriptGenerator.forBlock['Controller_parseMapping'] = (block, generator) => {
    const _jsonString = dfv(generator.valueToCode(block, 'jsonString', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Controller.parseMapping(${_jsonString})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_loadMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.loadMapping')
        // Returns data
        this.setOutput(true, '["MappingObject"]');

        // Params data
        this.appendValueInput('jsonURL') 
            .setCheck('String')
            .appendField('jsonURL');

        this.setColour('#9BBF37');
        this.setTooltip('Creates a new controller mapping from a {@link Controller.MappingJSON|MappingJSON} JSON file at a URL. Use {@link Controller.enableMapping|enableMapping} to enable the mapping for it to take effect.<p><strong>Warning:</strong> This function is not yet implemented; it doesn\'t load a mapping and just returns <code>null</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.loadMapping');
    }
};
javascript.javascriptGenerator.forBlock['Controller_loadMapping'] = (block, generator) => {
    const _jsonURL = dfv(generator.valueToCode(block, 'jsonURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Controller.loadMapping(${_jsonURL})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getHardware'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getHardware')
        // Returns data
        this.setOutput(true, '["Controller.Hardware"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the {@link Controller.Hardware} property tree. Calling this function is the same as using the {@link Controller} property, <code>Controller.Hardware</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getHardware');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getHardware'] = (block, generator) => {

return [`Controller.getHardware()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getActions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getActions')
        // Returns data
        this.setOutput(true, '["Controller.Actions"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the {@link Controller.Actions} property tree. Calling this function is the same as using the {@link Controller} property, <code>Controller.Actions</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getActions');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getActions'] = (block, generator) => {

return [`Controller.getActions()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getStandard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getStandard')
        // Returns data
        this.setOutput(true, '["Controller.Standard"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the {@link Controller.Standard} property tree. Calling this function is the same as using the {@link Controller} property, <code>Controller.Standard</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getStandard');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getStandard'] = (block, generator) => {

return [`Controller.getStandard()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_startInputRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.startInputRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Starts making a recording of currently active controllers.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.startInputRecording');
    }
};
javascript.javascriptGenerator.forBlock['Controller_startInputRecording'] = (block, generator) => {


    return `Controller.startInputRecording();\n`;};


// Blockly function
Blockly.Blocks['Controller_stopInputRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.stopInputRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Stops making a recording started by {@link Controller.startInputRecording|startInputRecording}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.stopInputRecording');
    }
};
javascript.javascriptGenerator.forBlock['Controller_stopInputRecording'] = (block, generator) => {


    return `Controller.stopInputRecording();\n`;};


// Blockly function
Blockly.Blocks['Controller_startInputPlayback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.startInputPlayback')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Plays back the current recording from the beginning. The current recording may have been recorded by {@link Controller.startInputRecording|startInputRecording} and {@link Controller.stopInputRecording|stopInputRecording}, or loaded by {@link Controller.loadInputRecording|loadInputRecording}. Playback repeats in a loop until {@link Controller.stopInputPlayback|stopInputPlayback} is called.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.startInputPlayback');
    }
};
javascript.javascriptGenerator.forBlock['Controller_startInputPlayback'] = (block, generator) => {


    return `Controller.startInputPlayback();\n`;};


// Blockly function
Blockly.Blocks['Controller_stopInputPlayback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.stopInputPlayback')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Stops play back of a recording started by {@link Controller.startInputPlayback|startInputPlayback}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.stopInputPlayback');
    }
};
javascript.javascriptGenerator.forBlock['Controller_stopInputPlayback'] = (block, generator) => {


    return `Controller.stopInputPlayback();\n`;};


// Blockly function
Blockly.Blocks['Controller_saveInputRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.saveInputRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Saves the current recording to a file. The current recording may have been recorded by{@link Controller.startInputRecording|startInputRecording} and{@link Controller.stopInputRecording|stopInputRecording}, or loaded by{@link Controller.loadInputRecording|loadInputRecording}. It is saved in the directory returned by {@link Controller.getInputRecorderSaveDirectory|getInputRecorderSaveDirectory}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.saveInputRecording');
    }
};
javascript.javascriptGenerator.forBlock['Controller_saveInputRecording'] = (block, generator) => {


    return `Controller.saveInputRecording();\n`;};


// Blockly function
Blockly.Blocks['Controller_loadInputRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.loadInputRecording')
        // Returns data

        // Params data
        this.appendValueInput('file') 
            .setCheck('String')
            .appendField('file');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Loads an input recording, ready for play back.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.loadInputRecording');
    }
};
javascript.javascriptGenerator.forBlock['Controller_loadInputRecording'] = (block, generator) => {
    const _file = dfv(generator.valueToCode(block, 'file', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Controller.loadInputRecording(${_file});\n`;};


// Blockly function
Blockly.Blocks['Controller_getInputRecorderSaveDirectory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getInputRecorderSaveDirectory')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the directory in which input recordings are saved.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getInputRecorderSaveDirectory');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getInputRecorderSaveDirectory'] = (block, generator) => {

return [`Controller.getInputRecorderSaveDirectory()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_getRunningInputDevices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.getRunningInputDevices')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#9BBF37');
        this.setTooltip('Gets the names of all the active and running (enabled) input devices.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.getRunningInputDevices');
    }
};
javascript.javascriptGenerator.forBlock['Controller_getRunningInputDevices'] = (block, generator) => {

return [`Controller.getRunningInputDevices()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Controller_captureMouseEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.captureMouseEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables processing of mouse "move", "press", "double-press", and "release" events into {@link Controller.Hardware|Controller.Hardware.Keyboard} outputs.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.captureMouseEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_captureMouseEvents'] = (block, generator) => {


    return `Controller.captureMouseEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_releaseMouseEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.releaseMouseEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Enables processing of mouse "move", "press", "double-press", and "release" events into {@link Controller.Hardware-Keyboard|Controller.Hardware.Keyboard} outputs that were disabled using {@link Controller.captureMouseEvents|captureMouseEvents}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.releaseMouseEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_releaseMouseEvents'] = (block, generator) => {


    return `Controller.releaseMouseEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_captureTouchEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.captureTouchEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables processing of touch "begin", "update", and "end" events into {@link Controller.Hardware|Controller.Hardware.Keyboard}, {@link Controller.Hardware|Controller.Hardware.Touchscreen}, and {@link Controller.Hardware|Controller.Hardware.TouchscreenVirtualPad} outputs.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.captureTouchEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_captureTouchEvents'] = (block, generator) => {


    return `Controller.captureTouchEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_releaseTouchEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.releaseTouchEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Enables processing of touch "begin", "update", and "end" events into {@link Controller.Hardware|Controller.Hardware.Keyboard}, {@link Controller.Hardware|Controller.Hardware.Touchscreen}, and {@link Controller.Hardware|Controller.Hardware.TouchscreenVirtualPad} outputs that were disabled using {@link Controller.captureTouchEvents|captureTouchEvents}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.releaseTouchEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_releaseTouchEvents'] = (block, generator) => {


    return `Controller.releaseTouchEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_captureWheelEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.captureWheelEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables processing of mouse wheel rotation events into {@link Controller.Hardware|Controller.Hardware.Keyboard} outputs.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.captureWheelEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_captureWheelEvents'] = (block, generator) => {


    return `Controller.captureWheelEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_releaseWheelEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.releaseWheelEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Enables processing of mouse wheel rotation events into {@link Controller.Hardware|Controller.Hardware.Keyboard} outputs that wer disabled using {@link Controller.captureWheelEvents|captureWheelEvents}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.releaseWheelEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_releaseWheelEvents'] = (block, generator) => {


    return `Controller.releaseWheelEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_captureActionEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.captureActionEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Disables translating and rotating the user\'s avatar in response to keyboard and controller controls.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.captureActionEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_captureActionEvents'] = (block, generator) => {


    return `Controller.captureActionEvents();\n`;};


// Blockly function
Blockly.Blocks['Controller_releaseActionEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.releaseActionEvents')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9BBF37');
        this.setTooltip('Enables translating and rotating the user\'s avatar in response to keyboard and controller controls that were disabled using {@link Controller.captureActionEvents|captureActionEvents}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.releaseActionEvents');
    }
};
javascript.javascriptGenerator.forBlock['Controller_releaseActionEvents'] = (block, generator) => {


    return `Controller.releaseActionEvents();\n`;};


// Blockly signal
Blockly.Blocks['Controller_actionEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.actionEvent');

        this.appendDummyInput('actionID')
            .appendField('actionID:')
            .appendField(new Blockly.FieldVariable('actionEvent_actionID'), 'actionID');
        this.appendDummyInput('value')
            .appendField('value:')
            .appendField(new Blockly.FieldVariable('actionEvent_value'), 'value');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when an action occurs.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.actionEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_actionEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const actionID = generator.getVariableName(block.getFieldValue('actionID'));
    const value = generator.getVariableName(block.getFieldValue('value'));

return `Controller.actionEvent.connect((_actionID,_value) => { 
  ${actionID} = _actionID; 
  ${value} = _value;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_inputEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.inputEvent');

        this.appendDummyInput('action')
            .appendField('action:')
            .appendField(new Blockly.FieldVariable('inputEvent_action'), 'action');
        this.appendDummyInput('value')
            .appendField('value:')
            .appendField(new Blockly.FieldVariable('inputEvent_value'), 'value');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when there is a new controller input event.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.inputEvent');
    }
};
javascript.javascriptGenerator.forBlock['Controller_inputEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const action = generator.getVariableName(block.getFieldValue('action'));
    const value = generator.getVariableName(block.getFieldValue('value'));

return `Controller.inputEvent.connect((_action,_value) => { 
  ${action} = _action; 
  ${value} = _value;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_hardwareChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.hardwareChanged');


        this.setColour('#9BBF37');
        this.setTooltip('Triggered when a device is registered or unregistered by a plugin. Not all plugins generate <code>hardwareChanged</code> events: for example, connecting or disconnecting a mouse will not generate an event but connecting or disconnecting an Xbox controller will.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.hardwareChanged');
    }
};
javascript.javascriptGenerator.forBlock['Controller_hardwareChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Controller.hardwareChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Controller_inputDeviceRunningChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Controller.inputDeviceRunningChanged');

        this.appendDummyInput('deviceName')
            .appendField('deviceName:')
            .appendField(new Blockly.FieldVariable('inputDeviceRunningChanged_deviceName'), 'deviceName');
        this.appendDummyInput('isRunning')
            .appendField('isRunning:')
            .appendField(new Blockly.FieldVariable('inputDeviceRunningChanged_isRunning'), 'isRunning');

        this.setColour('#9BBF37');
        this.setTooltip('Triggered when an input device starts or stops being active and running (enabled). For example, enabling or disabling the LeapMotion in Settings &gt; Controls &gt; Calibration will trigger this signal.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.inputDeviceRunningChanged');
    }
};
javascript.javascriptGenerator.forBlock['Controller_inputDeviceRunningChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const deviceName = generator.getVariableName(block.getFieldValue('deviceName'));
    const isRunning = generator.getVariableName(block.getFieldValue('isRunning'));

return `Controller.inputDeviceRunningChanged.connect((_deviceName,_isRunning) => { 
  ${deviceName} = _deviceName; 
  ${isRunning} = _isRunning;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Controller_Standard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Standard')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Standard</code> object has properties representing standard controller outputs. Those for physical controllers are based on the XBox controller, with aliases for PlayStation. The property values are integer IDs, uniquely identifying each output. <em>Read-only.</em></p><p>These outputs can be mapped to actions or functions in a {@link RouteObject} mapping. The data value provided by each control is either a number or a {@link Pose}. Numbers are typically normalized to <code>0.0</code> or <code>1.0</code> for button states, the range <code>0.0</code> &ndash; <code>1.0</code> for unidirectional scales, and the range <code>-1.0</code> &ndash; <code>1.0</code> for bidirectional scales.</p><p>Each hardware device has a mapping from its outputs to a subset of <code>Controller.Standard</code> items, specified in a JSON file. For example, <a href="https://github.com/highfidelity/hifi/blob/master/interface/resources/controllers/vive.json">vive.json</a>and <a href="https://github.com/highfidelity/hifi/blob/master/interface/resources/controllers/leapmotion.json">leapmotion.json</a>.</p><table>  <thead>      <tr><th>Property</th><th>Type</th><th>Data</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td colspan="4"><strong>Buttons</strong></td></tr>    <tr><td><code>A</code></td><td>number</td><td>number</td><td>"A" button pressed.</td></tr>    <tr><td><code>B</code></td><td>number</td><td>number</td><td>"B" button pressed.</td></tr>    <tr><td><code>X</code></td><td>number</td><td>number</td><td>"X" button pressed.</td></tr>    <tr><td><code>Y</code></td><td>number</td><td>number</td><td>"Y" button pressed.</td></tr>    <tr><td><code>DL</code></td><td>number</td><td>number</td><td>D-pad left pressed.</td></tr>    <tr><td><code>DR</code></td><td>number</td><td>number</td><td>D-pad right pressed.</td></tr>    <tr><td><code>DU</code></td><td>number</td><td>number</td><td>D-pad up pressed.</td></tr>    <tr><td><code>DD</code></td><td>number</td><td>number</td><td>D-pad down pressed.</td></tr>    <tr><td><code>Start</code></td><td>number</td><td>number</td><td>"Start" center button pressed.</td></tr>    <tr><td><code>Back</code></td><td>number</td><td>number</td><td>"Back" center button pressed.</td></tr>    <tr><td><code>LB</code></td><td>number</td><td>number</td><td>Left bumper button pressed.</td></tr>    <tr><td><code>RB</code></td><td>number</td><td>number</td><td>Right bumper button pressed.</td></tr>    <tr><td colspan="4"><strong>Sticks</strong></td></tr>    <tr><td><code>LX</code></td><td>number</td><td>number</td><td>Left stick x-axis scale.</td></tr>    <tr><td><code>LY</code></td><td>number</td><td>number</td><td>Left stick y-axis scale.</td></tr>    <tr><td><code>RX</code></td><td>number</td><td>number</td><td>Right stick x-axis scale.</td></tr>    <tr><td><code>RY</code></td><td>number</td><td>number</td><td>Right stick y-axis scale.</td></tr>    <tr><td><code>LS</code></td><td>number</td><td>number</td><td>Left stick button pressed.</td></tr>    <tr><td><code>RS</code></td><td>number</td><td>number</td><td>Right stick button pressed.</td></tr>    <tr><td><code>LSTouch</code></td><td>number</td><td>number</td><td>Left stick is touched.</td></tr>    <tr><td><code>RSTouch</code></td><td>number</td><td>number</td><td>Right stick is touched.</td></tr>    <tr><td colspan="4"><strong>Triggers</strong></td></tr>    <tr><td><code>LT</code></td><td>number</td><td>number</td><td>Left trigger scale.</td></tr>    <tr><td><code>RT</code></td><td>number</td><td>number</td><td>Right trigger scale.</td></tr>    <tr><td><code>LTClick</code></td><td>number</td><td>number</td><td>Left trigger click.</td></tr>    <tr><td><code>RTClick</code></td><td>number</td><td>number</td><td>Right trigger click.</td></tr>    <tr><td><code>LeftGrip</code></td><td>number</td><td>number</td><td>Left grip scale.</td></tr>    <tr><td><code>RightGrip</code></td><td>number</td><td>number</td><td>Right grip scale.</td></tr>    <tr><td><code>LeftGripTouch</code></td><td>number</td><td>number</td><td>Left grip is touched.</td></tr>    <tr><td><code>RightGripTouch</code></td><td>number</td><td>number</td><td>Right grip is touched.</td></tr>    <tr><td colspan="4"><strong>Aliases, PlayStation Style Names</strong></td></tr>    <tr><td><code>Cross</code></td><td>number</td><td>number</td><td>Alias for <code>A</code>.</td></tr>    <tr><td><code>Circle</code></td><td>number</td><td>number</td><td>Alias for <code>B</code>.</td></tr>    <tr><td><code>Square</code></td><td>number</td><td>number</td><td>Alias for <code>X</code>.</td></tr>    <tr><td><code>Triangle</code></td><td>number</td><td>number</td><td>Alias for <code>Y</code>.</td></tr>    <tr><td><code>Left</code></td><td>number</td><td>number</td><td>Alias for <code>DL</code>.</td></tr>    <tr><td><code>Right</code></td><td>number</td><td>number</td><td>Alias for <code>DR</code>.</td></tr>    <tr><td><code>Up</code></td><td>number</td><td>number</td><td>Alias for <code>DU</code>.</td></tr>    <tr><td><code>Down</code></td><td>number</td><td>number</td><td>Alias for <code>DD</code>.</td></tr>    <tr><td><code>Select</code></td><td>number</td><td>number</td><td>Alias for <code>Back</code>.</td></tr>    <tr><td><code>L1</code></td><td>number</td><td>number</td><td>Alias for <code>LB</code>.</td></tr>    <tr><td><code>R1</code></td><td>number</td><td>number</td><td>Alias for <code>RB</code>.</td></tr>    <tr><td><code>L3</code></td><td>number</td><td>number</td><td>Alias for <code>LS</code>.</td></tr>    <tr><td><code>R3</code></td><td>number</td><td>number</td><td>Alias for <code>RS</code>.</td></tr>    <tr><td><code>L2</code></td><td>number</td><td>number</td><td>Alias for <code>LT</code>.</td></tr>    <tr><td><code>R2</code></td><td>number</td><td>number</td><td>Alias for <code>RT</code>.</td></tr>    <tr><td colspan="4"><strong>Finger Abstractions</strong></td></tr>    <tr><td><code>LeftPrimaryThumb</code></td><td>number</td><td>number</td><td>Left primary thumb button pressed.</td></tr>    <tr><td><code>LeftSecondaryThumb</code></td><td>number</td><td>number</td><td>Left secondary thumb button pressed.      </td></tr>    <tr><td><code>RightPrimaryThumb</code></td><td>number</td><td>number</td><td>Right primary thumb button pressed.      </td></tr>    <tr><td><code>RightSecondaryThumb</code></td><td>number</td><td>number</td><td>Right secondary thumb button pressed.      </td></tr>    <tr><td><code>LeftPrimaryThumbTouch</code></td><td>number</td><td>number</td><td>Left thumb touching primary thumb       button.</td></tr>    <tr><td><code>LeftSecondaryThumbTouch</code></td><td>number</td><td>number</td><td>Left thumb touching secondary thumb       button.</td></tr>    <tr><td><code>LeftThumbUp</code></td><td>number</td><td>number</td><td>Left thumb not touching primary or secondary       thumb buttons.</td></tr>    <tr><td><code>RightPrimaryThumbTouch</code></td><td>number</td><td>number</td><td>Right thumb touching primary thumb       button.</td></tr>    <tr><td><code>RightSecondaryThumbTouch</code></td><td>number</td><td>number</td><td>Right thumb touching secondary thumb       button.</td></tr>    <tr><td><code>RightThumbUp</code></td><td>number</td><td>number</td><td>Right thumb not touching primary or secondary       thumb buttons.</td></tr>    <tr><td><code>LeftPrimaryIndex</code></td><td>number</td><td>number</td><td>Left primary index control pressed.</td></tr>    <tr><td><code>LeftSecondaryIndex</code></td><td>number</td><td>number</td><td>Left secondary index control pressed.      </td></tr>    <tr><td><code>RightPrimaryIndex</code></td><td>number</td><td>number</td><td>Right primary index control pressed.       </td></tr>    <tr><td><code>RightSecondaryIndex</code></td><td>number</td><td>number</td><td>Right secondary index control pressed.      </td></tr>    <tr><td><code>LeftPrimaryIndexTouch</code></td><td>number</td><td>number</td><td>Left index finger is touching primary       index finger control.</td></tr>    <tr><td><code>LeftSecondaryIndexTouch</code></td><td>number</td><td>number</td><td>Left index finger is touching       secondary index finger control.</td></tr>    <tr><td><code>LeftIndexPoint</code></td><td>number</td><td>number</td><td>Left index finger is pointing, not touching       primary or secondary index finger controls.</td></tr>    <tr><td><code>RightPrimaryIndexTouch</code></td><td>number</td><td>number</td><td>Right index finger is touching primary       index finger control.</td></tr>    <tr><td><code>RightSecondaryIndexTouch</code></td><td>number</td><td>number</td><td>Right index finger is touching       secondary index finger control.</td></tr>    <tr><td><code>RightIndexPoint</code></td><td>number</td><td>number</td><td>Right index finger is pointing, not touching       primary or secondary index finger controls.</td></tr>    <tr><td colspan="4"><strong>Avatar Skeleton</strong></td></tr>    <tr><td><code>Hips</code></td><td>number</td><td>{@link Pose}</td><td>Hips pose.</td></tr>    <tr><td><code>Spine2</code></td><td>number</td><td>{@link Pose}</td><td>Spine2 pose.</td></tr>    <tr><td><code>Head</code></td><td>number</td><td>{@link Pose}</td><td>Head pose.</td></tr>    <tr><td><code>LeftArm</code></td><td>number</td><td>{@link Pose}</td><td>Left arm pose.</td></tr>    <tr><td><code>RightArm</code></td><td>number</td><td>{@link Pose}</td><td>Right arm pose</td></tr>    <tr><td><code>LeftHand</code></td><td>number</td><td>{@link Pose}</td><td>Left hand pose.</td></tr>    <tr><td><code>LeftHandThumb1</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandThumb2</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandThumb3</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandThumb4</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 4 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex1</code></td><td>number</td><td>{@link Pose}</td><td>Left index 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex2</code></td><td>number</td><td>{@link Pose}</td><td>Left index 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex3</code></td><td>number</td><td>{@link Pose}</td><td>Left index 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex4</code></td><td>number</td><td>{@link Pose}</td><td>Left index 4 finger joint pose.</td></tr>    <tr><td><code>LeftHandMiddle1</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 1 finger joint pose.      </td></tr>    <tr><td><code>LeftHandMiddle2</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 2 finger joint pose.      </td></tr>    <tr><td><code>LeftHandMiddle3</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 3 finger joint pose.      </td></tr>    <tr><td><code>LeftHandMiddle4</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 4 finger joint pose.      </td></tr>    <tr><td><code>LeftHandRing1</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandRing2</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandRing3</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandRing4</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 4 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky1</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky2</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky3</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky4</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 4 finger joint pose.</td></tr>    <tr><td><code>RightHand</code></td><td>number</td><td>{@link Pose}</td><td>Right hand pose.</td></tr>    <tr><td><code>RightHandThumb1</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandThumb2</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandThumb3</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandThumb4</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 4 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex1</code></td><td>number</td><td>{@link Pose}</td><td>Right index 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex2</code></td><td>number</td><td>{@link Pose}</td><td>Right index 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex3</code></td><td>number</td><td>{@link Pose}</td><td>Right index 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex4</code></td><td>number</td><td>{@link Pose}</td><td>Right index 4 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle1</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle2</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle3</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle4</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 4 finger joint pose.      </td></tr>    <tr><td><code>RightHandRing1</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 1 finger joint pose.</td></tr>    <tr><td><code>RightHandRing2</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 2 finger joint pose.</td></tr>    <tr><td><code>RightHandRing3</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 3 finger joint pose.</td></tr>    <tr><td><code>RightHandRing4</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 4 finger joint pose.</td></tr>    <tr><td><code>RightHandPinky1</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandPinky2</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandPinky3</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandPinky4</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 4 finger joint pose.      </td></tr>    <tr><td><code>LeftFoot</code></td><td>number</td><td>{@link Pose}</td><td>Left foot pose.</td></tr>    <tr><td><code>RightFoot</code></td><td>number</td><td>{@link Pose}</td><td>Right foot pose.</td></tr>    <tr><td colspan="4"><strong>Trackers</strong></td></tr>    <tr><td><code>TrackedObject00</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 0 pose.</td></tr>    <tr><td><code>TrackedObject01</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 1 pose.</td></tr>    <tr><td><code>TrackedObject02</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 2 pose.</td></tr>    <tr><td><code>TrackedObject03</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 3 pose.</td></tr>    <tr><td><code>TrackedObject04</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 4 pose.</td></tr>    <tr><td><code>TrackedObject05</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 5 pose.</td></tr>    <tr><td><code>TrackedObject06</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 6 pose.</td></tr>    <tr><td><code>TrackedObject07</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 7 pose.</td></tr>    <tr><td><code>TrackedObject08</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 8 pose.</td></tr>    <tr><td><code>TrackedObject09</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 9 pose.</td></tr>    <tr><td><code>TrackedObject10</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 10 pose.</td></tr>    <tr><td><code>TrackedObject11</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 11 pose.</td></tr>    <tr><td><code>TrackedObject12</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 12 pose.</td></tr>    <tr><td><code>TrackedObject13</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 13 pose.</td></tr>    <tr><td><code>TrackedObject14</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 14 pose.</td></tr>    <tr><td><code>TrackedObject15</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 15 pose.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Standard');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Standard'] = (block, generator) => {

    return [`new Controller.Standard()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['MappingObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#BC7E9B');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p><p>A {@link Controller} mapping object that can contain a set of routes that map:</p><ul>    <li>{@link Controller.Standard} outputs to {@link Controller.Actions} actions or script functions.</li>    <li>{@link Controller.Hardware} outputs to {@link Controller.Standard} outputs, {@link Controller.Actions} actions, or     script functions.</li></ul><p>Create by one of the following methods:</p><ul>    <li>Use {@link Controller.newMapping} to create the mapping object, add routes using {@link MappingObject#from|from} or    {@link MappingObject#makeAxis|makeAxis}, and map the routes to actions or functions using {@link RouteObject}     methods.</li>    <li>Use {@link Controller.parseMapping} or {@link Controller.loadMapping} to load a {@link Controller.MappingJSON}.</li></ul><p>Enable the mapping using {@link MappingObject#enable|enable} or {@link Controller.enableMapping} for it to take effect.</p><p>Mappings and their routes are applied according to the following rules:</p><ul>    <li>One read per output: after a controller output has been read, it can\'t be read again. Exception: You can use     {@link RouteObject#peek} to read a value without marking that output as having been read.</li>    <li>Existing mapping routes take precedence over new mapping routes: within a mapping, if a route is added for a control     output that already has a route the new route is ignored.</li>    <li>New mappings override previous mappings: each output is processed using the route in the most recently enabled     mapping that contains that output.</li></ul>');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject'] = (block, generator) => {

    return [`new MappingObject()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_MappingJSON'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.MappingJSON')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('channels') 
            .setCheck('Array')
            .appendField('channels');
        this.setColour('#9BBF37');
        this.setTooltip('A {@link MappingObject} can be specified in JSON format. A simple example is provided below. Full examples &mdash; the default mappings provided in Interface &mdash;  can be found at <a href="https://github.com/highfidelity/hifi/tree/master/interface/resources/controllers">https://github.com/highfidelity/hifi/tree/master/interface/resources/controllers</a>.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.MappingJSON');
    }
};
javascript.javascriptGenerator.forBlock['Controller_MappingJSON'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _channels = dfv(generator.valueToCode(block, 'channels', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Controller.MappingJSON(${_name},${_channels})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_MappingJSONRoute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.MappingJSONRoute')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('from') 
            .setCheck('String')
            .appendField('from');
        this.appendValueInput('peek') 
            .setCheck('Boolean')
            .appendField('peek');
        this.appendValueInput('debug') 
            .setCheck('Boolean')
            .appendField('debug');
        this.appendValueInput('when') 
            .setCheck('String')
            .appendField('when');
        this.appendValueInput('filters') 
            .setCheck('Controller.MappingJSONFilter')
            .appendField('filters');
        this.appendValueInput('to') 
            .setCheck('String')
            .appendField('to');
        this.setColour('#9BBF37');
        this.setTooltip('A route in a {@link Controller.MappingJSON}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.MappingJSONRoute');
    }
};
javascript.javascriptGenerator.forBlock['Controller_MappingJSONRoute'] = (block, generator) => {
    const _from = dfv(generator.valueToCode(block, 'from', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _peek = dfv(generator.valueToCode(block, 'peek', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _debug = dfv(generator.valueToCode(block, 'debug', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _when = dfv(generator.valueToCode(block, 'when', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _filters = dfv(generator.valueToCode(block, 'filters', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _to = dfv(generator.valueToCode(block, 'to', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Controller.MappingJSONRoute(${_from},${_peek},${_debug},${_when},${_filters},${_to})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_MappingJSONAxis'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.MappingJSONAxis')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('makeAxis') 
            .setCheck('Array')
            .appendField('makeAxis');
        this.setColour('#9BBF37');
        this.setTooltip('An axis pair in a {@link Controller.MappingJSONRoute}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.MappingJSONAxis');
    }
};
javascript.javascriptGenerator.forBlock['Controller_MappingJSONAxis'] = (block, generator) => {
    const _makeAxis = dfv(generator.valueToCode(block, 'makeAxis', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Controller.MappingJSONAxis(${_makeAxis})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_MappingJSONFilter'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.MappingJSONFilter')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('String')
            .appendField('type');
        this.appendValueInput('prop_0') 
            .setCheck('String')
            .appendField('prop_0');
        this.appendValueInput('prop_1') 
            .setCheck('String')
            .appendField('prop_1');
        this.setColour('#9BBF37');
        this.setTooltip('A filter in a {@link Controller.MappingJSONRoute}.');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.MappingJSONFilter');
    }
};
javascript.javascriptGenerator.forBlock['Controller_MappingJSONFilter'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _prop_0 = dfv(generator.valueToCode(block, 'prop_0', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _prop_1 = dfv(generator.valueToCode(block, 'prop_1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Controller.MappingJSONFilter(${_type},${_prop_0},${_prop_1})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['MappingObject#fromQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject#fromQml')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('source') 
            .setCheck('Controller.Standard')
            .appendField('source');

        this.setColour('#BC7E9B');
        this.setTooltip('Creates a new {@link RouteObject} from a controller output, ready to be mapped to a standard control, action, or function.<p>This is a QML-specific version of {@link MappingObject#from|from}: use this version in QML files.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject#fromQml');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject#fromQml'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MappingObject#fromQml(${_source})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MappingObject#makeAxisQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject#makeAxisQml')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('source1') 
            .setCheck('Controller.Hardware')
            .appendField('source1');
        this.appendValueInput('source2') 
            .setCheck('Controller.Hardware')
            .appendField('source2');

        this.setColour('#BC7E9B');
        this.setTooltip('Creates a new {@link RouteObject} from two numeric {@link Controller.Hardware} outputs, one applied in the negative direction and the other in the positive direction, ready to be mapped to a standard control, action, or function.<p>This is a QML-specific version of {@link MappingObject#makeAxis|makeAxis}: use this version in QML files.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject#makeAxisQml');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject#makeAxisQml'] = (block, generator) => {
    const _source1 = dfv(generator.valueToCode(block, 'source1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _source2 = dfv(generator.valueToCode(block, 'source2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MappingObject#makeAxisQml(${_source1},${_source2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MappingObject#from'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject#from')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('source') 
            .setCheck('Controller.Standard')
            .appendField('source');

        this.setColour('#BC7E9B');
        this.setTooltip('Creates a new {@link RouteObject} from a controller output, ready to be mapped to a standard control, action, or function.');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject#from');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject#from'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MappingObject#from(${_source})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MappingObject#makeAxis'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject#makeAxis')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('source1') 
            .setCheck('Controller.Hardware')
            .appendField('source1');
        this.appendValueInput('source2') 
            .setCheck('Controller.Hardware')
            .appendField('source2');

        this.setColour('#BC7E9B');
        this.setTooltip('Creates a new {@link RouteObject} from two numeric {@link Controller.Hardware} outputs, one applied in the negative direction and the other in the positive direction, ready to be mapped to a standard control, action, or function.');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject#makeAxis');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject#makeAxis'] = (block, generator) => {
    const _source1 = dfv(generator.valueToCode(block, 'source1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _source2 = dfv(generator.valueToCode(block, 'source2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MappingObject#makeAxis(${_source1},${_source2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MappingObject#enable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject#enable')
        // Returns data
        this.setOutput(true, '["MappingObject"]');

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setColour('#BC7E9B');
        this.setTooltip('Enables or disables the mapping. When enabled, the routes in the mapping take effect.<p>Synonymous with {@link Controller.enableMapping}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject#enable');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject#enable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

return [`MappingObject#enable(${_enable})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MappingObject#disable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MappingObject#disable')
        // Returns data
        this.setOutput(true, '["MappingObject"]');

        // Params data

        this.setColour('#BC7E9B');
        this.setTooltip('Disables the mapping. When disabled, the routes in the mapping have no effect.<p>Synonymous with {@link Controller.disableMapping}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MappingObject#disable');
    }
};
javascript.javascriptGenerator.forBlock['MappingObject#disable'] = (block, generator) => {

return [`MappingObject#disable()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['RouteObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#CD852D');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p><p>A route in a {@link MappingObject} used by the {@link Controller} API.</p><p>Create a route using {@link MappingObject} methods and apply this object\'s methods to process it, terminating with {@link RouteObject#to} to apply it to a <code>Standard</code> control, action, or script function. Note: Loops are not permitted.</p><p>Some methods apply to routes with number data, some apply routes with {@link Pose} data, and some apply to both route types.<p>');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject'] = (block, generator) => {

    return [`new RouteObject()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['RouteObject#toQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#toQml')
        // Returns data

        // Params data
        this.appendValueInput('destination') 
            .setCheck('Controller.Standard')
            .appendField('destination');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#CD852D');
        this.setTooltip('Terminates the route with a standard control, an action, or a script function. The output value from the route is sent to the specified destination.<p>This is a QML-specific version of {@link MappingObject#to|to}: use this version in QML files.</p>');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#toQml');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#toQml'] = (block, generator) => {
    const _destination = dfv(generator.valueToCode(block, 'destination', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `RouteObject#toQml(${_destination});\n`;};


// Blockly function
Blockly.Blocks['RouteObject#whenQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#whenQml')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('expression') 
            .setCheck('condition')
            .appendField('expression');

        this.setColour('#CD852D');
        this.setTooltip('Processes the route only if a condition is satisfied. The condition is evaluated before the route input is read, andthe input is read only if the condition is <code>true</code>. Thus, if the condition is not met then subsequentroutes using the same input are processed.<p>This is a QML-specific version of {@link MappingObject#when|when}: use this version in QML files.</p>');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#whenQml');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#whenQml'] = (block, generator) => {
    const _expression = dfv(generator.valueToCode(block, 'expression', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RouteObject#whenQml(${_expression})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#to'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#to')
        // Returns data

        // Params data
        this.appendValueInput('destination') 
            .setCheck('Controller.Standard')
            .appendField('destination');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#CD852D');
        this.setTooltip('Terminates the route with a standard control, an action, or a script function. The output value from the route is sent to the specified destination.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#to');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#to'] = (block, generator) => {
    const _destination = dfv(generator.valueToCode(block, 'destination', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `RouteObject#to(${_destination});\n`;};


// Blockly function
Blockly.Blocks['RouteObject#debug'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#debug')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setColour('#CD852D');
        this.setTooltip('Enables or disables writing debug information for a route to the program log.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#debug');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#debug'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

return [`RouteObject#debug(${_enable})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#peek'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#peek')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setColour('#CD852D');
        this.setTooltip('Processes the route without marking the controller output as having been read, so that other routes from the same controller output can also process.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#peek');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#peek'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

return [`RouteObject#peek(${_enable})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#when'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#when')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('expression') 
            .setCheck('condition')
            .appendField('expression');

        this.setColour('#CD852D');
        this.setTooltip('Processes the route only if a condition is satisfied. The condition is evaluated before the route input is read, and the input is read only if the condition is <code>true</code>. Thus, if the condition is not met then subsequent routes using the same input are processed.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#when');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#when'] = (block, generator) => {
    const _expression = dfv(generator.valueToCode(block, 'expression', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RouteObject#when(${_expression})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#clamp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#clamp')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('min') 
            .setCheck('Number')
            .appendField('min');
        this.appendValueInput('max') 
            .setCheck('Number')
            .appendField('max');

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values to lie between two values; values outside this range are not passed on through the route.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#clamp');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#clamp'] = (block, generator) => {
    const _min = dfv(generator.valueToCode(block, 'min', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _max = dfv(generator.valueToCode(block, 'max', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#clamp(${_min},${_max})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#hysteresis'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#hysteresis')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('min') 
            .setCheck('Number')
            .appendField('min');
        this.appendValueInput('max') 
            .setCheck('Number')
            .appendField('max');

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values such that they are rounded to <code>0</code> or <code>1</code> without output values flickering when the input value hovers around <code>0.5</code>. For example, this enables you to use an analog input as if it were a toggle.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#hysteresis');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#hysteresis'] = (block, generator) => {
    const _min = dfv(generator.valueToCode(block, 'min', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _max = dfv(generator.valueToCode(block, 'max', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#hysteresis(${_min},${_max})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#pulse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#pulse')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('interval') 
            .setCheck('Number')
            .appendField('interval');

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values to send at a specified interval.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#pulse');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#pulse'] = (block, generator) => {
    const _interval = dfv(generator.valueToCode(block, 'interval', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#pulse(${_interval})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#scale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#scale')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('multiplier') 
            .setCheck('Number')
            .appendField('multiplier');

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric and {@link Pose} route values to be scaled by a constant amount.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#scale');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#scale'] = (block, generator) => {
    const _multiplier = dfv(generator.valueToCode(block, 'multiplier', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#scale(${_multiplier})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#invert'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#invert')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric and {@link Pose} route values to have the opposite sign, e.g., <code>0.5</code> is changed to <code>-0.5</code>.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#invert');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#invert'] = (block, generator) => {

return [`RouteObject#invert()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#deadZone'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#deadZone')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('min') 
            .setCheck('Number')
            .appendField('min');

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values such that they\'re sent only when the input value is outside a dead-zone. When the input passes the dead-zone value, output is sent starting at <code>0.0</code> and catching up with the input value. As the input returns toward the dead-zone value, output values reduce to <code>0.0</code> at the dead-zone value.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#deadZone');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#deadZone'] = (block, generator) => {
    const _min = dfv(generator.valueToCode(block, 'min', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#deadZone(${_min})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#constrainToInteger'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#constrainToInteger')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values such that they are rounded to <code>-1</code>, <code>0</code>, or <code>1</code>.For example, this enables you to use an analog input as if it were a toggle or, in the case of a bidirectional axis, a tri-state switch.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#constrainToInteger');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#constrainToInteger'] = (block, generator) => {

return [`RouteObject#constrainToInteger()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#constrainToPositiveInteger'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#constrainToPositiveInteger')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values such that they are rounded to <code>0</code> or <code>1</code>. For example, this enables you to use an analog input as if it were a toggle.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#constrainToPositiveInteger');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#constrainToPositiveInteger'] = (block, generator) => {

return [`RouteObject#constrainToPositiveInteger()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#translate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#translate')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('translate') 
            .setCheck('Vec3')
            .appendField('translate');

        this.setColour('#CD852D');
        this.setTooltip('Filters {@link Pose} route values to have a pre-translation applied.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#translate');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#translate'] = (block, generator) => {
    const _translate = dfv(generator.valueToCode(block, 'translate', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RouteObject#translate(${_translate})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#transform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#transform')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('transform') 
            .setCheck('Mat4')
            .appendField('transform');

        this.setColour('#CD852D');
        this.setTooltip('Filters {@link Pose} route values to have a pre-transform applied.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#transform');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#transform'] = (block, generator) => {
    const _transform = dfv(generator.valueToCode(block, 'transform', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RouteObject#transform(${_transform})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#postTransform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#postTransform')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('transform') 
            .setCheck('Mat4')
            .appendField('transform');

        this.setColour('#CD852D');
        this.setTooltip('Filters {@link Pose} route values to have a post-transform applied.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#postTransform');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#postTransform'] = (block, generator) => {
    const _transform = dfv(generator.valueToCode(block, 'transform', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RouteObject#postTransform(${_transform})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#rotate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#rotate')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setColour('#CD852D');
        this.setTooltip('Filters {@link Pose} route values to have a pre-rotation applied.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#rotate');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#rotate'] = (block, generator) => {
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`RouteObject#rotate(${_rotation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#lowVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#lowVelocity')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('rotationConstant') 
            .setCheck('Number')
            .appendField('rotationConstant');
        this.appendValueInput('translationConstant') 
            .setCheck('Number')
            .appendField('translationConstant');

        this.setColour('#CD852D');
        this.setTooltip('Filters {@link Pose} route values to be smoothed by a low velocity filter. The filter\'s rotation and translation values are calculated as: <code>(1 - f) * currentValue + f * previousValue</code> where <code>f = currentVelocity / filterConstant</code>. At low velocities, the filter value is largely the previous value; at high velocities the value is wholly the current controller value.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#lowVelocity');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#lowVelocity'] = (block, generator) => {
    const _rotationConstant = dfv(generator.valueToCode(block, 'rotationConstant', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translationConstant = dfv(generator.valueToCode(block, 'translationConstant', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#lowVelocity(${_rotationConstant},${_translationConstant})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#exponentialSmoothing'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#exponentialSmoothing')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data
        this.appendValueInput('rotationConstant') 
            .setCheck('Number')
            .appendField('rotationConstant');
        this.appendValueInput('translationConstant') 
            .setCheck('Number')
            .appendField('translationConstant');

        this.setColour('#CD852D');
        this.setTooltip('Filters {@link Pose} route values to be smoothed by an exponential decay filter. The filter\'s rotation and translation values are calculated as: <code>filterConstant * currentValue + (1 - filterConstant) * previousValue</code>. Values near 1 are less smooth with lower latency; values near 0 are more smooth with higher latency.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#exponentialSmoothing');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#exponentialSmoothing'] = (block, generator) => {
    const _rotationConstant = dfv(generator.valueToCode(block, 'rotationConstant', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translationConstant = dfv(generator.valueToCode(block, 'translationConstant', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`RouteObject#exponentialSmoothing(${_rotationConstant},${_translationConstant})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['RouteObject#logicalNot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RouteObject#logicalNot')
        // Returns data
        this.setOutput(true, '["RouteObject"]');

        // Params data

        this.setColour('#CD852D');
        this.setTooltip('Filters numeric route values such that a value of <code>0.0</code> is changed to <code>1.0</code>, and other values are changed to <code>0.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/RouteObject#logicalNot');
    }
};
javascript.javascriptGenerator.forBlock['RouteObject#logicalNot'] = (block, generator) => {

return [`RouteObject#logicalNot()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['HMD_IPDScaleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.IPDScaleChanged');


        this.setColour('#23491C');
        this.setTooltip('Triggered when the <code>HMD.ipdScale</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.IPDScaleChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_IPDScaleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `HMD.IPDScaleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['HMD_displayModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.displayModeChanged');

        this.appendDummyInput('isHMDMode')
            .appendField('isHMDMode:')
            .appendField(new Blockly.FieldVariable('displayModeChanged_isHMDMode'), 'isHMDMode');

        this.setColour('#23491C');
        this.setTooltip('Triggered when Interface\'s display mode changes and when the user puts on or takes off their HMD.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.displayModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_displayModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isHMDMode = generator.getVariableName(block.getFieldValue('isHMDMode'));

return `HMD.displayModeChanged.connect((_isHMDMode) => { 
  ${isHMDMode} = _isHMDMode;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['HMD_mountedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('HMD.mountedChanged');


        this.setColour('#23491C');
        this.setTooltip('Triggered when the <code>HMD.mounted</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/HMD.html#.mountedChanged');
    }
};
javascript.javascriptGenerator.forBlock['HMD_mountedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `HMD.mountedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Reticle_allowMouseCapture'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.allowMouseCapture')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('<code>true</code> if the mouse cursor will be captured when in HMD mode and the     Interface window content (excluding menus) has focus, <code>false</code> if the mouse cursor will not be captured.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.allowMouseCapture');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_allowMouseCapture'] = (block, generator) => {
    return [`Reticle.allowMouseCapture`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_depth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.depth')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('The depth (distance) that the reticle is displayed at relative to the HMD view, in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.depth');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_depth'] = (block, generator) => {
    return [`Reticle.depth`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_maximumPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.maximumPosition')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('The maximum reticle coordinates on the display device in desktop mode or the HUD surface     in HMD mode. (The minimum reticle coordinates on the desktop display device or HUD surface are <code>0</code>,     <code>0</code>.) <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.maximumPosition');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_maximumPosition'] = (block, generator) => {
    return [`Reticle.maximumPosition`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_mouseCaptured'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.mouseCaptured')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('<code>true</code> if the mouse cursor is captured, displaying only in Interface and     not on the rest of the desktop. The mouse cursor may be captured when in HMD mode and the Interface window content     (excluding menu items) has focus, if capturing is enabled (<code>allowMouseCapture</code> is <code>true</code>).     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.mouseCaptured');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_mouseCaptured'] = (block, generator) => {
    return [`Reticle.mouseCaptured`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_pointingAtSystemOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.pointingAtSystemOverlay')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('<code>true</code> if the mouse cursor is pointing at UI in the Interface     window in desktop mode or on the HUD surface in HMD mode, <code>false</code> if it isn\'t. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.pointingAtSystemOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_pointingAtSystemOverlay'] = (block, generator) => {
    return [`Reticle.pointingAtSystemOverlay`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_position'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.position')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('The position of the cursor. This is the position relative to the Interface window in desktop     mode, and the HUD surface in HMD mode.    <p><strong>Note:</strong> The position values may be negative.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.position');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_position'] = (block, generator) => {
    return [`Reticle.position`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_scale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.scale')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('The scale of the reticle circle in desktop mode, and the arrow and reticle circle in HMD mode.     (Does not affect the size of the arrow in desktop mode.)');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.scale');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_scale'] = (block, generator) => {
    return [`Reticle.scale`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Reticle_visible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.visible')       
        this.setOutput(true, '');
        this.setColour('#DD5C8C');
        this.setTooltip('<code>true</code> if the reticle circle is visible in desktop mode, and the arrow or     reticle circle are visible in HMD mode; <code>false</code> otherwise. (Does not affect the visibility of the mouse     pointer in desktop mode.)');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.visible');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_visible'] = (block, generator) => {
    return [`Reticle.visible`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Reticle_isMouseCaptured'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.isMouseCaptured')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Checks whether the mouse cursor is captured, displaying only in Interface and not on the rest of the desktop. The mouse cursor is captured when in HMD mode and the Interface window content (excluding menu items) has focus, if capturing is enabled (<code>allowMouseCapture</code> property value is <code>true</code>).');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.isMouseCaptured');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_isMouseCaptured'] = (block, generator) => {

return [`Reticle.isMouseCaptured()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_getAllowMouseCapture'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.getAllowMouseCapture')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets whether the mouse cursor will be captured when in HMD mode and the Interface window content (excluding menu items) has focus. When captured, the mouse cursor displays only in Interface, not on the rest of the desktop.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.getAllowMouseCapture');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_getAllowMouseCapture'] = (block, generator) => {

return [`Reticle.getAllowMouseCapture()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_setAllowMouseCapture'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.setAllowMouseCapture')
        // Returns data

        // Params data
        this.appendValueInput('allowMouseCaptured') 
            .setCheck('Boolean')
            .appendField('allowMouseCaptured');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DD5C8C');
        this.setTooltip('Sets whether the mouse cursor will be captured when in HMD mode and the Interface window content (excluding menu items)has focus. When captured, the mouse cursor displays only in Interface, not on the rest of desktop.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.setAllowMouseCapture');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_setAllowMouseCapture'] = (block, generator) => {
    const _allowMouseCaptured = dfv(generator.valueToCode(block, 'allowMouseCaptured', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Reticle.setAllowMouseCapture(${_allowMouseCaptured});\n`;};


// Blockly function
Blockly.Blocks['Reticle_isPointingAtSystemOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.isPointingAtSystemOverlay')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets whether the mouse cursor is pointing at UI in the Interface window in desktop mode or on the HUD surface in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.isPointingAtSystemOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_isPointingAtSystemOverlay'] = (block, generator) => {

return [`Reticle.isPointingAtSystemOverlay()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_getVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.getVisible')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets whether the reticle circle is visible in desktop mode, or the arrow or reticle circle are visible in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.getVisible');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_getVisible'] = (block, generator) => {

return [`Reticle.getVisible()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_setVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.setVisible')
        // Returns data

        // Params data
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DD5C8C');
        this.setTooltip('Sets whether the reticle circle is visible in desktop mode, or the arrow or reticle circle are visible in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.setVisible');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_setVisible'] = (block, generator) => {
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Reticle.setVisible(${_visible});\n`;};


// Blockly function
Blockly.Blocks['Reticle_getDepth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.getDepth')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets the depth (distance) that the reticle is displayed at relative to the HMD view, in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.getDepth');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_getDepth'] = (block, generator) => {

return [`Reticle.getDepth()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_setDepth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.setDepth')
        // Returns data

        // Params data
        this.appendValueInput('depth') 
            .setCheck('Number')
            .appendField('depth');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DD5C8C');
        this.setTooltip('Sets the depth (distance) that the reticle is displayed at relative to the HMD view, in HMD mode.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.setDepth');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_setDepth'] = (block, generator) => {
    const _depth = dfv(generator.valueToCode(block, 'depth', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Reticle.setDepth(${_depth});\n`;};


// Blockly function
Blockly.Blocks['Reticle_getScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.getScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets the scale of the reticle circle in desktop mode, and the arrow and reticle circle in HMD mode. (Does not affect the size of the arrow in desktop mode.) The default scale is <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.getScale');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_getScale'] = (block, generator) => {

return [`Reticle.getScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_setScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.setScale')
        // Returns data

        // Params data
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DD5C8C');
        this.setTooltip('Sets the scale of the reticle circle in desktop mode, and the arrow and reticle circle in HMD mode. (Does not affect thesize of the arrow in desktop mode.) The default scale is <code>1.0</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.setScale');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_setScale'] = (block, generator) => {
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Reticle.setScale(${_scale});\n`;};


// Blockly function
Blockly.Blocks['Reticle_getPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.getPosition')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets the position of the cursor. This is the position relative to the Interface window in desktop mode, and the HUD surface in HMD mode.<p><strong>Note:</strong> The position values may be negative.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.getPosition');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_getPosition'] = (block, generator) => {

return [`Reticle.getPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Reticle_setPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DD5C8C');
        this.setTooltip('Sets the position of the cursor. This is the position relative to the Interface window in desktop mode, and the HUD surface in HMD mode.<p><strong>Note:</strong> The position values may be negative.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_setPosition'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Reticle.setPosition(${_position});\n`;};


// Blockly function
Blockly.Blocks['Reticle_getMaximumPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Reticle.getMaximumPosition')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#DD5C8C');
        this.setTooltip('Gets the maximum reticle coordinates on the display device in desktop mode or the HUD surface in HMD mode. (The minimum reticle coordinates on the desktop display device or HUD surface are <code>0</code>, <code>0</code>.)');
        this.setHelpUrl('https://apidocs.overte.org/Reticle.html#.getMaximumPosition');
    }
};
javascript.javascriptGenerator.forBlock['Reticle_getMaximumPosition'] = (block, generator) => {

return [`Reticle.getMaximumPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Entities_AmbientLight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.AmbientLight')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('ambientIntensity') 
            .setCheck('Number')
            .appendField('ambientIntensity');
        this.appendValueInput('ambientURL') 
            .setCheck('String')
            .appendField('ambientURL');
        this.setColour('#EA9958');
        this.setTooltip('Ambient light is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.AmbientLight');
    }
};
javascript.javascriptGenerator.forBlock['Entities_AmbientLight'] = (block, generator) => {
    const _ambientIntensity = dfv(generator.valueToCode(block, 'ambientIntensity', javascript.javascriptGenerator.ORDER_ATOMIC), `0.5`);
    const _ambientURL = dfv(generator.valueToCode(block, 'ambientURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

    return [`new Entities.AmbientLight(${_ambientIntensity},${_ambientURL})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_AnimationProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.AnimationProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('allowTranslation') 
            .setCheck('Boolean')
            .appendField('allowTranslation');
        this.appendValueInput('fps') 
            .setCheck('Number')
            .appendField('fps');
        this.appendValueInput('firstFrame') 
            .setCheck('Number')
            .appendField('firstFrame');
        this.appendValueInput('lastFrame') 
            .setCheck('Number')
            .appendField('lastFrame');
        this.appendValueInput('currentFrame') 
            .setCheck('Number')
            .appendField('currentFrame');
        this.appendValueInput('running') 
            .setCheck('Boolean')
            .appendField('running');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('hold') 
            .setCheck('Boolean')
            .appendField('hold');
        this.setColour('#EA9958');
        this.setTooltip('An animation is configured by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.AnimationProperties');
    }
};
javascript.javascriptGenerator.forBlock['Entities_AnimationProperties'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _allowTranslation = dfv(generator.valueToCode(block, 'allowTranslation', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _fps = dfv(generator.valueToCode(block, 'fps', javascript.javascriptGenerator.ORDER_ATOMIC), `30`);
    const _firstFrame = dfv(generator.valueToCode(block, 'firstFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastFrame = dfv(generator.valueToCode(block, 'lastFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `100000`);
    const _currentFrame = dfv(generator.valueToCode(block, 'currentFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _running = dfv(generator.valueToCode(block, 'running', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _hold = dfv(generator.valueToCode(block, 'hold', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.AnimationProperties(${_url},${_allowTranslation},${_fps},${_firstFrame},${_lastFrame},${_currentFrame},${_running},${_loop},${_hold})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Bloom'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Bloom')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('bloomIntensity') 
            .setCheck('Number')
            .appendField('bloomIntensity');
        this.appendValueInput('bloomThreshold') 
            .setCheck('Number')
            .appendField('bloomThreshold');
        this.appendValueInput('bloomSize') 
            .setCheck('Number')
            .appendField('bloomSize');
        this.setColour('#EA9958');
        this.setTooltip('Bloom is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Bloom');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Bloom'] = (block, generator) => {
    const _bloomIntensity = dfv(generator.valueToCode(block, 'bloomIntensity', javascript.javascriptGenerator.ORDER_ATOMIC), `0.25`);
    const _bloomThreshold = dfv(generator.valueToCode(block, 'bloomThreshold', javascript.javascriptGenerator.ORDER_ATOMIC), `0.7`);
    const _bloomSize = dfv(generator.valueToCode(block, 'bloomSize', javascript.javascriptGenerator.ORDER_ATOMIC), `0.9`);

    return [`new Entities.Bloom(${_bloomIntensity},${_bloomThreshold},${_bloomSize})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>An entity action may be one of the following types:</p><table>  <thead>    <tr><th>Value</th><th>Type</th><th>Description</th><th>Arguments</th></tr>  </thead>  <tbody>    <tr><td><code>"far-grab"</code></td><td>Avatar action</td>      <td>Moves and rotates an entity to a target position and orientation, optionally relative to another entity. Collisions       between the entity and the user\'s avatar are disabled during the far-grab.</td>      <td>{@link Entities.ActionArguments-FarGrab}</td></tr>    <tr><td><code>"hold"</code></td><td>Avatar action</td>      <td>Positions and rotates an entity relative to an avatar\'s hand. Collisions between the entity and the user\'s avatar       are disabled during the hold.</td>      <td>{@link Entities.ActionArguments-Hold}</td></tr>    <tr><td><code>"offset"</code></td><td>Object action</td>      <td>Moves an entity so that it is a defined distance away from a target point.</td>      <td>{@link Entities.ActionArguments-Offset}</td></tr>    <tr><td><code>"tractor"</code></td><td>Object action</td>      <td>Moves and rotates an entity to a target position and orientation, optionally relative to another entity.</td>      <td>{@link Entities.ActionArguments-Tractor}</td></tr>    <tr><td><code>"travel-oriented"</code></td><td>Object action</td>      <td>Orients an entity to align with its direction of travel.</td>      <td>{@link Entities.ActionArguments-TravelOriented}</td></tr>    <tr><td><code>"hinge"</code></td><td>Object constraint</td>      <td>Lets an entity pivot about an axis or connects two entities with a hinge joint.</td>      <td>{@link Entities.ActionArguments-Hinge}</td></tr>    <tr><td><code>"slider"</code></td><td>Object constraint</td>      <td>Lets an entity slide and rotate along an axis, or connects two entities that slide and rotate along a shared       axis.</td>      <td>{@link Entities.ActionArguments-Slider|ActionArguments-Slider}</td></tr>    <tr><td><code>"cone-twist"</code></td><td>Object constraint</td>      <td>Connects two entities with a joint that can move through a cone and can twist.</td>      <td>{@link Entities.ActionArguments-ConeTwist}</td></tr>    <tr><td><code>"ball-socket"</code></td><td>Object constraint</td>      <td>Connects two entities with a ball and socket joint.</td>      <td>{@link Entities.ActionArguments-BallSocket}</td></tr>    <tr><td><code>"spring"</code></td><td>&nbsp;</td><td>Synonym for <code>"tractor"</code>.       <p class="important">Deprecated.</p></td><td>&nbsp;</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionType'] = (block, generator) => {

    return [`new Entities.ActionType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('type') 
            .setCheck('Entities.EntityType')
            .appendField('type');
        this.appendValueInput('entityHostType') 
            .setCheck('Entities.EntityHostType')
            .appendField('entityHostType');
        this.appendValueInput('avatarEntity') 
            .setCheck('Boolean')
            .appendField('avatarEntity');
        this.appendValueInput('clientOnly') 
            .setCheck('Boolean')
            .appendField('clientOnly');
        this.appendValueInput('localEntity') 
            .setCheck('Boolean')
            .appendField('localEntity');
        this.appendValueInput('owningAvatarID') 
            .setCheck('Uuid')
            .appendField('owningAvatarID');
        this.appendValueInput('created') 
            .setCheck('Number')
            .appendField('created');
        this.appendValueInput('age') 
            .setCheck('Number')
            .appendField('age');
        this.appendValueInput('ageAsText') 
            .setCheck('String')
            .appendField('ageAsText');
        this.appendValueInput('lifetime') 
            .setCheck('Number')
            .appendField('lifetime');
        this.appendValueInput('lastEdited') 
            .setCheck('Number')
            .appendField('lastEdited');
        this.appendValueInput('lastEditedBy') 
            .setCheck('Uuid')
            .appendField('lastEditedBy');
        this.appendValueInput('locked') 
            .setCheck('Boolean')
            .appendField('locked');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.appendValueInput('canCastShadow') 
            .setCheck('Boolean')
            .appendField('canCastShadow');
        this.appendValueInput('isVisibleInSecondaryCamera') 
            .setCheck('Boolean')
            .appendField('isVisibleInSecondaryCamera');
        this.appendValueInput('renderLayer') 
            .setCheck('Entities.RenderLayer')
            .appendField('renderLayer');
        this.appendValueInput('primitiveMode') 
            .setCheck('Entities.PrimitiveMode')
            .appendField('primitiveMode');
        this.appendValueInput('ignorePickIntersection') 
            .setCheck('Boolean')
            .appendField('ignorePickIntersection');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('registrationPoint') 
            .setCheck('Vec3')
            .appendField('registrationPoint');
        this.appendValueInput('naturalPosition') 
            .setCheck('Vec3')
            .appendField('naturalPosition');
        this.appendValueInput('naturalDimensions') 
            .setCheck('Vec3')
            .appendField('naturalDimensions');
        this.appendValueInput('velocity') 
            .setCheck('Vec3')
            .appendField('velocity');
        this.appendValueInput('damping') 
            .setCheck('Number')
            .appendField('damping');
        this.appendValueInput('angularVelocity') 
            .setCheck('Vec3')
            .appendField('angularVelocity');
        this.appendValueInput('angularDamping') 
            .setCheck('Number')
            .appendField('angularDamping');
        this.appendValueInput('gravity') 
            .setCheck('Vec3')
            .appendField('gravity');
        this.appendValueInput('acceleration') 
            .setCheck('Vec3')
            .appendField('acceleration');
        this.appendValueInput('restitution') 
            .setCheck('Number')
            .appendField('restitution');
        this.appendValueInput('friction') 
            .setCheck('Number')
            .appendField('friction');
        this.appendValueInput('density') 
            .setCheck('Number')
            .appendField('density');
        this.appendValueInput('collisionless') 
            .setCheck('Boolean')
            .appendField('collisionless');
        this.appendValueInput('ignoreForCollisions') 
            .setCheck('Boolean')
            .appendField('ignoreForCollisions');
        this.appendValueInput('collisionMask') 
            .setCheck('CollisionMask')
            .appendField('collisionMask');
        this.appendValueInput('collidesWith') 
            .setCheck('String')
            .appendField('collidesWith');
        this.appendValueInput('collisionSoundURL') 
            .setCheck('String')
            .appendField('collisionSoundURL');
        this.appendValueInput('dynamic') 
            .setCheck('Boolean')
            .appendField('dynamic');
        this.appendValueInput('collisionsWillMove') 
            .setCheck('Boolean')
            .appendField('collisionsWillMove');
        this.appendValueInput('href') 
            .setCheck('String')
            .appendField('href');
        this.appendValueInput('description') 
            .setCheck('String')
            .appendField('description');
        this.appendValueInput('userData') 
            .setCheck('String')
            .appendField('userData');
        this.appendValueInput('privateUserData') 
            .setCheck('String')
            .appendField('privateUserData');
        this.appendValueInput('script') 
            .setCheck('String')
            .appendField('script');
        this.appendValueInput('scriptTimestamp') 
            .setCheck('Number')
            .appendField('scriptTimestamp');
        this.appendValueInput('serverScripts') 
            .setCheck('String')
            .appendField('serverScripts');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('localPosition') 
            .setCheck('Vec3')
            .appendField('localPosition');
        this.appendValueInput('localRotation') 
            .setCheck('Quat')
            .appendField('localRotation');
        this.appendValueInput('localVelocity') 
            .setCheck('Vec3')
            .appendField('localVelocity');
        this.appendValueInput('localAngularVelocity') 
            .setCheck('Vec3')
            .appendField('localAngularVelocity');
        this.appendValueInput('localDimensions') 
            .setCheck('Vec3')
            .appendField('localDimensions');
        this.appendValueInput('boundingBox') 
            .setCheck('Entities.BoundingBox')
            .appendField('boundingBox');
        this.appendValueInput('queryAACube') 
            .setCheck('AACube')
            .appendField('queryAACube');
        this.appendValueInput('actionData') 
            .setCheck('String')
            .appendField('actionData');
        this.appendValueInput('renderInfo') 
            .setCheck('Entities.RenderInfo')
            .appendField('renderInfo');
        this.appendValueInput('cloneable') 
            .setCheck('Boolean')
            .appendField('cloneable');
        this.appendValueInput('cloneLifetime') 
            .setCheck('Number')
            .appendField('cloneLifetime');
        this.appendValueInput('cloneLimit') 
            .setCheck('Number')
            .appendField('cloneLimit');
        this.appendValueInput('cloneDynamic') 
            .setCheck('Boolean')
            .appendField('cloneDynamic');
        this.appendValueInput('cloneAvatarEntity') 
            .setCheck('Boolean')
            .appendField('cloneAvatarEntity');
        this.appendValueInput('cloneOriginID') 
            .setCheck('Uuid')
            .appendField('cloneOriginID');
        this.appendValueInput('renderWithZones') 
            .setCheck('Array')
            .appendField('renderWithZones');
        this.appendValueInput('billboardMode') 
            .setCheck('BillboardMode')
            .appendField('billboardMode');
        this.appendValueInput('grab') 
            .setCheck('Entities.Grab')
            .appendField('grab');
        this.setColour('#EA9958');
        this.setTooltip('Different entity types have different properties: some common to all entities (listed in the table) and some specific toeach {@link Entities.EntityType|EntityType} (linked to below).');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entityHostType = dfv(generator.valueToCode(block, 'entityHostType', javascript.javascriptGenerator.ORDER_ATOMIC), `"domain"`);
    const _avatarEntity = dfv(generator.valueToCode(block, 'avatarEntity', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _clientOnly = dfv(generator.valueToCode(block, 'clientOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _localEntity = dfv(generator.valueToCode(block, 'localEntity', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _owningAvatarID = dfv(generator.valueToCode(block, 'owningAvatarID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _created = dfv(generator.valueToCode(block, 'created', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _age = dfv(generator.valueToCode(block, 'age', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _ageAsText = dfv(generator.valueToCode(block, 'ageAsText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _lifetime = dfv(generator.valueToCode(block, 'lifetime', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _lastEdited = dfv(generator.valueToCode(block, 'lastEdited', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastEditedBy = dfv(generator.valueToCode(block, 'lastEditedBy', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _locked = dfv(generator.valueToCode(block, 'locked', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _canCastShadow = dfv(generator.valueToCode(block, 'canCastShadow', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _isVisibleInSecondaryCamera = dfv(generator.valueToCode(block, 'isVisibleInSecondaryCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _renderLayer = dfv(generator.valueToCode(block, 'renderLayer', javascript.javascriptGenerator.ORDER_ATOMIC), `"world"`);
    const _primitiveMode = dfv(generator.valueToCode(block, 'primitiveMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"solid"`);
    const _ignorePickIntersection = dfv(generator.valueToCode(block, 'ignorePickIntersection', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _registrationPoint = dfv(generator.valueToCode(block, 'registrationPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0.5,0.5,0.5`);
    const _naturalPosition = dfv(generator.valueToCode(block, 'naturalPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _naturalDimensions = dfv(generator.valueToCode(block, 'naturalDimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _damping = dfv(generator.valueToCode(block, 'damping', javascript.javascriptGenerator.ORDER_ATOMIC), `0.39347`);
    const _angularVelocity = dfv(generator.valueToCode(block, 'angularVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _angularDamping = dfv(generator.valueToCode(block, 'angularDamping', javascript.javascriptGenerator.ORDER_ATOMIC), `0.39347`);
    const _gravity = dfv(generator.valueToCode(block, 'gravity', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _acceleration = dfv(generator.valueToCode(block, 'acceleration', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _restitution = dfv(generator.valueToCode(block, 'restitution', javascript.javascriptGenerator.ORDER_ATOMIC), `0.5`);
    const _friction = dfv(generator.valueToCode(block, 'friction', javascript.javascriptGenerator.ORDER_ATOMIC), `0.5`);
    const _density = dfv(generator.valueToCode(block, 'density', javascript.javascriptGenerator.ORDER_ATOMIC), `1000`);
    const _collisionless = dfv(generator.valueToCode(block, 'collisionless', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _ignoreForCollisions = dfv(generator.valueToCode(block, 'ignoreForCollisions', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _collisionMask = dfv(generator.valueToCode(block, 'collisionMask', javascript.javascriptGenerator.ORDER_ATOMIC), `31`);
    const _collidesWith = dfv(generator.valueToCode(block, 'collidesWith', javascript.javascriptGenerator.ORDER_ATOMIC), `"static,dynamic,kinematic,myAvatar,otherAvatar,"`);
    const _collisionSoundURL = dfv(generator.valueToCode(block, 'collisionSoundURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _dynamic = dfv(generator.valueToCode(block, 'dynamic', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _collisionsWillMove = dfv(generator.valueToCode(block, 'collisionsWillMove', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _href = dfv(generator.valueToCode(block, 'href', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _description = dfv(generator.valueToCode(block, 'description', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _userData = dfv(generator.valueToCode(block, 'userData', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _privateUserData = dfv(generator.valueToCode(block, 'privateUserData', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _script = dfv(generator.valueToCode(block, 'script', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _scriptTimestamp = dfv(generator.valueToCode(block, 'scriptTimestamp', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _serverScripts = dfv(generator.valueToCode(block, 'serverScripts', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `65535`);
    const _localPosition = dfv(generator.valueToCode(block, 'localPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _localRotation = dfv(generator.valueToCode(block, 'localRotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _localVelocity = dfv(generator.valueToCode(block, 'localVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _localAngularVelocity = dfv(generator.valueToCode(block, 'localAngularVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _localDimensions = dfv(generator.valueToCode(block, 'localDimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _boundingBox = dfv(generator.valueToCode(block, 'boundingBox', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _queryAACube = dfv(generator.valueToCode(block, 'queryAACube', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _actionData = dfv(generator.valueToCode(block, 'actionData', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _renderInfo = dfv(generator.valueToCode(block, 'renderInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _cloneable = dfv(generator.valueToCode(block, 'cloneable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _cloneLifetime = dfv(generator.valueToCode(block, 'cloneLifetime', javascript.javascriptGenerator.ORDER_ATOMIC), `300`);
    const _cloneLimit = dfv(generator.valueToCode(block, 'cloneLimit', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _cloneDynamic = dfv(generator.valueToCode(block, 'cloneDynamic', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _cloneAvatarEntity = dfv(generator.valueToCode(block, 'cloneAvatarEntity', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _cloneOriginID = dfv(generator.valueToCode(block, 'cloneOriginID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _renderWithZones = dfv(generator.valueToCode(block, 'renderWithZones', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _billboardMode = dfv(generator.valueToCode(block, 'billboardMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);
    const _grab = dfv(generator.valueToCode(block, 'grab', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.EntityProperties(${_id},${_name},${_type},${_entityHostType},${_avatarEntity},${_clientOnly},${_localEntity},${_owningAvatarID},${_created},${_age},${_ageAsText},${_lifetime},${_lastEdited},${_lastEditedBy},${_locked},${_visible},${_canCastShadow},${_isVisibleInSecondaryCamera},${_renderLayer},${_primitiveMode},${_ignorePickIntersection},${_position},${_rotation},${_registrationPoint},${_naturalPosition},${_naturalDimensions},${_velocity},${_damping},${_angularVelocity},${_angularDamping},${_gravity},${_acceleration},${_restitution},${_friction},${_density},${_collisionless},${_ignoreForCollisions},${_collisionMask},${_collidesWith},${_collisionSoundURL},${_dynamic},${_collisionsWillMove},${_href},${_description},${_userData},${_privateUserData},${_script},${_scriptTimestamp},${_serverScripts},${_parentID},${_parentJointIndex},${_localPosition},${_localRotation},${_localVelocity},${_localAngularVelocity},${_localDimensions},${_boundingBox},${_queryAACube},${_actionData},${_renderInfo},${_cloneable},${_cloneLifetime},${_cloneLimit},${_cloneDynamic},${_cloneAvatarEntity},${_cloneOriginID},${_renderWithZones},${_billboardMode},${_grab})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Box'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Box')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Box"</code> {@link Entities.EntityType|EntityType} is the same as the <code>"Shape"</code>{@link Entities.EntityType|EntityType} except that its <code>shape</code> value is always set to <code>"Cube"</code>when the entity is created. If its <code>shape</code> property value is subsequently changed then the entity\'s<code>type</code> will be reported as <code>"Sphere"</code> if the <code>shape</code> is set to <code>"Sphere"</code>,otherwise it will be reported as <code>"Shape"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Box');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Box'] = (block, generator) => {

    return [`new Entities.EntityProperties-Box()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Light'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Light')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('intensity') 
            .setCheck('Number')
            .appendField('intensity');
        this.appendValueInput('falloffRadius') 
            .setCheck('Number')
            .appendField('falloffRadius');
        this.appendValueInput('isSpotlight') 
            .setCheck('Boolean')
            .appendField('isSpotlight');
        this.appendValueInput('exponent') 
            .setCheck('Number')
            .appendField('exponent');
        this.appendValueInput('cutoff') 
            .setCheck('Number')
            .appendField('cutoff');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Light"</code> {@link Entities.EntityType|EntityType} adds local lighting effects. It has properties in additionto the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Light');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Light'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _intensity = dfv(generator.valueToCode(block, 'intensity', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _falloffRadius = dfv(generator.valueToCode(block, 'falloffRadius', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1`);
    const _isSpotlight = dfv(generator.valueToCode(block, 'isSpotlight', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _exponent = dfv(generator.valueToCode(block, 'exponent', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _cutoff = dfv(generator.valueToCode(block, 'cutoff', javascript.javascriptGenerator.ORDER_ATOMIC), `1.57`);

    return [`new Entities.EntityProperties-Light(${_dimensions},${_color},${_intensity},${_falloffRadius},${_isSpotlight},${_exponent},${_cutoff})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Line'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Line')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('linePoints') 
            .setCheck('Array')
            .appendField('linePoints');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Line"</code> {@link Entities.EntityType|EntityType} draws thin, straight lines between a sequence of two or morepoints. It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.<p class=important>Deprecated: Use {@link Entities.EntityProperties-PolyLine|PolyLine} entities instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Line');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Line'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _linePoints = dfv(generator.valueToCode(block, 'linePoints', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);

    return [`new Entities.EntityProperties-Line(${_dimensions},${_linePoints},${_color})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Material'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Material')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('materialURL') 
            .setCheck('String')
            .appendField('materialURL');
        this.appendValueInput('materialData') 
            .setCheck('String')
            .appendField('materialData');
        this.appendValueInput('priority') 
            .setCheck('Number')
            .appendField('priority');
        this.appendValueInput('parentMaterialName') 
            .setCheck('String')
            .appendField('parentMaterialName');
        this.appendValueInput('materialMappingMode') 
            .setCheck('String')
            .appendField('materialMappingMode');
        this.appendValueInput('materialMappingPos') 
            .setCheck('Vec2')
            .appendField('materialMappingPos');
        this.appendValueInput('materialMappingScale') 
            .setCheck('Vec2')
            .appendField('materialMappingScale');
        this.appendValueInput('materialMappingRot') 
            .setCheck('Number')
            .appendField('materialMappingRot');
        this.appendValueInput('materialRepeat') 
            .setCheck('Boolean')
            .appendField('materialRepeat');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Material"</code> {@link Entities.EntityType|EntityType} modifies existing materials on entities and avatars. Ithas properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.<p>To apply a material to an entity, set the material entity\'s <code>parentID</code> property to the entity ID.To apply a material to an avatar, set the material entity\'s <code>parentID</code> property to the avatar\'s session UUID.To apply a material to your avatar such that it persists across domains and log-ins, create the material as an avatar entityby setting the <code>entityHostType</code> parameter in {@link Entities.addEntity} to <code>"avatar"</code> and set theentity\'s <code>parentID</code> property to <code>MyAvatar.SELF_ID</code>.Material entities render as non-scalable spheres if they don\'t have their parent set.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Material');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Material'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _materialURL = dfv(generator.valueToCode(block, 'materialURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _materialData = dfv(generator.valueToCode(block, 'materialData', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _priority = dfv(generator.valueToCode(block, 'priority', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _parentMaterialName = dfv(generator.valueToCode(block, 'parentMaterialName', javascript.javascriptGenerator.ORDER_ATOMIC), `"0"`);
    const _materialMappingMode = dfv(generator.valueToCode(block, 'materialMappingMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"uv"`);
    const _materialMappingPos = dfv(generator.valueToCode(block, 'materialMappingPos', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0`);
    const _materialMappingScale = dfv(generator.valueToCode(block, 'materialMappingScale', javascript.javascriptGenerator.ORDER_ATOMIC), `1,1`);
    const _materialMappingRot = dfv(generator.valueToCode(block, 'materialMappingRot', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _materialRepeat = dfv(generator.valueToCode(block, 'materialRepeat', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

    return [`new Entities.EntityProperties-Material(${_dimensions},${_materialURL},${_materialData},${_priority},${_parentMaterialName},${_materialMappingMode},${_materialMappingPos},${_materialMappingScale},${_materialMappingRot},${_materialRepeat})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Model'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Model')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('modelURL') 
            .setCheck('String')
            .appendField('modelURL');
        this.appendValueInput('modelScale') 
            .setCheck('Vec3')
            .appendField('modelScale');
        this.appendValueInput('blendshapeCoefficients') 
            .setCheck('String')
            .appendField('blendshapeCoefficients');
        this.appendValueInput('useOriginalPivot') 
            .setCheck('Boolean')
            .appendField('useOriginalPivot');
        this.appendValueInput('textures') 
            .setCheck('String')
            .appendField('textures');
        this.appendValueInput('originalTextures') 
            .setCheck('String')
            .appendField('originalTextures');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('shapeType') 
            .setCheck('ShapeType')
            .appendField('shapeType');
        this.appendValueInput('compoundShapeURL') 
            .setCheck('String')
            .appendField('compoundShapeURL');
        this.appendValueInput('animation') 
            .setCheck('Entities.AnimationProperties')
            .appendField('animation');
        this.appendValueInput('jointRotations') 
            .setCheck('Array')
            .appendField('jointRotations');
        this.appendValueInput('jointRotationsSet') 
            .setCheck('Array')
            .appendField('jointRotationsSet');
        this.appendValueInput('jointTranslations') 
            .setCheck('Array')
            .appendField('jointTranslations');
        this.appendValueInput('jointTranslationsSet') 
            .setCheck('Array')
            .appendField('jointTranslationsSet');
        this.appendValueInput('relayParentJoints') 
            .setCheck('Boolean')
            .appendField('relayParentJoints');
        this.appendValueInput('groupCulled') 
            .setCheck('Boolean')
            .appendField('groupCulled');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Model"</code> {@link Entities.EntityType|EntityType} displays a glTF, FBX, or OBJ model. When adding an entity,if no <code>dimensions</code> value is specified then the model is automatically sized to its<code>{@link Entities.EntityProperties|naturalDimensions}</code>. It has properties in addition to the common{@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Model');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Model'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _modelURL = dfv(generator.valueToCode(block, 'modelURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _modelScale = dfv(generator.valueToCode(block, 'modelScale', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _blendshapeCoefficients = dfv(generator.valueToCode(block, 'blendshapeCoefficients', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _useOriginalPivot = dfv(generator.valueToCode(block, 'useOriginalPivot', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _textures = dfv(generator.valueToCode(block, 'textures', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _originalTextures = dfv(generator.valueToCode(block, 'originalTextures', javascript.javascriptGenerator.ORDER_ATOMIC), `"{}"`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _shapeType = dfv(generator.valueToCode(block, 'shapeType', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);
    const _compoundShapeURL = dfv(generator.valueToCode(block, 'compoundShapeURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _animation = dfv(generator.valueToCode(block, 'animation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointRotations = dfv(generator.valueToCode(block, 'jointRotations', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _jointRotationsSet = dfv(generator.valueToCode(block, 'jointRotationsSet', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _jointTranslations = dfv(generator.valueToCode(block, 'jointTranslations', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _jointTranslationsSet = dfv(generator.valueToCode(block, 'jointTranslationsSet', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _relayParentJoints = dfv(generator.valueToCode(block, 'relayParentJoints', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _groupCulled = dfv(generator.valueToCode(block, 'groupCulled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.EntityProperties-Model(${_dimensions},${_modelURL},${_modelScale},${_blendshapeCoefficients},${_useOriginalPivot},${_textures},${_originalTextures},${_color},${_shapeType},${_compoundShapeURL},${_animation},${_jointRotations},${_jointRotationsSet},${_jointTranslations},${_jointTranslationsSet},${_relayParentJoints},${_groupCulled})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-ParticleEffect'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-ParticleEffect')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('isEmitting') 
            .setCheck('Boolean')
            .appendField('isEmitting');
        this.appendValueInput('maxParticles') 
            .setCheck('Number')
            .appendField('maxParticles');
        this.appendValueInput('lifespan') 
            .setCheck('Number')
            .appendField('lifespan');
        this.appendValueInput('emitRate') 
            .setCheck('Number')
            .appendField('emitRate');
        this.appendValueInput('emitSpeed') 
            .setCheck('Number')
            .appendField('emitSpeed');
        this.appendValueInput('speedSpread') 
            .setCheck('Number')
            .appendField('speedSpread');
        this.appendValueInput('emitAcceleration') 
            .setCheck('Vec3')
            .appendField('emitAcceleration');
        this.appendValueInput('accelerationSpread') 
            .setCheck('Vec3')
            .appendField('accelerationSpread');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('emitterShouldTrail') 
            .setCheck('Boolean')
            .appendField('emitterShouldTrail');
        this.appendValueInput('emitOrientation') 
            .setCheck('Quat')
            .appendField('emitOrientation');
        this.appendValueInput('shapeType') 
            .setCheck('ShapeType')
            .appendField('shapeType');
        this.appendValueInput('compoundShapeURL') 
            .setCheck('String')
            .appendField('compoundShapeURL');
        this.appendValueInput('emitDimensions') 
            .setCheck('Vec3')
            .appendField('emitDimensions');
        this.appendValueInput('emitRadiusStart') 
            .setCheck('Number')
            .appendField('emitRadiusStart');
        this.appendValueInput('polarStart') 
            .setCheck('Number')
            .appendField('polarStart');
        this.appendValueInput('polarFinish') 
            .setCheck('Number')
            .appendField('polarFinish');
        this.appendValueInput('azimuthStart') 
            .setCheck('Number')
            .appendField('azimuthStart');
        this.appendValueInput('azimuthFinish') 
            .setCheck('Number')
            .appendField('azimuthFinish');
        this.appendValueInput('textures') 
            .setCheck('String')
            .appendField('textures');
        this.appendValueInput('particleRadius') 
            .setCheck('Number')
            .appendField('particleRadius');
        this.appendValueInput('radiusStart') 
            .setCheck('Number')
            .appendField('radiusStart');
        this.appendValueInput('radiusFinish') 
            .setCheck('Number')
            .appendField('radiusFinish');
        this.appendValueInput('radiusSpread') 
            .setCheck('Number')
            .appendField('radiusSpread');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('colorStart') 
            .setCheck('ColorFloat')
            .appendField('colorStart');
        this.appendValueInput('colorFinish') 
            .setCheck('ColorFloat')
            .appendField('colorFinish');
        this.appendValueInput('colorSpread') 
            .setCheck('Color')
            .appendField('colorSpread');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('alphaStart') 
            .setCheck('Number')
            .appendField('alphaStart');
        this.appendValueInput('alphaFinish') 
            .setCheck('Number')
            .appendField('alphaFinish');
        this.appendValueInput('alphaSpread') 
            .setCheck('Number')
            .appendField('alphaSpread');
        this.appendValueInput('pulse') 
            .setCheck('Entities.Pulse')
            .appendField('pulse');
        this.appendValueInput('particleSpin') 
            .setCheck('Number')
            .appendField('particleSpin');
        this.appendValueInput('spinStart') 
            .setCheck('Number')
            .appendField('spinStart');
        this.appendValueInput('spinFinish') 
            .setCheck('Number')
            .appendField('spinFinish');
        this.appendValueInput('spinSpread') 
            .setCheck('Number')
            .appendField('spinSpread');
        this.appendValueInput('rotateWithEntity') 
            .setCheck('Boolean')
            .appendField('rotateWithEntity');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"ParticleEffect"</code> {@link Entities.EntityType|EntityType} displays a particle system that can be used tosimulate things such as fire, smoke, snow, magic spells, etc. The particles emanate from an ellipsoid or part thereof.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-ParticleEffect');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-ParticleEffect'] = (block, generator) => {
    const _isEmitting = dfv(generator.valueToCode(block, 'isEmitting', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _maxParticles = dfv(generator.valueToCode(block, 'maxParticles', javascript.javascriptGenerator.ORDER_ATOMIC), `1000`);
    const _lifespan = dfv(generator.valueToCode(block, 'lifespan', javascript.javascriptGenerator.ORDER_ATOMIC), `3s`);
    const _emitRate = dfv(generator.valueToCode(block, 'emitRate', javascript.javascriptGenerator.ORDER_ATOMIC), `15`);
    const _emitSpeed = dfv(generator.valueToCode(block, 'emitSpeed', javascript.javascriptGenerator.ORDER_ATOMIC), `5`);
    const _speedSpread = dfv(generator.valueToCode(block, 'speedSpread', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _emitAcceleration = dfv(generator.valueToCode(block, 'emitAcceleration', javascript.javascriptGenerator.ORDER_ATOMIC), `0,-9.8,0`);
    const _accelerationSpread = dfv(generator.valueToCode(block, 'accelerationSpread', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _emitterShouldTrail = dfv(generator.valueToCode(block, 'emitterShouldTrail', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _emitOrientation = dfv(generator.valueToCode(block, 'emitOrientation', javascript.javascriptGenerator.ORDER_ATOMIC), `-0.707,0,0,0.707`);
    const _shapeType = dfv(generator.valueToCode(block, 'shapeType', javascript.javascriptGenerator.ORDER_ATOMIC), `"ellipsoid"`);
    const _compoundShapeURL = dfv(generator.valueToCode(block, 'compoundShapeURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _emitDimensions = dfv(generator.valueToCode(block, 'emitDimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _emitRadiusStart = dfv(generator.valueToCode(block, 'emitRadiusStart', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _polarStart = dfv(generator.valueToCode(block, 'polarStart', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _polarFinish = dfv(generator.valueToCode(block, 'polarFinish', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _azimuthStart = dfv(generator.valueToCode(block, 'azimuthStart', javascript.javascriptGenerator.ORDER_ATOMIC), `-Math.PI`);
    const _azimuthFinish = dfv(generator.valueToCode(block, 'azimuthFinish', javascript.javascriptGenerator.ORDER_ATOMIC), `Math.PI`);
    const _textures = dfv(generator.valueToCode(block, 'textures', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _particleRadius = dfv(generator.valueToCode(block, 'particleRadius', javascript.javascriptGenerator.ORDER_ATOMIC), `0.025`);
    const _radiusStart = dfv(generator.valueToCode(block, 'radiusStart', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _radiusFinish = dfv(generator.valueToCode(block, 'radiusFinish', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _radiusSpread = dfv(generator.valueToCode(block, 'radiusSpread', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _colorStart = dfv(generator.valueToCode(block, 'colorStart', javascript.javascriptGenerator.ORDER_ATOMIC), `null,null,null`);
    const _colorFinish = dfv(generator.valueToCode(block, 'colorFinish', javascript.javascriptGenerator.ORDER_ATOMIC), `null,null,null`);
    const _colorSpread = dfv(generator.valueToCode(block, 'colorSpread', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _alphaStart = dfv(generator.valueToCode(block, 'alphaStart', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _alphaFinish = dfv(generator.valueToCode(block, 'alphaFinish', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _alphaSpread = dfv(generator.valueToCode(block, 'alphaSpread', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _pulse = dfv(generator.valueToCode(block, 'pulse', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _particleSpin = dfv(generator.valueToCode(block, 'particleSpin', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _spinStart = dfv(generator.valueToCode(block, 'spinStart', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _spinFinish = dfv(generator.valueToCode(block, 'spinFinish', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _spinSpread = dfv(generator.valueToCode(block, 'spinSpread', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotateWithEntity = dfv(generator.valueToCode(block, 'rotateWithEntity', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.EntityProperties-ParticleEffect(${_isEmitting},${_maxParticles},${_lifespan},${_emitRate},${_emitSpeed},${_speedSpread},${_emitAcceleration},${_accelerationSpread},${_dimensions},${_emitterShouldTrail},${_emitOrientation},${_shapeType},${_compoundShapeURL},${_emitDimensions},${_emitRadiusStart},${_polarStart},${_polarFinish},${_azimuthStart},${_azimuthFinish},${_textures},${_particleRadius},${_radiusStart},${_radiusFinish},${_radiusSpread},${_color},${_colorStart},${_colorFinish},${_colorSpread},${_alpha},${_alphaStart},${_alphaFinish},${_alphaSpread},${_pulse},${_particleSpin},${_spinStart},${_spinFinish},${_spinSpread},${_rotateWithEntity})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-PolyLine'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-PolyLine')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('linePoints') 
            .setCheck('Array')
            .appendField('linePoints');
        this.appendValueInput('normals') 
            .setCheck('Array')
            .appendField('normals');
        this.appendValueInput('strokeWidths') 
            .setCheck('Array')
            .appendField('strokeWidths');
        this.appendValueInput('strokeColors') 
            .setCheck('Array')
            .appendField('strokeColors');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('textures') 
            .setCheck('String')
            .appendField('textures');
        this.appendValueInput('isUVModeStretch') 
            .setCheck('Boolean')
            .appendField('isUVModeStretch');
        this.appendValueInput('glow') 
            .setCheck('Boolean')
            .appendField('glow');
        this.appendValueInput('faceCamera') 
            .setCheck('Boolean')
            .appendField('faceCamera');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"PolyLine"</code> {@link Entities.EntityType|EntityType} draws textured, straight lines between a sequence ofpoints. It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-PolyLine');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-PolyLine'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _linePoints = dfv(generator.valueToCode(block, 'linePoints', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _normals = dfv(generator.valueToCode(block, 'normals', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _strokeWidths = dfv(generator.valueToCode(block, 'strokeWidths', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _strokeColors = dfv(generator.valueToCode(block, 'strokeColors', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _textures = dfv(generator.valueToCode(block, 'textures', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _isUVModeStretch = dfv(generator.valueToCode(block, 'isUVModeStretch', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _glow = dfv(generator.valueToCode(block, 'glow', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _faceCamera = dfv(generator.valueToCode(block, 'faceCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.EntityProperties-PolyLine(${_dimensions},${_linePoints},${_normals},${_strokeWidths},${_strokeColors},${_color},${_textures},${_isUVModeStretch},${_glow},${_faceCamera})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-PolyVox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-PolyVox')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('voxelVolumeSize') 
            .setCheck('Vec3')
            .appendField('voxelVolumeSize');
        this.appendValueInput('voxelData') 
            .setCheck('String')
            .appendField('voxelData');
        this.appendValueInput('voxelSurfaceStyle') 
            .setCheck('Entities.PolyVoxSurfaceStyle')
            .appendField('voxelSurfaceStyle');
        this.appendValueInput('xTextureURL') 
            .setCheck('String')
            .appendField('xTextureURL');
        this.appendValueInput('yTextureURL') 
            .setCheck('String')
            .appendField('yTextureURL');
        this.appendValueInput('zTextureURL') 
            .setCheck('String')
            .appendField('zTextureURL');
        this.appendValueInput('xNNeighborID') 
            .setCheck('Uuid')
            .appendField('xNNeighborID');
        this.appendValueInput('yNNeighborID') 
            .setCheck('Uuid')
            .appendField('yNNeighborID');
        this.appendValueInput('zNNeighborID') 
            .setCheck('Uuid')
            .appendField('zNNeighborID');
        this.appendValueInput('xPNeighborID') 
            .setCheck('Uuid')
            .appendField('xPNeighborID');
        this.appendValueInput('yPNeighborID') 
            .setCheck('Uuid')
            .appendField('yPNeighborID');
        this.appendValueInput('zPNeighborID') 
            .setCheck('Uuid')
            .appendField('zPNeighborID');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"PolyVox"</code> {@link Entities.EntityType|EntityType} displays a set of textured voxels.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.If you have two or more neighboring PolyVox entities of the same size abutting each other, you can display them as joined byconfiguring their <code>voxelSurfaceStyle</code> and various neighbor ID properties.<p>PolyVox entities uses a library from <a href="http://www.volumesoffun.com/">Volumes of Fun</a>. Their<a href="http://www.volumesoffun.com/polyvox-documentation/">library documentation</a> may be useful to read.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-PolyVox');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-PolyVox'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _voxelVolumeSize = dfv(generator.valueToCode(block, 'voxelVolumeSize', javascript.javascriptGenerator.ORDER_ATOMIC), `32,32,32`);
    const _voxelData = dfv(generator.valueToCode(block, 'voxelData', javascript.javascriptGenerator.ORDER_ATOMIC), `"ABAAEAAQAAAAHgAAEAB42u3BAQ0AAADCoPdPbQ8HFAAAAPBuEAAAAQ=="`);
    const _voxelSurfaceStyle = dfv(generator.valueToCode(block, 'voxelSurfaceStyle', javascript.javascriptGenerator.ORDER_ATOMIC), `2`);
    const _xTextureURL = dfv(generator.valueToCode(block, 'xTextureURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _yTextureURL = dfv(generator.valueToCode(block, 'yTextureURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _zTextureURL = dfv(generator.valueToCode(block, 'zTextureURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _xNNeighborID = dfv(generator.valueToCode(block, 'xNNeighborID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _yNNeighborID = dfv(generator.valueToCode(block, 'yNNeighborID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _zNNeighborID = dfv(generator.valueToCode(block, 'zNNeighborID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _xPNeighborID = dfv(generator.valueToCode(block, 'xPNeighborID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _yPNeighborID = dfv(generator.valueToCode(block, 'yPNeighborID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);
    const _zPNeighborID = dfv(generator.valueToCode(block, 'zPNeighborID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);

    return [`new Entities.EntityProperties-PolyVox(${_dimensions},${_voxelVolumeSize},${_voxelData},${_voxelSurfaceStyle},${_xTextureURL},${_yTextureURL},${_zTextureURL},${_xNNeighborID},${_yNNeighborID},${_zNNeighborID},${_xPNeighborID},${_yPNeighborID},${_zPNeighborID})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Shape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Shape')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('shape') 
            .setCheck('Entities.Shape')
            .appendField('shape');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('pulse') 
            .setCheck('Entities.Pulse')
            .appendField('pulse');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Shape"</code> {@link Entities.EntityType|EntityType} displays an entity of a specified <code>shape</code>.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Shape');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Shape'] = (block, generator) => {
    const _shape = dfv(generator.valueToCode(block, 'shape', javascript.javascriptGenerator.ORDER_ATOMIC), `"Sphere"`);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _pulse = dfv(generator.valueToCode(block, 'pulse', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.EntityProperties-Shape(${_shape},${_dimensions},${_color},${_alpha},${_pulse})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Sphere'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Sphere')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Sphere"</code> {@link Entities.EntityType|EntityType} is the same as the <code>"Shape"</code>{@link Entities.EntityType|EntityType} except that its <code>shape</code> value is always set to <code>"Sphere"</code>when the entity is created. If its <code>shape</code> property value is subsequently changed then the entity\'s<code>type</code> will be reported as <code>"Box"</code> if the <code>shape</code> is set to <code>"Cube"</code>,otherwise it will be reported as <code>"Shape"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Sphere');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Sphere'] = (block, generator) => {

    return [`new Entities.EntityProperties-Sphere()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Text'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Text')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');
        this.appendValueInput('lineHeight') 
            .setCheck('Number')
            .appendField('lineHeight');
        this.appendValueInput('textColor') 
            .setCheck('Color')
            .appendField('textColor');
        this.appendValueInput('textAlpha') 
            .setCheck('Number')
            .appendField('textAlpha');
        this.appendValueInput('backgroundColor') 
            .setCheck('Color')
            .appendField('backgroundColor');
        this.appendValueInput('backgroundAlpha') 
            .setCheck('Number')
            .appendField('backgroundAlpha');
        this.appendValueInput('pulse') 
            .setCheck('Entities.Pulse')
            .appendField('pulse');
        this.appendValueInput('leftMargin') 
            .setCheck('Number')
            .appendField('leftMargin');
        this.appendValueInput('rightMargin') 
            .setCheck('Number')
            .appendField('rightMargin');
        this.appendValueInput('topMargin') 
            .setCheck('Number')
            .appendField('topMargin');
        this.appendValueInput('bottomMargin') 
            .setCheck('Number')
            .appendField('bottomMargin');
        this.appendValueInput('unlit') 
            .setCheck('Boolean')
            .appendField('unlit');
        this.appendValueInput('font') 
            .setCheck('String')
            .appendField('font');
        this.appendValueInput('textEffect') 
            .setCheck('Entities.TextEffect')
            .appendField('textEffect');
        this.appendValueInput('textEffectColor') 
            .setCheck('Color')
            .appendField('textEffectColor');
        this.appendValueInput('textEffectThickness') 
            .setCheck('Number')
            .appendField('textEffectThickness');
        this.appendValueInput('alignment') 
            .setCheck('Entities.TextAlignment')
            .appendField('alignment');
        this.appendValueInput('faceCamera') 
            .setCheck('Boolean')
            .appendField('faceCamera');
        this.appendValueInput('isFacingAvatar') 
            .setCheck('Boolean')
            .appendField('isFacingAvatar');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Text"</code> {@link Entities.EntityType|EntityType} displays a 2D rectangle of text in the domain.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Text');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Text'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.01`);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _lineHeight = dfv(generator.valueToCode(block, 'lineHeight', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1`);
    const _textColor = dfv(generator.valueToCode(block, 'textColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _textAlpha = dfv(generator.valueToCode(block, 'textAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _backgroundColor = dfv(generator.valueToCode(block, 'backgroundColor', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _backgroundAlpha = dfv(generator.valueToCode(block, 'backgroundAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _pulse = dfv(generator.valueToCode(block, 'pulse', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _leftMargin = dfv(generator.valueToCode(block, 'leftMargin', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _rightMargin = dfv(generator.valueToCode(block, 'rightMargin', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _topMargin = dfv(generator.valueToCode(block, 'topMargin', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _bottomMargin = dfv(generator.valueToCode(block, 'bottomMargin', javascript.javascriptGenerator.ORDER_ATOMIC), `0.0`);
    const _unlit = dfv(generator.valueToCode(block, 'unlit', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _font = dfv(generator.valueToCode(block, 'font', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _textEffect = dfv(generator.valueToCode(block, 'textEffect', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);
    const _textEffectColor = dfv(generator.valueToCode(block, 'textEffectColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _textEffectThickness = dfv(generator.valueToCode(block, 'textEffectThickness', javascript.javascriptGenerator.ORDER_ATOMIC), `0.2`);
    const _alignment = dfv(generator.valueToCode(block, 'alignment', javascript.javascriptGenerator.ORDER_ATOMIC), `"left"`);
    const _faceCamera = dfv(generator.valueToCode(block, 'faceCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isFacingAvatar = dfv(generator.valueToCode(block, 'isFacingAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.EntityProperties-Text(${_dimensions},${_text},${_lineHeight},${_textColor},${_textAlpha},${_backgroundColor},${_backgroundAlpha},${_pulse},${_leftMargin},${_rightMargin},${_topMargin},${_bottomMargin},${_unlit},${_font},${_textEffect},${_textEffectColor},${_textEffectThickness},${_alignment},${_faceCamera},${_isFacingAvatar})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Web'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Web')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('sourceUrl') 
            .setCheck('String')
            .appendField('sourceUrl');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('pulse') 
            .setCheck('Entities.Pulse')
            .appendField('pulse');
        this.appendValueInput('faceCamera') 
            .setCheck('Boolean')
            .appendField('faceCamera');
        this.appendValueInput('isFacingAvatar') 
            .setCheck('Boolean')
            .appendField('isFacingAvatar');
        this.appendValueInput('dpi') 
            .setCheck('Number')
            .appendField('dpi');
        this.appendValueInput('scriptURL') 
            .setCheck('String')
            .appendField('scriptURL');
        this.appendValueInput('maxFPS') 
            .setCheck('Number')
            .appendField('maxFPS');
        this.appendValueInput('inputMode') 
            .setCheck('WebInputMode')
            .appendField('inputMode');
        this.appendValueInput('showKeyboardFocusHighlight') 
            .setCheck('Boolean')
            .appendField('showKeyboardFocusHighlight');
        this.appendValueInput('useBackground') 
            .setCheck('Boolean')
            .appendField('useBackground');
        this.appendValueInput('userAgent') 
            .setCheck('String')
            .appendField('userAgent');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Web"</code> {@link Entities.EntityType|EntityType} displays a browsable web page. Each user views their own copyof the web page: if one user navigates to another page on the entity, other users do not see the change; if a video is beingplayed, users don\'t see it in sync. Internally, a Web entity is rendered as a non-repeating, upside down texture, so additionaltransformations may be necessary if you reference a Web entity texture by UUID. It has properties in addition to the common{@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Web');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Web'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.01`);
    const _sourceUrl = dfv(generator.valueToCode(block, 'sourceUrl', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _pulse = dfv(generator.valueToCode(block, 'pulse', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _faceCamera = dfv(generator.valueToCode(block, 'faceCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isFacingAvatar = dfv(generator.valueToCode(block, 'isFacingAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _dpi = dfv(generator.valueToCode(block, 'dpi', javascript.javascriptGenerator.ORDER_ATOMIC), `30`);
    const _scriptURL = dfv(generator.valueToCode(block, 'scriptURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _maxFPS = dfv(generator.valueToCode(block, 'maxFPS', javascript.javascriptGenerator.ORDER_ATOMIC), `10`);
    const _inputMode = dfv(generator.valueToCode(block, 'inputMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"touch"`);
    const _showKeyboardFocusHighlight = dfv(generator.valueToCode(block, 'showKeyboardFocusHighlight', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _useBackground = dfv(generator.valueToCode(block, 'useBackground', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _userAgent = dfv(generator.valueToCode(block, 'userAgent', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.EntityProperties-Web(${_dimensions},${_sourceUrl},${_color},${_alpha},${_pulse},${_faceCamera},${_isFacingAvatar},${_dpi},${_scriptURL},${_maxFPS},${_inputMode},${_showKeyboardFocusHighlight},${_useBackground},${_userAgent})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Zone'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Zone')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('shapeType') 
            .setCheck('ShapeType')
            .appendField('shapeType');
        this.appendValueInput('compoundShapeURL') 
            .setCheck('String')
            .appendField('compoundShapeURL');
        this.appendValueInput('keyLightMode') 
            .setCheck('Entities.ComponentMode')
            .appendField('keyLightMode');
        this.appendValueInput('keyLight') 
            .setCheck('Entities.KeyLight')
            .appendField('keyLight');
        this.appendValueInput('ambientLightMode') 
            .setCheck('Entities.ComponentMode')
            .appendField('ambientLightMode');
        this.appendValueInput('ambientLight') 
            .setCheck('Entities.AmbientLight')
            .appendField('ambientLight');
        this.appendValueInput('skyboxMode') 
            .setCheck('Entities.ComponentMode')
            .appendField('skyboxMode');
        this.appendValueInput('skybox') 
            .setCheck('Entities.Skybox')
            .appendField('skybox');
        this.appendValueInput('hazeMode') 
            .setCheck('Entities.ComponentMode')
            .appendField('hazeMode');
        this.appendValueInput('haze') 
            .setCheck('Entities.Haze')
            .appendField('haze');
        this.appendValueInput('bloomMode') 
            .setCheck('Entities.ComponentMode')
            .appendField('bloomMode');
        this.appendValueInput('bloom') 
            .setCheck('Entities.Bloom')
            .appendField('bloom');
        this.appendValueInput('flyingAllowed') 
            .setCheck('Boolean')
            .appendField('flyingAllowed');
        this.appendValueInput('ghostingAllowed') 
            .setCheck('Boolean')
            .appendField('ghostingAllowed');
        this.appendValueInput('filterURL') 
            .setCheck('String')
            .appendField('filterURL');
        this.appendValueInput('avatarPriority') 
            .setCheck('Entities.AvatarPriorityMode')
            .appendField('avatarPriority');
        this.appendValueInput('screenshare') 
            .setCheck('Entities.ScreenshareMode')
            .appendField('screenshare');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Zone"</code> {@link Entities.EntityType|EntityType} is a volume of lighting effects and avatar permissions.Avatar interaction events such as {@link Entities.enterEntity} are also often used with a Zone entity. It has properties inaddition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Zone');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Zone'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.1`);
    const _shapeType = dfv(generator.valueToCode(block, 'shapeType', javascript.javascriptGenerator.ORDER_ATOMIC), `"box"`);
    const _compoundShapeURL = dfv(generator.valueToCode(block, 'compoundShapeURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _keyLightMode = dfv(generator.valueToCode(block, 'keyLightMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);
    const _keyLight = dfv(generator.valueToCode(block, 'keyLight', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _ambientLightMode = dfv(generator.valueToCode(block, 'ambientLightMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);
    const _ambientLight = dfv(generator.valueToCode(block, 'ambientLight', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _skyboxMode = dfv(generator.valueToCode(block, 'skyboxMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);
    const _skybox = dfv(generator.valueToCode(block, 'skybox', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hazeMode = dfv(generator.valueToCode(block, 'hazeMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);
    const _haze = dfv(generator.valueToCode(block, 'haze', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _bloomMode = dfv(generator.valueToCode(block, 'bloomMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);
    const _bloom = dfv(generator.valueToCode(block, 'bloom', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _flyingAllowed = dfv(generator.valueToCode(block, 'flyingAllowed', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _ghostingAllowed = dfv(generator.valueToCode(block, 'ghostingAllowed', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _filterURL = dfv(generator.valueToCode(block, 'filterURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _avatarPriority = dfv(generator.valueToCode(block, 'avatarPriority', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);
    const _screenshare = dfv(generator.valueToCode(block, 'screenshare', javascript.javascriptGenerator.ORDER_ATOMIC), `"inherit"`);

    return [`new Entities.EntityProperties-Zone(${_dimensions},${_shapeType},${_compoundShapeURL},${_keyLightMode},${_keyLight},${_ambientLightMode},${_ambientLight},${_skyboxMode},${_skybox},${_hazeMode},${_haze},${_bloomMode},${_bloom},${_flyingAllowed},${_ghostingAllowed},${_filterURL},${_avatarPriority},${_screenshare})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Image'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Image')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('imageURL') 
            .setCheck('String')
            .appendField('imageURL');
        this.appendValueInput('emissive') 
            .setCheck('Boolean')
            .appendField('emissive');
        this.appendValueInput('keepAspectRatio') 
            .setCheck('Boolean')
            .appendField('keepAspectRatio');
        this.appendValueInput('subImage') 
            .setCheck('Rect')
            .appendField('subImage');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('pulse') 
            .setCheck('Entities.Pulse')
            .appendField('pulse');
        this.appendValueInput('faceCamera') 
            .setCheck('Boolean')
            .appendField('faceCamera');
        this.appendValueInput('isFacingAvatar') 
            .setCheck('Boolean')
            .appendField('isFacingAvatar');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Image"</code> {@link Entities.EntityType|EntityType} displays an image on a 2D rectangle in the domain.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Image');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Image'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.1,0.01`);
    const _imageURL = dfv(generator.valueToCode(block, 'imageURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _emissive = dfv(generator.valueToCode(block, 'emissive', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _keepAspectRatio = dfv(generator.valueToCode(block, 'keepAspectRatio', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _subImage = dfv(generator.valueToCode(block, 'subImage', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,0`);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _pulse = dfv(generator.valueToCode(block, 'pulse', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _faceCamera = dfv(generator.valueToCode(block, 'faceCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isFacingAvatar = dfv(generator.valueToCode(block, 'isFacingAvatar', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Entities.EntityProperties-Image(${_dimensions},${_imageURL},${_emissive},${_keepAspectRatio},${_subImage},${_color},${_alpha},${_pulse},${_faceCamera},${_isFacingAvatar})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Grid'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Grid')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');
        this.appendValueInput('pulse') 
            .setCheck('Entities.Pulse')
            .appendField('pulse');
        this.appendValueInput('followCamera') 
            .setCheck('Boolean')
            .appendField('followCamera');
        this.appendValueInput('majorGridEvery') 
            .setCheck('Number')
            .appendField('majorGridEvery');
        this.appendValueInput('minorGridEvery') 
            .setCheck('Number')
            .appendField('minorGridEvery');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Grid"</code> {@link Entities.EntityType|EntityType} displays a grid on a 2D plane.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Grid');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Grid'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _pulse = dfv(generator.valueToCode(block, 'pulse', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _followCamera = dfv(generator.valueToCode(block, 'followCamera', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _majorGridEvery = dfv(generator.valueToCode(block, 'majorGridEvery', javascript.javascriptGenerator.ORDER_ATOMIC), `5`);
    const _minorGridEvery = dfv(generator.valueToCode(block, 'minorGridEvery', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);

    return [`new Entities.EntityProperties-Grid(${_dimensions},${_color},${_alpha},${_pulse},${_followCamera},${_majorGridEvery},${_minorGridEvery})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityProperties-Gizmo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityProperties-Gizmo')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('gizmoType') 
            .setCheck('Entities.GizmoType')
            .appendField('gizmoType');
        this.appendValueInput('ring') 
            .setCheck('Entities.RingGizmo')
            .appendField('ring');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"Gizmo"</code> {@link Entities.EntityType|EntityType} displays an entity that could be used as UI.It has properties in addition to the common {@link Entities.EntityProperties|EntityProperties}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityProperties-Gizmo');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityProperties-Gizmo'] = (block, generator) => {
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1,0.001,0.1`);
    const _gizmoType = dfv(generator.valueToCode(block, 'gizmoType', javascript.javascriptGenerator.ORDER_ATOMIC), `"ring"`);
    const _ring = dfv(generator.valueToCode(block, 'ring', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.EntityProperties-Gizmo(${_dimensions},${_gizmoType},${_ring})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_BoundingBox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.BoundingBox')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('brn') 
            .setCheck('Vec3')
            .appendField('brn');
        this.appendValueInput('tfl') 
            .setCheck('Vec3')
            .appendField('tfl');
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.setColour('#EA9958');
        this.setTooltip('The axis-aligned bounding box of an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.BoundingBox');
    }
};
javascript.javascriptGenerator.forBlock['Entities_BoundingBox'] = (block, generator) => {
    const _brn = dfv(generator.valueToCode(block, 'brn', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _tfl = dfv(generator.valueToCode(block, 'tfl', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.BoundingBox(${_brn},${_tfl},${_center},${_dimensions})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_RenderInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.RenderInfo')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('verticesCount') 
            .setCheck('Number')
            .appendField('verticesCount');
        this.appendValueInput('texturesCount') 
            .setCheck('Number')
            .appendField('texturesCount');
        this.appendValueInput('texturesSize') 
            .setCheck('Number')
            .appendField('texturesSize');
        this.appendValueInput('hasTransparent') 
            .setCheck('Boolean')
            .appendField('hasTransparent');
        this.appendValueInput('drawCalls') 
            .setCheck('Number')
            .appendField('drawCalls');
        this.setColour('#EA9958');
        this.setTooltip('Information on how an entity is rendered. Properties are only filled in for <code>Model</code> entities; otherentity types have an empty object, <code>{}</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.RenderInfo');
    }
};
javascript.javascriptGenerator.forBlock['Entities_RenderInfo'] = (block, generator) => {
    const _verticesCount = dfv(generator.valueToCode(block, 'verticesCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _texturesCount = dfv(generator.valueToCode(block, 'texturesCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _texturesSize = dfv(generator.valueToCode(block, 'texturesSize', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _hasTransparent = dfv(generator.valueToCode(block, 'hasTransparent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _drawCalls = dfv(generator.valueToCode(block, 'drawCalls', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Entities.RenderInfo(${_verticesCount},${_texturesCount},${_texturesSize},${_hasTransparent},${_drawCalls})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_EntityPropertyInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityPropertyInfo')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('propertyEnum') 
            .setCheck('Number')
            .appendField('propertyEnum');
        this.appendValueInput('minimum') 
            .setCheck('String')
            .appendField('minimum');
        this.appendValueInput('maximum') 
            .setCheck('String')
            .appendField('maximum');
        this.setColour('#EA9958');
        this.setTooltip('Information about an entity property.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityPropertyInfo');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityPropertyInfo'] = (block, generator) => {
    const _propertyEnum = dfv(generator.valueToCode(block, 'propertyEnum', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _minimum = dfv(generator.valueToCode(block, 'minimum', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _maximum = dfv(generator.valueToCode(block, 'maximum', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.EntityPropertyInfo(${_propertyEnum},${_minimum},${_maximum})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['EntityScriptServerLog_receivedNewLogLines'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('EntityScriptServerLog.receivedNewLogLines')
        // Returns data

        // Params data
        this.appendValueInput('logLines') 
            .setCheck('String')
            .appendField('logLines');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#512C98');
        this.setTooltip('Triggered when one or more lines are written to the server log by server entity scripts.');
        this.setHelpUrl('https://apidocs.overte.org/EntityScriptServerLog.html#.receivedNewLogLines');
    }
};
javascript.javascriptGenerator.forBlock['EntityScriptServerLog_receivedNewLogLines'] = (block, generator) => {
    const _logLines = dfv(generator.valueToCode(block, 'logLines', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `EntityScriptServerLog.receivedNewLogLines(${_logLines});\n`;};


// Blockly typedef
Blockly.Blocks['Script~entityEventCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script~entityEventCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F907E6');
        this.setTooltip('Called when an entity event occurs on an entity as registered with {@link Script.addEventHandler}.');
        this.setHelpUrl('https://apidocs.overte.org/Script~entityEventCallback');
    }
};
javascript.javascriptGenerator.forBlock['Script~entityEventCallback'] = (block, generator) => {

    return [`new Script~entityEventCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Script~pointerEventCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script~pointerEventCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F907E6');
        this.setTooltip('Called when a pointer event occurs on an entity as registered with {@link Script.addEventHandler}.');
        this.setHelpUrl('https://apidocs.overte.org/Script~pointerEventCallback');
    }
};
javascript.javascriptGenerator.forBlock['Script~pointerEventCallback'] = (block, generator) => {

    return [`new Script~pointerEventCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Script~collisionEventCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script~collisionEventCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F907E6');
        this.setTooltip('Called when a collision event occurs on an entity as registered with {@link Script.addEventHandler}.');
        this.setHelpUrl('https://apidocs.overte.org/Script~collisionEventCallback');
    }
};
javascript.javascriptGenerator.forBlock['Script~collisionEventCallback'] = (block, generator) => {

    return [`new Script~collisionEventCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Script_EntityEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.EntityEvent')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F907E6');
        this.setTooltip('<p>The name of an entity event. When the entity event occurs, any function that has been registered for that eventvia {@link Script.addEventHandler} is called with parameters per the entity event.</p><table>  <thead>    <tr><th>Event Name</th><th>Callback Type</th><th>Entity Event</th></tr>  </thead>  <tbody>    <tr><td><code>"enterEntity"</code></td><td>{@link Script~entityEventCallback|entityEventCallback}</td>      <td>{@link Entities.enterEntity}</td></tr>    <tr><td><code>"leaveEntity"</code></td><td>{@link Script~entityEventCallback|entityEventCallback}</td>      <td>{@link Entities.leaveEntity}</td></tr>    <tr><td><code>"mousePressOnEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.mousePressOnEntity}</td></tr>    <tr><td><code>"mouseMoveOnEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.mouseMoveOnEntity}</td></tr>    <tr><td><code>"mouseReleaseOnEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.mouseReleaseOnEntity}</td></tr>    <tr><td><code>"clickDownOnEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.clickDownOnEntity}</td></tr>    <tr><td><code>"holdingClickOnEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.holdingClickOnEntity}</td></tr>    <tr><td><code>"clickReleaseOnEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.clickReleaseOnEntity}</td></tr>    <tr><td><code>"hoverEnterEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.hoverEnterEntity}</td></tr>    <tr><td><code>"hoverOverEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.hoverOverEntity}</td></tr>    <tr><td><code>"hoverLeaveEntity"</code></td><td>{@link Script~pointerEventCallback|pointerEventCallback}</td>      <td>{@link Entities.hoverLeaveEntity}</td></tr>    <tr><td><code>"collisionWithEntity"</code><td>{@link Script~collisionEventCallback|collisionEventCallback}</td>      </td><td>{@link Entities.collisionWithEntity}</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.EntityEvent');
    }
};
javascript.javascriptGenerator.forBlock['Script_EntityEvent'] = (block, generator) => {

    return [`new Script.EntityEvent()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_RayToEntityIntersectionResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.RayToEntityIntersectionResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('intersects') 
            .setCheck('Boolean')
            .appendField('intersects');
        this.appendValueInput('accurate') 
            .setCheck('Boolean')
            .appendField('accurate');
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('distance') 
            .setCheck('Number')
            .appendField('distance');
        this.appendValueInput('intersection') 
            .setCheck('Vec3')
            .appendField('intersection');
        this.appendValueInput('surfaceNormal') 
            .setCheck('Vec3')
            .appendField('surfaceNormal');
        this.appendValueInput('face') 
            .setCheck('BoxFace')
            .appendField('face');
        this.appendValueInput('extraInfo') 
            .setCheck('object')
            .appendField('extraInfo');
        this.setColour('#EA9958');
        this.setTooltip('The result of a {@link Entities.findRayIntersection|findRayIntersection} search using a {@link PickRay}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.RayToEntityIntersectionResult');
    }
};
javascript.javascriptGenerator.forBlock['Entities_RayToEntityIntersectionResult'] = (block, generator) => {
    const _intersects = dfv(generator.valueToCode(block, 'intersects', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _accurate = dfv(generator.valueToCode(block, 'accurate', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _distance = dfv(generator.valueToCode(block, 'distance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _intersection = dfv(generator.valueToCode(block, 'intersection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _surfaceNormal = dfv(generator.valueToCode(block, 'surfaceNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _face = dfv(generator.valueToCode(block, 'face', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extraInfo = dfv(generator.valueToCode(block, 'extraInfo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.RayToEntityIntersectionResult(${_intersects},${_accurate},${_entityID},${_distance},${_intersection},${_surfaceNormal},${_face},${_extraInfo})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Entities_keyboardFocusEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.keyboardFocusEntity')       
        this.setOutput(true, '');
        this.setColour('#EA9958');
        this.setTooltip('The {@link Entities.EntityProperties-Web|Web} entity that has keyboard focus. If no     Web entity has keyboard focus, returns <code>null</code>; set to <code>null</code> or {@link Uuid|Uuid.NULL} to clear     keyboard focus.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.keyboardFocusEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_keyboardFocusEntity'] = (block, generator) => {
    return [`Entities.keyboardFocusEntity`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Entities_getMultipleEntityProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getMultipleEntityProperties')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('entityIDs') 
            .setCheck('Array')
            .appendField('entityIDs');
        this.appendValueInput('desiredProperties') 
            .setCheck('Array')
            .appendField('desiredProperties');

        this.setColour('#EA9958');
        this.setTooltip('Gets the properties of multiple entities.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getMultipleEntityProperties');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getMultipleEntityProperties'] = (block, generator) => {
    const _entityIDs = dfv(generator.valueToCode(block, 'entityIDs', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _desiredProperties = dfv(generator.valueToCode(block, 'desiredProperties', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);

return [`Entities.getMultipleEntityProperties(${_entityIDs},${_desiredProperties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canAdjustLocks'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canAdjustLocks')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can change the <code>locked</code> property of entities. Locked entities have their<code>locked</code> property set to <code>true</code> and cannot be edited or deleted.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canAdjustLocks');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canAdjustLocks'] = (block, generator) => {

return [`Entities.canAdjustLocks()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canRez'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canRez')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can rez (create) new entities in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canRez');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canRez'] = (block, generator) => {

return [`Entities.canRez()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canRezTmp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canRezTmp')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can rez (create) new temporary entities in the domain. Temporary entities are entities with a finite <code>lifetime</code> property value set.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canRezTmp');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canRezTmp'] = (block, generator) => {

return [`Entities.canRezTmp()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canWriteAssets'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canWriteAssets')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can make changes to the asset server\'s assets.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canWriteAssets');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canWriteAssets'] = (block, generator) => {

return [`Entities.canWriteAssets()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canReplaceContent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canReplaceContent')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can replace the domain\'s content set.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canReplaceContent');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canReplaceContent'] = (block, generator) => {

return [`Entities.canReplaceContent()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canGetAndSetPrivateUserData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canGetAndSetPrivateUserData')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can get and set the <code>privateUserData</code> property of entities.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canGetAndSetPrivateUserData');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canGetAndSetPrivateUserData'] = (block, generator) => {

return [`Entities.canGetAndSetPrivateUserData()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canRezAvatarEntities'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canRezAvatarEntities')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can rez avatar entities.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canRezAvatarEntities');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canRezAvatarEntities'] = (block, generator) => {

return [`Entities.canRezAvatarEntities()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_canViewAssetURLs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.canViewAssetURLs')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether or not the script can view asset URLs');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canViewAssetURLs');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canViewAssetURLs'] = (block, generator) => {

return [`Entities.canViewAssetURLs()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Entities_EntityHostType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityHostType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>How an entity is hosted and sent to others for display.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"domain"</code></td><td>Domain entities are stored on the domain, are visible to everyone, and are       sent to everyone by the entity server.</td></tr>    <tr><td><code>"avatar"</code></td><td>Avatar entities are stored on an Interface client, are visible to everyone,       and are sent to everyone by the avatar mixer. They follow the client to each domain visited, displaying at the       same domain coordinates unless parented to the client\'s avatar.</td></tr>    <tr><td><code>"local"</code></td><td>Local entities are ephemeral &mdash; they aren\'t stored anywhere &mdash; and       are visible only to the client. They follow the client to each domain visited, displaying at the same domain       coordinates unless parented to the client\'s avatar. Additionally, local entities are always       collisionless.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityHostType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityHostType'] = (block, generator) => {

    return [`new Entities.EntityHostType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Entities_addEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.addEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('properties') 
            .setCheck('Entities.EntityProperties')
            .appendField('properties');
        this.appendValueInput('entityHostType') 
            .setCheck('Entities.EntityHostType')
            .appendField('entityHostType');

        this.setColour('#EA9958');
        this.setTooltip('Adds a new domain, avatar, or local entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.addEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_addEntity'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entityHostType = dfv(generator.valueToCode(block, 'entityHostType', javascript.javascriptGenerator.ORDER_ATOMIC), `"domain"`);

return [`Entities.addEntity(${_properties},${_entityHostType})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_addEntitypropertiesavatarEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.addEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('properties') 
            .setCheck('Entities.EntityProperties')
            .appendField('properties');
        this.appendValueInput('avatarEntity') 
            .setCheck('Boolean')
            .appendField('avatarEntity');

        this.setColour('#EA9958');
        this.setTooltip('Adds a new avatar entity (<code>{@link Entities.EntityProperties|entityHostType}</code> property is <code>"avatar"</code>) or domain entity (<code>{@link Entities.EntityProperties|entityHostType}</code> property is <code>"domain"</code>).');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.addEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_addEntitypropertiesavatarEntity'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _avatarEntity = dfv(generator.valueToCode(block, 'avatarEntity', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.addEntity(${_properties},${_avatarEntity})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_cloneEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.cloneEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Creates a clone of an entity. The clone has the same properties as the original except that: it has a modified<code>name</code> property, clone-related properties are set per the original entity\'s clone-related{@link Entities.EntityProperties|properties} (e.g., <code>cloneLifetime</code>), and its clone-related properties are set to their defaults.<p>Domain entities must have their <code>cloneable</code> property value be <code>true</code> in order to be cloned. A domain entity can be cloned by a client that doesn\'t have rez permissions in the domain.</p><p>Avatar entities must have their <code>cloneable</code> and <code>cloneAvatarEntity</code> property values be <code>true</code> in order to be cloned.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.cloneEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_cloneEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.cloneEntity(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getEntityProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getEntityProperties')
        // Returns data
        this.setOutput(true, '["Entities.EntityProperties"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('desiredProperties') 
            .setCheck('String')
            .appendField('desiredProperties');

        this.setColour('#EA9958');
        this.setTooltip('Gets an entity\'s property values.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getEntityProperties');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getEntityProperties'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _desiredProperties = dfv(generator.valueToCode(block, 'desiredProperties', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);

return [`Entities.getEntityProperties(${_entityID},${_desiredProperties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_editEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.editEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('properties') 
            .setCheck('Entities.EntityProperties')
            .appendField('properties');

        this.setColour('#EA9958');
        this.setTooltip('Edits an entity, changing one or more of its property values.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.editEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_editEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.editEntity(${_entityID},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_deleteEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.deleteEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Deletes an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.deleteEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_deleteEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.deleteEntity(${_entityID});\n`;};


// Blockly function
Blockly.Blocks['Entities_getEntityType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getEntityType')
        // Returns data
        this.setOutput(true, '["Entities.EntityType"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#EA9958');
        this.setTooltip('Gets an entity\'s type.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getEntityType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getEntityType'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getEntityType(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getEntityObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getEntityObject')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#EA9958');
        this.setTooltip('Gets an entity\'s script object. In particular, this is useful for accessing a {@link Entities.EntityProperties-Web|Web} entity\'s HTML <code>EventBridge</code> script object to exchange messages with the web page script.<p>To send a message from an Interface script to a Web entity over its event bridge:</p><pre class="prettyprint"><code>var entityObject = Entities.getEntityObject(entityID);entityObject.emitScriptEvent(message);</code></pre><p>To receive a message from a Web entity over its event bridge in an Interface script:</p><pre class="prettyprint"><code>var entityObject = Entities.getentityObject(entityID);entityObject.webEventReceived.connect(function(message) {    ...};</code></pre><p>Alternatively, you can use {@link Entities.emitScriptEvent} and {@link Entities.webEventReceived} to exchangemessages with a Web entity over its event bridge.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getEntityObject');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getEntityObject'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getEntityObject(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_isLoaded'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.isLoaded')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#EA9958');
        this.setTooltip('Checks whether an entity\'s assets have been loaded. For example, for an <code>Model</code> entity the result indicateswhether its textures have been loaded.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.isLoaded');
    }
};
javascript.javascriptGenerator.forBlock['Entities_isLoaded'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.isLoaded(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_isAddedEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.isAddedEntity')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#EA9958');
        this.setTooltip('Checks if there is an entity with a specified ID.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.isAddedEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_isAddedEntity'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.isAddedEntity(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_textSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.textSize')
        // Returns data
        this.setOutput(true, '["Size"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');

        this.setColour('#EA9958');
        this.setTooltip('Calculates the size of some text in a {@link Entities.EntityProperties-Text|Text} entity. The entity need not be set visible.<p><strong>Note:</strong> The size of text in a Text entity cannot be calculated immediately after theentity is created; a short delay is required while the entity finishes being created.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.textSize');
    }
};
javascript.javascriptGenerator.forBlock['Entities_textSize'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.textSize(${_id},${_text})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_callEntityMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.callEntityMethod')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('method') 
            .setCheck('String')
            .appendField('method');
        this.appendValueInput('parameters') 
            .setCheck('Array')
            .appendField('parameters');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Calls a method in a client entity script from an Interface, avatar, or client entity script, or calls a method in a server entity script from a server entity script. The entity script method must be exposed as a property in the target entity script. Additionally, if calling a server entity script, the server entity script must include the method\'s name in an exposed property called <code>remotelyCallable</code> that is an array of method names that can be called.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.callEntityMethod');
    }
};
javascript.javascriptGenerator.forBlock['Entities_callEntityMethod'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _method = dfv(generator.valueToCode(block, 'method', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parameters = dfv(generator.valueToCode(block, 'parameters', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);


    return `Entities.callEntityMethod(${_entityID},${_method},${_parameters});\n`;};


// Blockly function
Blockly.Blocks['Entities_callEntityServerMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.callEntityServerMethod')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('method') 
            .setCheck('String')
            .appendField('method');
        this.appendValueInput('parameters') 
            .setCheck('Array')
            .appendField('parameters');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Calls a method in a server entity script from an Interface, avatar, or client entity script. The server entity script method must be exposed as a property in the target server entity script. Additionally, the server entity script must include the method\'s name in an exposed property called <code>remotelyCallable</code> that is an array of method names that can be called.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.callEntityServerMethod');
    }
};
javascript.javascriptGenerator.forBlock['Entities_callEntityServerMethod'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _method = dfv(generator.valueToCode(block, 'method', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parameters = dfv(generator.valueToCode(block, 'parameters', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);


    return `Entities.callEntityServerMethod(${_entityID},${_method},${_parameters});\n`;};


// Blockly function
Blockly.Blocks['Entities_callEntityClientMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.callEntityClientMethod')
        // Returns data

        // Params data
        this.appendValueInput('clientSessionID') 
            .setCheck('Uuid')
            .appendField('clientSessionID');
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('method') 
            .setCheck('String')
            .appendField('method');
        this.appendValueInput('parameters') 
            .setCheck('Array')
            .appendField('parameters');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Calls a method in a specific user\'s client entity script from a server entity script. The entity script method must beexposed as a property in the target client entity script. Additionally, the client entity script must include the method\'s name in an exposed property called <code>remotelyCallable</code> that is an array of method names that can be called.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.callEntityClientMethod');
    }
};
javascript.javascriptGenerator.forBlock['Entities_callEntityClientMethod'] = (block, generator) => {
    const _clientSessionID = dfv(generator.valueToCode(block, 'clientSessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _method = dfv(generator.valueToCode(block, 'method', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parameters = dfv(generator.valueToCode(block, 'parameters', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);


    return `Entities.callEntityClientMethod(${_clientSessionID},${_entityID},${_method},${_parameters});\n`;};


// Blockly function
Blockly.Blocks['Entities_findClosestEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findClosestEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');

        this.setColour('#EA9958');
        this.setTooltip('Finds the domain or avatar entity with a position closest to a specified point and within a specified radius.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findClosestEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findClosestEntity'] = (block, generator) => {
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.findClosestEntity(${_center},${_radius})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_findEntities'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findEntities')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');

        this.setColour('#EA9958');
        this.setTooltip('Finds all domain and avatar entities that intersect a sphere.<p><strong>Note:</strong> Server entity scripts only find entities that have a server entity scriptrunning in them or a parent entity. You can apply a dummy script to entities that you want found in a search.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findEntities');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findEntities'] = (block, generator) => {
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.findEntities(${_center},${_radius})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_findEntitiesInBox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findEntitiesInBox')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('corner') 
            .setCheck('Vec3')
            .appendField('corner');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');

        this.setColour('#EA9958');
        this.setTooltip('Finds all domain and avatar entities whose axis-aligned boxes intersect a search axis-aligned box.<p><strong>Note:</strong> Server entity scripts only find entities that have a server entity scriptrunning in them or a parent entity. You can apply a dummy script to entities that you want found in a search.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findEntitiesInBox');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findEntitiesInBox'] = (block, generator) => {
    const _corner = dfv(generator.valueToCode(block, 'corner', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.findEntitiesInBox(${_corner},${_dimensions})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_findEntitiesInFrustum'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findEntitiesInFrustum')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('frustum') 
            .setCheck('ViewFrustum')
            .appendField('frustum');

        this.setColour('#EA9958');
        this.setTooltip('Finds all domain and avatar entities whose axis-aligned boxes intersect a search frustum.<p><strong>Note:</strong> Server entity scripts only find entities that have a server entity scriptrunning in them or a parent entity. You can apply a dummy script to entities that you want found in a search.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findEntitiesInFrustum');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findEntitiesInFrustum'] = (block, generator) => {
    const _frustum = dfv(generator.valueToCode(block, 'frustum', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.findEntitiesInFrustum(${_frustum})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_findEntitiesByType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findEntitiesByType')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('entityType') 
            .setCheck('Entities.EntityType')
            .appendField('entityType');
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');

        this.setColour('#EA9958');
        this.setTooltip('Finds all domain and avatar entities of a particular type that intersect a sphere.<p><strong>Note:</strong> Server entity scripts only find entities that have a server entity scriptrunning in them or a parent entity. You can apply a dummy script to entities that you want found in a search.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findEntitiesByType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findEntitiesByType'] = (block, generator) => {
    const _entityType = dfv(generator.valueToCode(block, 'entityType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.findEntitiesByType(${_entityType},${_center},${_radius})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_findEntitiesByName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findEntitiesByName')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('entityName') 
            .setCheck('String')
            .appendField('entityName');
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('caseSensitive') 
            .setCheck('Boolean')
            .appendField('caseSensitive');

        this.setColour('#EA9958');
        this.setTooltip('Finds all domain and avatar entities with a particular name that intersect a sphere.<p><strong>Note:</strong> Server entity scripts only find entities that have a server entity scriptrunning in them or a parent entity. You can apply a dummy script to entities that you want found in a search.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findEntitiesByName');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findEntitiesByName'] = (block, generator) => {
    const _entityName = dfv(generator.valueToCode(block, 'entityName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _caseSensitive = dfv(generator.valueToCode(block, 'caseSensitive', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.findEntitiesByName(${_entityName},${_center},${_radius},${_caseSensitive})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_findRayIntersection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.findRayIntersection')
        // Returns data
        this.setOutput(true, '["Entities.RayToEntityIntersectionResult"]');

        // Params data
        this.appendValueInput('pickRay') 
            .setCheck('PickRay')
            .appendField('pickRay');
        this.appendValueInput('precisionPicking') 
            .setCheck('Boolean')
            .appendField('precisionPicking');
        this.appendValueInput('entitiesToInclude') 
            .setCheck('Array')
            .appendField('entitiesToInclude');
        this.appendValueInput('entitiesToDiscard') 
            .setCheck('Array')
            .appendField('entitiesToDiscard');
        this.appendValueInput('visibleOnly') 
            .setCheck('Boolean')
            .appendField('visibleOnly');
        this.appendValueInput('collideableOnly') 
            .setCheck('Boolean')
            .appendField('collideableOnly');

        this.setColour('#EA9958');
        this.setTooltip('Finds the first avatar or domain entity intersected by a {@link PickRay}. <code>Light</code> and <code>Zone</code> entities are not intersected unless they\'ve been configured as pickable using {@link Entities.setLightsArePickable|setLightsArePickable} and {@link Entities.setZonesArePickable|setZonesArePickable}, respectively.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.findRayIntersection');
    }
};
javascript.javascriptGenerator.forBlock['Entities_findRayIntersection'] = (block, generator) => {
    const _pickRay = dfv(generator.valueToCode(block, 'pickRay', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _precisionPicking = dfv(generator.valueToCode(block, 'precisionPicking', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _entitiesToInclude = dfv(generator.valueToCode(block, 'entitiesToInclude', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _entitiesToDiscard = dfv(generator.valueToCode(block, 'entitiesToDiscard', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _visibleOnly = dfv(generator.valueToCode(block, 'visibleOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _collideableOnly = dfv(generator.valueToCode(block, 'collideableOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.findRayIntersection(${_pickRay},${_precisionPicking},${_entitiesToInclude},${_entitiesToDiscard},${_visibleOnly},${_collideableOnly})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_reloadServerScripts'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.reloadServerScripts')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Reloads an entity\'s server entity script such that the latest version re-downloaded.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.reloadServerScripts');
    }
};
javascript.javascriptGenerator.forBlock['Entities_reloadServerScripts'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.reloadServerScripts(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getServerScriptStatus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getServerScriptStatus')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('callback') 
            .setCheck('Entities~getServerScriptStatusCallback')
            .appendField('callback');

        this.setColour('#EA9958');
        this.setTooltip('Gets the status of a server entity script attached to an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getServerScriptStatus');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getServerScriptStatus'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getServerScriptStatus(${_entityID},${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Entities~getServerScriptStatusCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities~getServerScriptStatusCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('Called when a {@link Entities.getServerScriptStatus} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Entities~getServerScriptStatusCallback');
    }
};
javascript.javascriptGenerator.forBlock['Entities~getServerScriptStatusCallback'] = (block, generator) => {

    return [`new Entities~getServerScriptStatusCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Entities_queryPropertyMetadata'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.queryPropertyMetadata')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('property') 
            .setCheck('String')
            .appendField('property');
        this.appendValueInput('callback') 
            .setCheck('Entities~queryPropertyMetadataCallback')
            .appendField('callback');

        this.setColour('#EA9958');
        this.setTooltip('Gets metadata for certain entity properties such as <code>script</code> and <code>serverScripts</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.queryPropertyMetadata');
    }
};
javascript.javascriptGenerator.forBlock['Entities_queryPropertyMetadata'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _property = dfv(generator.valueToCode(block, 'property', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.queryPropertyMetadata(${_entityID},${_property},${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_queryPropertyMetadataentityIDpropertyscopecallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.queryPropertyMetadata')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('property') 
            .setCheck('String')
            .appendField('property');
        this.appendValueInput('scope') 
            .setCheck('object')
            .appendField('scope');
        this.appendValueInput('callback') 
            .setCheck('Entities~queryPropertyMetadataCallback')
            .appendField('callback');

        this.setColour('#EA9958');
        this.setTooltip('Gets metadata for certain entity properties such as <code>script</code> and <code>serverScripts</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.queryPropertyMetadata');
    }
};
javascript.javascriptGenerator.forBlock['Entities_queryPropertyMetadataentityIDpropertyscopecallback'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _property = dfv(generator.valueToCode(block, 'property', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scope = dfv(generator.valueToCode(block, 'scope', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.queryPropertyMetadata(${_entityID},${_property},${_scope},${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Entities~queryPropertyMetadataCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities~queryPropertyMetadataCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('Called when a {@link Entities.queryPropertyMetadata} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Entities~queryPropertyMetadataCallback');
    }
};
javascript.javascriptGenerator.forBlock['Entities~queryPropertyMetadataCallback'] = (block, generator) => {

    return [`new Entities~queryPropertyMetadataCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Entities_setLightsArePickable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setLightsArePickable')
        // Returns data

        // Params data
        this.appendValueInput('value') 
            .setCheck('Boolean')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets whether or not ray picks intersect the bounding box of {@link Entities.EntityProperties-Light|Light} entities. By default, Light entities are not intersected. The setting lasts for the Interface session. Ray picks are performed using {@link Entities.findRayIntersection|findRayIntersection}, or the {@link Picks} API.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setLightsArePickable');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setLightsArePickable'] = (block, generator) => {
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Entities.setLightsArePickable(${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_getLightsArePickable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLightsArePickable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets whether or not ray picks intersect the bounding box of {@link Entities.EntityProperties-Light|Light} entities. Ray picks are performed using {@link Entities.findRayIntersection|findRayIntersection}, or the {@link Picks} API.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLightsArePickable');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLightsArePickable'] = (block, generator) => {

return [`Entities.getLightsArePickable()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setZonesArePickable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setZonesArePickable')
        // Returns data

        // Params data
        this.appendValueInput('value') 
            .setCheck('Boolean')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets whether or not ray picks intersect the bounding box of {@link Entities.EntityProperties-Zone|Zone} entities. By default, Zone entities are not intersected. The setting lasts for the Interface session. Ray picks are performed using {@link Entities.findRayIntersection|findRayIntersection}, or the {@link Picks} API.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setZonesArePickable');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setZonesArePickable'] = (block, generator) => {
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Entities.setZonesArePickable(${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_getZonesArePickable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getZonesArePickable')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets whether or not ray picks intersect the bounding box of {@link Entities.EntityProperties-Zone|Zone} entities. Ray picks are performed using {@link Entities.findRayIntersection|findRayIntersection}, or the {@link Picks} API.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getZonesArePickable');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getZonesArePickable'] = (block, generator) => {

return [`Entities.getZonesArePickable()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setDrawZoneBoundaries'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setDrawZoneBoundaries')
        // Returns data

        // Params data
        this.appendValueInput('value') 
            .setCheck('Boolean')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets whether or not {@link Entities.EntityProperties-Zone|Zone} entities\' boundaries should be drawn. <em>Currently not used.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setDrawZoneBoundaries');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setDrawZoneBoundaries'] = (block, generator) => {
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Entities.setDrawZoneBoundaries(${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_getDrawZoneBoundaries'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getDrawZoneBoundaries')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets whether or not {@link Entities.EntityProperties-Zone|Zone} entities\' boundaries should be drawn. <em>Currently not used.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getDrawZoneBoundaries');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getDrawZoneBoundaries'] = (block, generator) => {

return [`Entities.getDrawZoneBoundaries()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setVoxelSphere'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setVoxelSphere')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the values of all voxels in a spherical portion of a {@link Entities.EntityProperties-PolyVox|PolyVox} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setVoxelSphere');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setVoxelSphere'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Entities.setVoxelSphere(${_entityID},${_center},${_radius},${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_setVoxelCapsule'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setVoxelCapsule')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('start') 
            .setCheck('Vec3')
            .appendField('start');
        this.appendValueInput('end') 
            .setCheck('Vec3')
            .appendField('end');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the values of all voxels in a capsule-shaped portion of a {@link Entities.EntityProperties-PolyVox|PolyVox} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setVoxelCapsule');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setVoxelCapsule'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _start = dfv(generator.valueToCode(block, 'start', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _end = dfv(generator.valueToCode(block, 'end', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Entities.setVoxelCapsule(${_entityID},${_start},${_end},${_radius},${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_setVoxel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setVoxel')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the value of a particular voxel in a {@link Entities.EntityProperties-PolyVox|PolyVox} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setVoxel');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setVoxel'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Entities.setVoxel(${_entityID},${_position},${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_setAllVoxels'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setAllVoxels')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the values of all voxels in a {@link Entities.EntityProperties-PolyVox|PolyVox} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setAllVoxels');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setAllVoxels'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Entities.setAllVoxels(${_entityID},${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_setVoxelsInCuboid'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setVoxelsInCuboid')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('lowPosition') 
            .setCheck('Vec3')
            .appendField('lowPosition');
        this.appendValueInput('cuboidSize') 
            .setCheck('Vec3')
            .appendField('cuboidSize');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the values of all voxels in a cubic portion of a {@link Entities.EntityProperties-PolyVox|PolyVox} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setVoxelsInCuboid');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setVoxelsInCuboid'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _lowPosition = dfv(generator.valueToCode(block, 'lowPosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _cuboidSize = dfv(generator.valueToCode(block, 'cuboidSize', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Entities.setVoxelsInCuboid(${_entityID},${_lowPosition},${_cuboidSize},${_value});\n`;};


// Blockly function
Blockly.Blocks['Entities_voxelCoordsToWorldCoords'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.voxelCoordsToWorldCoords')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('voxelCoords') 
            .setCheck('Vec3')
            .appendField('voxelCoords');

        this.setColour('#EA9958');
        this.setTooltip('Converts voxel coordinates in a {@link Entities.EntityProperties-PolyVox|PolyVox} entity to world coordinates. Voxel coordinates are relative to the minimum axes values corner of the entity with a scale of <code>Vec3.ONE</code> being the dimensions of each voxel.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.voxelCoordsToWorldCoords');
    }
};
javascript.javascriptGenerator.forBlock['Entities_voxelCoordsToWorldCoords'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _voxelCoords = dfv(generator.valueToCode(block, 'voxelCoords', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.voxelCoordsToWorldCoords(${_entityID},${_voxelCoords})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_worldCoordsToVoxelCoords'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.worldCoordsToVoxelCoords')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('worldCoords') 
            .setCheck('Vec3')
            .appendField('worldCoords');

        this.setColour('#EA9958');
        this.setTooltip('Converts world coordinates to voxel coordinates in a {@link Entities.EntityProperties-PolyVox|PolyVox} entity. Voxel coordinates are relative to the minimum axes values corner of the entity, with a scale of <code>Vec3.ONE</code> being the dimensions of each voxel.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.worldCoordsToVoxelCoords');
    }
};
javascript.javascriptGenerator.forBlock['Entities_worldCoordsToVoxelCoords'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _worldCoords = dfv(generator.valueToCode(block, 'worldCoords', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.worldCoordsToVoxelCoords(${_entityID},${_worldCoords})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_voxelCoordsToLocalCoords'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.voxelCoordsToLocalCoords')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('voxelCoords') 
            .setCheck('Vec3')
            .appendField('voxelCoords');

        this.setColour('#EA9958');
        this.setTooltip('Converts voxel coordinates in a {@link Entities.EntityProperties-PolyVox|PolyVox} entity to local coordinates. Local coordinates are relative to the minimum axes value corner of the entity, with the scale being the same as world coordinates. Voxel coordinates are relative to the minimum axes values corner of the entity, with a scale of <code>Vec3.ONE</code> being the dimensions of each voxel.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.voxelCoordsToLocalCoords');
    }
};
javascript.javascriptGenerator.forBlock['Entities_voxelCoordsToLocalCoords'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _voxelCoords = dfv(generator.valueToCode(block, 'voxelCoords', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.voxelCoordsToLocalCoords(${_entityID},${_voxelCoords})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_localCoordsToVoxelCoords'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.localCoordsToVoxelCoords')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('localCoords') 
            .setCheck('Vec3')
            .appendField('localCoords');

        this.setColour('#EA9958');
        this.setTooltip('Converts local coordinates to voxel coordinates in a {@link Entities.EntityProperties-PolyVox|PolyVox} entity. Local coordinates are relative to the minimum axes value corner of the entity, with the scale being the same as world coordinates. Voxel coordinates are relative to the minimum axes values corner of the entity, with a scale of <code>Vec3.ONE</code> being the dimensions of each voxel.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.localCoordsToVoxelCoords');
    }
};
javascript.javascriptGenerator.forBlock['Entities_localCoordsToVoxelCoords'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _localCoords = dfv(generator.valueToCode(block, 'localCoords', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.localCoordsToVoxelCoords(${_entityID},${_localCoords})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_dumpTree'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.dumpTree')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Dumps debug information about all entities in Interface\'s local in-memory tree of entities it knows about to the program log.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.dumpTree');
    }
};
javascript.javascriptGenerator.forBlock['Entities_dumpTree'] = (block, generator) => {


    return `Entities.dumpTree();\n`;};


// Blockly function
Blockly.Blocks['Entities_addAction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.addAction')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('actionType') 
            .setCheck('Entities.ActionType')
            .appendField('actionType');
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('arguments') 
            .setCheck('Entities.ActionArguments')
            .appendField('arguments');

        this.setColour('#EA9958');
        this.setTooltip('Adds an action to an entity. An action is registered with the physics engine and is applied every physics simulationstep. Any entity may have more than one action associated with it, but only as many as will fit in an entity\'s <code>{@link Entities.EntityProperties|actionData}</code> property.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.addAction');
    }
};
javascript.javascriptGenerator.forBlock['Entities_addAction'] = (block, generator) => {
    const _actionType = dfv(generator.valueToCode(block, 'actionType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _arguments = dfv(generator.valueToCode(block, 'arguments', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.addAction(${_actionType},${_entityID},${_arguments})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_updateAction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.updateAction')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('actionID') 
            .setCheck('Uuid')
            .appendField('actionID');
        this.appendValueInput('arguments') 
            .setCheck('Entities.ActionArguments')
            .appendField('arguments');

        this.setColour('#EA9958');
        this.setTooltip('Updates an entity action.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.updateAction');
    }
};
javascript.javascriptGenerator.forBlock['Entities_updateAction'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _actionID = dfv(generator.valueToCode(block, 'actionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _arguments = dfv(generator.valueToCode(block, 'arguments', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.updateAction(${_entityID},${_actionID},${_arguments})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_deleteAction'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.deleteAction')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('actionID') 
            .setCheck('Uuid')
            .appendField('actionID');

        this.setColour('#EA9958');
        this.setTooltip('Deletes an action from an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.deleteAction');
    }
};
javascript.javascriptGenerator.forBlock['Entities_deleteAction'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _actionID = dfv(generator.valueToCode(block, 'actionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.deleteAction(${_entityID},${_actionID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getActionIDs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getActionIDs')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Gets the IDs of the actions that are associated with an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getActionIDs');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getActionIDs'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getActionIDs(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getActionArguments'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getActionArguments')
        // Returns data
        this.setOutput(true, '["Entities.ActionArguments"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('actionID') 
            .setCheck('Uuid')
            .appendField('actionID');

        this.setColour('#EA9958');
        this.setTooltip('Gets the arguments of an action.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getActionArguments');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getActionArguments'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _actionID = dfv(generator.valueToCode(block, 'actionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getActionArguments(${_entityID},${_actionID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#EA9958');
        this.setTooltip('Gets the translation of a joint in a {@link Entities.EntityProperties-Model|Model} entity relative to the entity\'s position and orientation.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.getAbsoluteJointTranslationInObjectFrame(${_entityID},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getJointParent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getJointParent')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#EA9958');
        this.setTooltip('Gets the index of the parent joint of a joint in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getJointParent');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getJointParent'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.getJointParent(${_entityID},${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#EA9958');
        this.setTooltip('Gets the rotation of a joint in a {@link Entities.EntityProperties-Model|Model} entity relative to the entity\'s position and orientation.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.getAbsoluteJointRotationInObjectFrame(${_entityID},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setAbsoluteJointTranslationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setAbsoluteJointTranslationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setColour('#EA9958');
        this.setTooltip('Sets the translation of a joint in a {@link Entities.EntityProperties-Model|Model} entity relative to the entity\'s position and orientation.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setAbsoluteJointTranslationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setAbsoluteJointTranslationInObjectFrame'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setAbsoluteJointTranslationInObjectFrame(${_entityID},${_jointIndex},${_translation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setAbsoluteJointRotationInObjectFrame'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setAbsoluteJointRotationInObjectFrame')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setColour('#EA9958');
        this.setTooltip('Sets the rotation of a joint in a {@link Entities.EntityProperties-Model|Model} entity relative to the entity\'s position and orientation.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setAbsoluteJointRotationInObjectFrame');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setAbsoluteJointRotationInObjectFrame'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setAbsoluteJointRotationInObjectFrame(${_entityID},${_jointIndex},${_rotation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLocalJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLocalJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#EA9958');
        this.setTooltip('Gets the local translation of a joint in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLocalJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLocalJointTranslation'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.getLocalJointTranslation(${_entityID},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLocalJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLocalJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#EA9958');
        this.setTooltip('Gets the local rotation of a joint in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLocalJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLocalJointRotation'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.getLocalJointRotation(${_entityID},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setLocalJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setLocalJointTranslation')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setColour('#EA9958');
        this.setTooltip('Sets the local translation of a joint in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setLocalJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setLocalJointTranslation'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setLocalJointTranslation(${_entityID},${_jointIndex},${_translation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setLocalJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setLocalJointRotation')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setColour('#EA9958');
        this.setTooltip('Sets the local rotation of a joint in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setLocalJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setLocalJointRotation'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setLocalJointRotation(${_entityID},${_jointIndex},${_rotation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setLocalJointTranslations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setLocalJointTranslations')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('translations') 
            .setCheck('Array')
            .appendField('translations');

        this.setColour('#EA9958');
        this.setTooltip('Sets the local translations of joints in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setLocalJointTranslations');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setLocalJointTranslations'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translations = dfv(generator.valueToCode(block, 'translations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setLocalJointTranslations(${_entityID},${_translations})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setLocalJointRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setLocalJointRotations')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('rotations') 
            .setCheck('Array')
            .appendField('rotations');

        this.setColour('#EA9958');
        this.setTooltip('Sets the local rotations of joints in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setLocalJointRotations');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setLocalJointRotations'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotations = dfv(generator.valueToCode(block, 'rotations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setLocalJointRotations(${_entityID},${_rotations})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setLocalJointsData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setLocalJointsData')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('rotations') 
            .setCheck('Array')
            .appendField('rotations');
        this.appendValueInput('translations') 
            .setCheck('Array')
            .appendField('translations');

        this.setColour('#EA9958');
        this.setTooltip('Sets the local rotations and translations of joints in a {@link Entities.EntityProperties-Model|Model} entity. This is the same as calling both {@link Entities.setLocalJointRotations|setLocalJointRotations} and {@link Entities.setLocalJointTranslations|setLocalJointTranslations} at the same time.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setLocalJointsData');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setLocalJointsData'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotations = dfv(generator.valueToCode(block, 'rotations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translations = dfv(generator.valueToCode(block, 'translations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.setLocalJointsData(${_entityID},${_rotations},${_translations})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getJointIndex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#EA9958');
        this.setTooltip('Gets the index of a named joint in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getJointIndex'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getJointIndex(${_entityID},${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getJointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getJointNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Gets the names of all the joints in a {@link Entities.EntityProperties-Model|Model} entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getJointNames');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getJointNames'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getJointNames(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getChildrenIDs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getChildrenIDs')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');

        this.setColour('#EA9958');
        this.setTooltip('Gets the IDs of entities and avatars that are directly parented to an entity or avatar model. To get all descendants, you can recurse on the IDs returned.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getChildrenIDs');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getChildrenIDs'] = (block, generator) => {
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getChildrenIDs(${_parentID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getChildrenIDsOfJoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getChildrenIDsOfJoint')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('jointIndex') 
            .setCheck('Number')
            .appendField('jointIndex');

        this.setColour('#EA9958');
        this.setTooltip('Gets the IDs of entities and avatars that are directly parented to an entity or avatar model\'s joint. To get all descendants, you can use {@link Entities.getChildrenIDs|getChildrenIDs} to recurse on the IDs returned.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getChildrenIDsOfJoint');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getChildrenIDsOfJoint'] = (block, generator) => {
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _jointIndex = dfv(generator.valueToCode(block, 'jointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.getChildrenIDsOfJoint(${_parentID},${_jointIndex})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_isChildOfParent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.isChildOfParent')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('childID') 
            .setCheck('Uuid')
            .appendField('childID');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');

        this.setColour('#EA9958');
        this.setTooltip('Checks whether an entity has an entity as an ancestor (parent, parent\'s parent, etc.).');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.isChildOfParent');
    }
};
javascript.javascriptGenerator.forBlock['Entities_isChildOfParent'] = (block, generator) => {
    const _childID = dfv(generator.valueToCode(block, 'childID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.isChildOfParent(${_childID},${_parentID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getNestableType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getNestableType')
        // Returns data
        this.setOutput(true, '["Entities.NestableType"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#EA9958');
        this.setTooltip('Gets the type &mdash; entity or avatar &mdash; of an in-world item.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getNestableType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getNestableType'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getNestableType(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getKeyboardFocusEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getKeyboardFocusEntity')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the ID of the {@link Entities.EntityProperties-Web|Web} entity that has keyboard focus.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getKeyboardFocusEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getKeyboardFocusEntity'] = (block, generator) => {

return [`Entities.getKeyboardFocusEntity()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_setKeyboardFocusEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setKeyboardFocusEntity')
        // Returns data

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the {@link Entities.EntityProperties-Web|Web} entity that has keyboard focus.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setKeyboardFocusEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setKeyboardFocusEntity'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.setKeyboardFocusEntity(${_id});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendMousePressOnEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendMousePressOnEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.mousePressOnEntity|mousePressOnEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendMousePressOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendMousePressOnEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendMousePressOnEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendMouseMoveOnEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendMouseMoveOnEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.mouseMoveOnEntity|mouseMoveOnEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendMouseMoveOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendMouseMoveOnEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendMouseMoveOnEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendMouseReleaseOnEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendMouseReleaseOnEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.mouseReleaseOnEntity|mouseReleaseOnEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendMouseReleaseOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendMouseReleaseOnEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendMouseReleaseOnEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendClickDownOnEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendClickDownOnEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.clickDownOnEntity|clickDownOnEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendClickDownOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendClickDownOnEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendClickDownOnEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendHoldingClickOnEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendHoldingClickOnEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.holdingClickOnEntity|holdingClickOnEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendHoldingClickOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendHoldingClickOnEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendHoldingClickOnEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendClickReleaseOnEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendClickReleaseOnEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.clickReleaseOnEntity|clickReleaseOnEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendClickReleaseOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendClickReleaseOnEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendClickReleaseOnEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendHoverEnterEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendHoverEnterEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.hoverEnterEntity|hoverEnterEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendHoverEnterEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendHoverEnterEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendHoverEnterEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendHoverOverEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendHoverOverEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.hoverOverEntity|hoverOverEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendHoverOverEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendHoverOverEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendHoverOverEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_sendHoverLeaveEntity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.sendHoverLeaveEntity')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('event') 
            .setCheck('PointerEvent')
            .appendField('event');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Emits a {@link Entities.hoverLeaveEntity|hoverLeaveEntity} event.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.sendHoverLeaveEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_sendHoverLeaveEntity'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _event = dfv(generator.valueToCode(block, 'event', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.sendHoverLeaveEntity(${_entityID},${_event});\n`;};


// Blockly function
Blockly.Blocks['Entities_wantsHandControllerPointerEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.wantsHandControllerPointerEvents')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Checks whether an entity wants hand controller pointer events. For example, a {@link Entities.EntityProperties-Web|Web} entity does but a {@link Entities.EntityProperties-Shape|Shape} entity doesn\'t.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.wantsHandControllerPointerEvents');
    }
};
javascript.javascriptGenerator.forBlock['Entities_wantsHandControllerPointerEvents'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.wantsHandControllerPointerEvents(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_emitScriptEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.emitScriptEvent')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sends a message to a {@link Entities.EntityProperties-Web|Web} entity\'s HTML page. To receive the message, the web page\'s script must connect to the <code>EventBridge</code> that is automatically provided to the script:<pre class="prettyprint"><code>EventBridge.scriptEventReceived.connect(function(message) {    ...});</code></pre><p>Use {@link Entities.webEventReceived} to receive messages from the Web entity\'s HTML page.</p><p>Alternatively, you can use {@link Entities.getEntityObject} to exchange messages over a Web entity\'s HTML eventbridge.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.emitScriptEvent');
    }
};
javascript.javascriptGenerator.forBlock['Entities_emitScriptEvent'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Entities.emitScriptEvent(${_entityID},${_message});\n`;};


// Blockly function
Blockly.Blocks['Entities_AABoxIntersectsCapsule'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.AABoxIntersectsCapsule')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('brn') 
            .setCheck('Vec3')
            .appendField('brn');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.appendValueInput('start') 
            .setCheck('Vec3')
            .appendField('start');
        this.appendValueInput('end') 
            .setCheck('Vec3')
            .appendField('end');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');

        this.setColour('#EA9958');
        this.setTooltip('Checks whether an axis-aligned box and a capsule intersect.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.AABoxIntersectsCapsule');
    }
};
javascript.javascriptGenerator.forBlock['Entities_AABoxIntersectsCapsule'] = (block, generator) => {
    const _brn = dfv(generator.valueToCode(block, 'brn', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _start = dfv(generator.valueToCode(block, 'start', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _end = dfv(generator.valueToCode(block, 'end', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Entities.AABoxIntersectsCapsule(${_brn},${_dimensions},${_start},${_end},${_radius})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getEntityTransform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getEntityTransform')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Gets the object to world transform, excluding scale, of an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getEntityTransform');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getEntityTransform'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getEntityTransform(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getEntityLocalTransform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getEntityLocalTransform')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#EA9958');
        this.setTooltip('Gets the object to parent transform, excluding scale, of an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getEntityLocalTransform');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getEntityLocalTransform'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getEntityLocalTransform(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_worldToLocalPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.worldToLocalPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('worldPosition') 
            .setCheck('Vec3')
            .appendField('worldPosition');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a position in world coordinates to a position in an avatar, entity, or joint\'s local coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.worldToLocalPosition');
    }
};
javascript.javascriptGenerator.forBlock['Entities_worldToLocalPosition'] = (block, generator) => {
    const _worldPosition = dfv(generator.valueToCode(block, 'worldPosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.worldToLocalPosition(${_worldPosition},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_worldToLocalRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.worldToLocalRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('worldRotation') 
            .setCheck('Quat')
            .appendField('worldRotation');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a rotation or orientation in world coordinates to rotation in an avatar, entity, or joint\'s local coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.worldToLocalRotation');
    }
};
javascript.javascriptGenerator.forBlock['Entities_worldToLocalRotation'] = (block, generator) => {
    const _worldRotation = dfv(generator.valueToCode(block, 'worldRotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.worldToLocalRotation(${_worldRotation},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_worldToLocalVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.worldToLocalVelocity')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('worldVelocity') 
            .setCheck('Vec3')
            .appendField('worldVelocity');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a velocity in world coordinates to a velocity in an avatar, entity, or joint\'s local coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.worldToLocalVelocity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_worldToLocalVelocity'] = (block, generator) => {
    const _worldVelocity = dfv(generator.valueToCode(block, 'worldVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.worldToLocalVelocity(${_worldVelocity},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_worldToLocalAngularVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.worldToLocalAngularVelocity')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('worldAngularVelocity') 
            .setCheck('Vec3')
            .appendField('worldAngularVelocity');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a Euler angular velocity in world coordinates to an angular velocity in an avatar, entity, or joint\'s local coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.worldToLocalAngularVelocity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_worldToLocalAngularVelocity'] = (block, generator) => {
    const _worldAngularVelocity = dfv(generator.valueToCode(block, 'worldAngularVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.worldToLocalAngularVelocity(${_worldAngularVelocity},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_worldToLocalDimensions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.worldToLocalDimensions')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('worldDimensions') 
            .setCheck('Vec3')
            .appendField('worldDimensions');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts dimensions in world coordinates to dimensions in an avatar or entity\'s local coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.worldToLocalDimensions');
    }
};
javascript.javascriptGenerator.forBlock['Entities_worldToLocalDimensions'] = (block, generator) => {
    const _worldDimensions = dfv(generator.valueToCode(block, 'worldDimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.worldToLocalDimensions(${_worldDimensions},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_localToWorldPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.localToWorldPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('localPosition') 
            .setCheck('Vec3')
            .appendField('localPosition');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithparent') 
            .setCheck('Boolean')
            .appendField('scalesWithparent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a position in an avatar, entity, or joint\'s local coordinate to a position in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.localToWorldPosition');
    }
};
javascript.javascriptGenerator.forBlock['Entities_localToWorldPosition'] = (block, generator) => {
    const _localPosition = dfv(generator.valueToCode(block, 'localPosition', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithparent = dfv(generator.valueToCode(block, 'scalesWithparent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.localToWorldPosition(${_localPosition},${_parentID},${_parentJointIndex},${_scalesWithparent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_localToWorldRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.localToWorldRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('localRotation') 
            .setCheck('Quat')
            .appendField('localRotation');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a rotation or orientation in an avatar, entity, or joint\'s local coordinate to a rotation in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.localToWorldRotation');
    }
};
javascript.javascriptGenerator.forBlock['Entities_localToWorldRotation'] = (block, generator) => {
    const _localRotation = dfv(generator.valueToCode(block, 'localRotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.localToWorldRotation(${_localRotation},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_localToWorldVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.localToWorldVelocity')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('localVelocity') 
            .setCheck('Vec3')
            .appendField('localVelocity');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a velocity in an avatar, entity, or joint\'s local coordinate to a velocity in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.localToWorldVelocity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_localToWorldVelocity'] = (block, generator) => {
    const _localVelocity = dfv(generator.valueToCode(block, 'localVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.localToWorldVelocity(${_localVelocity},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_localToWorldAngularVelocity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.localToWorldAngularVelocity')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('localAngularVelocity') 
            .setCheck('Vec3')
            .appendField('localAngularVelocity');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts a Euler angular velocity in an avatar, entity, or joint\'s local coordinate to an angular velocity in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.localToWorldAngularVelocity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_localToWorldAngularVelocity'] = (block, generator) => {
    const _localAngularVelocity = dfv(generator.valueToCode(block, 'localAngularVelocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.localToWorldAngularVelocity(${_localAngularVelocity},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_localToWorldDimensions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.localToWorldDimensions')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('localDimensions') 
            .setCheck('Vec3')
            .appendField('localDimensions');
        this.appendValueInput('parentID') 
            .setCheck('Uuid')
            .appendField('parentID');
        this.appendValueInput('parentJointIndex') 
            .setCheck('Number')
            .appendField('parentJointIndex');
        this.appendValueInput('scalesWithParent') 
            .setCheck('Boolean')
            .appendField('scalesWithParent');

        this.setColour('#EA9958');
        this.setTooltip('Converts dimensions in an avatar or entity\'s local coordinates to dimensions in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.localToWorldDimensions');
    }
};
javascript.javascriptGenerator.forBlock['Entities_localToWorldDimensions'] = (block, generator) => {
    const _localDimensions = dfv(generator.valueToCode(block, 'localDimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentID = dfv(generator.valueToCode(block, 'parentID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parentJointIndex = dfv(generator.valueToCode(block, 'parentJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _scalesWithParent = dfv(generator.valueToCode(block, 'scalesWithParent', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Entities.localToWorldDimensions(${_localDimensions},${_parentID},${_parentJointIndex},${_scalesWithParent})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getPropertyInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getPropertyInfo')
        // Returns data
        this.setOutput(true, '["Entities.EntityPropertyInfo"]');

        // Params data
        this.appendValueInput('propertyName') 
            .setCheck('String')
            .appendField('propertyName');

        this.setColour('#EA9958');
        this.setTooltip('Gets information about an entity property, including a minimum to maximum range for some numerical properties.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getPropertyInfo');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getPropertyInfo'] = (block, generator) => {
    const _propertyName = dfv(generator.valueToCode(block, 'propertyName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Entities.getPropertyInfo(${_propertyName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Entities_collisionWithEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.collisionWithEntity');

        this.appendDummyInput('idA')
            .appendField('idA:')
            .appendField(new Blockly.FieldVariable('collisionWithEntity_idA'), 'idA');
        this.appendDummyInput('idB')
            .appendField('idB:')
            .appendField(new Blockly.FieldVariable('collisionWithEntity_idB'), 'idB');
        this.appendDummyInput('collision')
            .appendField('collision:')
            .appendField(new Blockly.FieldVariable('collisionWithEntity_collision'), 'collision');

        this.setColour('#EA9958');
        this.setTooltip('Triggered on the client that is the physics simulation owner during the collision of two entities. Note: Isn\'t triggeredfor a collision with an avatar.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.collisionWithEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_collisionWithEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const idA = generator.getVariableName(block.getFieldValue('idA'));
    const idB = generator.getVariableName(block.getFieldValue('idB'));
    const collision = generator.getVariableName(block.getFieldValue('collision'));

return `Entities.collisionWithEntity.connect((_idA,_idB,_collision) => { 
  ${idA} = _idA; 
  ${idB} = _idB; 
  ${collision} = _collision;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canAdjustLocksChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canAdjustLocksChanged');

        this.appendDummyInput('canAdjustLocks')
            .appendField('canAdjustLocks:')
            .appendField(new Blockly.FieldVariable('canAdjustLocksChanged_canAdjustLocks'), 'canAdjustLocks');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to change the <code>locked</code> property of entities changes.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canAdjustLocksChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canAdjustLocksChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canAdjustLocks = generator.getVariableName(block.getFieldValue('canAdjustLocks'));

return `Entities.canAdjustLocksChanged.connect((_canAdjustLocks) => { 
  ${canAdjustLocks} = _canAdjustLocks;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canRezChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canRezChanged');

        this.appendDummyInput('canRez')
            .appendField('canRez:')
            .appendField(new Blockly.FieldVariable('canRezChanged_canRez'), 'canRez');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to rez (create) entities changes.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canRezChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canRezChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canRez = generator.getVariableName(block.getFieldValue('canRez'));

return `Entities.canRezChanged.connect((_canRez) => { 
  ${canRez} = _canRez;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canRezTmpChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canRezTmpChanged');

        this.appendDummyInput('canRezTmp')
            .appendField('canRezTmp:')
            .appendField(new Blockly.FieldVariable('canRezTmpChanged_canRezTmp'), 'canRezTmp');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to rez (create) temporary entities changes. Temporary entities are entities with a finite<code>lifetime</code> property value set.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canRezTmpChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canRezTmpChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canRezTmp = generator.getVariableName(block.getFieldValue('canRezTmp'));

return `Entities.canRezTmpChanged.connect((_canRezTmp) => { 
  ${canRezTmp} = _canRezTmp;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canWriteAssetsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canWriteAssetsChanged');

        this.appendDummyInput('canWriteAssets')
            .appendField('canWriteAssets:')
            .appendField(new Blockly.FieldVariable('canWriteAssetsChanged_canWriteAssets'), 'canWriteAssets');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to make changes to the asset server\'s assets changes.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canWriteAssetsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canWriteAssetsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canWriteAssets = generator.getVariableName(block.getFieldValue('canWriteAssets'));

return `Entities.canWriteAssetsChanged.connect((_canWriteAssets) => { 
  ${canWriteAssets} = _canWriteAssets;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canGetAndSetPrivateUserDataChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canGetAndSetPrivateUserDataChanged');

        this.appendDummyInput('canGetAndSetPrivateUserData')
            .appendField('canGetAndSetPrivateUserData:')
            .appendField(new Blockly.FieldVariable('canGetAndSetPrivateUserDataChanged_canGetAndSetPrivateUserData'), 'canGetAndSetPrivateUserData');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to get and set private user data changes.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canGetAndSetPrivateUserDataChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canGetAndSetPrivateUserDataChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canGetAndSetPrivateUserData = generator.getVariableName(block.getFieldValue('canGetAndSetPrivateUserData'));

return `Entities.canGetAndSetPrivateUserDataChanged.connect((_canGetAndSetPrivateUserData) => { 
  ${canGetAndSetPrivateUserData} = _canGetAndSetPrivateUserData;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canRezAvatarEntitiesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canRezAvatarEntitiesChanged');

        this.appendDummyInput('canRezAvatarEntities')
            .appendField('canRezAvatarEntities:')
            .appendField(new Blockly.FieldVariable('canRezAvatarEntitiesChanged_canRezAvatarEntities'), 'canRezAvatarEntities');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to use avatar entities is changed.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canRezAvatarEntitiesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canRezAvatarEntitiesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canRezAvatarEntities = generator.getVariableName(block.getFieldValue('canRezAvatarEntities'));

return `Entities.canRezAvatarEntitiesChanged.connect((_canRezAvatarEntities) => { 
  ${canRezAvatarEntities} = _canRezAvatarEntities;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_canViewAssetURLsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.canViewAssetURLsChanged');

        this.appendDummyInput('canViewAssetURLs')
            .appendField('canViewAssetURLs:')
            .appendField(new Blockly.FieldVariable('canViewAssetURLsChanged_canViewAssetURLs'), 'canViewAssetURLs');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when your ability to view asset URLs is changed.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.canViewAssetURLsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Entities_canViewAssetURLsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canViewAssetURLs = generator.getVariableName(block.getFieldValue('canViewAssetURLs'));

return `Entities.canViewAssetURLsChanged.connect((_canViewAssetURLs) => { 
  ${canViewAssetURLs} = _canViewAssetURLs;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_mousePressOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.mousePressOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('mousePressOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mousePressOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is clicked while the mouse cursor is on an entity, or a controller trigger is fully pressed while its laser is on an entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.mousePressOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_mousePressOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.mousePressOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_mouseDoublePressOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.mouseDoublePressOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('mouseDoublePressOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseDoublePressOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is double-clicked while the mouse cursor is on an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.mouseDoublePressOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_mouseDoublePressOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.mouseDoublePressOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_mouseMoveOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.mouseMoveOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('mouseMoveOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseMoveOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Repeatedly triggered while the mouse cursor or controller laser moves on an entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.mouseMoveOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_mouseMoveOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.mouseMoveOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_mouseReleaseOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.mouseReleaseOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('mouseReleaseOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseReleaseOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is released after clicking on an entity or the controller trigger is partly or fully released after pressing on an entity, even if the mouse pointer or controller laser has moved off the entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.mouseReleaseOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_mouseReleaseOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.mouseReleaseOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_mousePressOffEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.mousePressOffEntity');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mousePressOffEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is clicked while the mouse cursor is not on an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.mousePressOffEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_mousePressOffEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.mousePressOffEntity.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_mouseDoublePressOffEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.mouseDoublePressOffEntity');

        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('mouseDoublePressOffEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is double-clicked while the mouse cursor is not on an entity.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.mouseDoublePressOffEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_mouseDoublePressOffEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.mouseDoublePressOffEntity.connect((_event) => { 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_clickDownOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.clickDownOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('clickDownOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('clickDownOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is clicked while the mouse cursor is on an entity. Note: Not triggered by controllers.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.clickDownOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_clickDownOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.clickDownOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_holdingClickOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.holdingClickOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('holdingClickOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('holdingClickOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Repeatedly triggered while a mouse button continues to be held after clicking an entity, even if the mouse cursor has moved off the entity. Note: Not triggered by controllers.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.holdingClickOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_holdingClickOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.holdingClickOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_clickReleaseOnEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.clickReleaseOnEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('clickReleaseOnEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('clickReleaseOnEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a mouse button is released after clicking on an entity, even if the mouse cursor has moved off the entity. Note: Not triggered by controllers.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.clickReleaseOnEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_clickReleaseOnEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.clickReleaseOnEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_hoverEnterEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.hoverEnterEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('hoverEnterEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('hoverEnterEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when the mouse cursor or controller laser starts hovering on an entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.hoverEnterEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_hoverEnterEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.hoverEnterEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_hoverOverEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.hoverOverEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('hoverOverEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('hoverOverEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Repeatedly triggered when the mouse cursor or controller laser moves while hovering over an entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.hoverOverEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_hoverOverEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.hoverOverEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_hoverLeaveEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.hoverLeaveEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('hoverLeaveEntity_entityID'), 'entityID');
        this.appendDummyInput('event')
            .appendField('event:')
            .appendField(new Blockly.FieldVariable('hoverLeaveEntity_event'), 'event');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when the mouse cursor or controller laser stops hovering over an entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.hoverLeaveEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_hoverLeaveEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const event = generator.getVariableName(block.getFieldValue('event'));

return `Entities.hoverLeaveEntity.connect((_entityID,_event) => { 
  ${entityID} = _entityID; 
  ${event} = _event;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_enterEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.enterEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('enterEntity_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when an avatar enters an entity.Note: At the initial loading of the script, if the avatar is already present inside the entity, it might be too late to catch this event when the script runs, so it won\'t trigger. The {@link Entities.preload|preload} signal can be used to handle those cases.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.enterEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_enterEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.enterEntity.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_leaveEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.leaveEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('leaveEntity_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when an avatar leaves an entity.<p>See also, {@link Entities|Entity Methods} and {@link Script.addEventHandler}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.leaveEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_leaveEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.leaveEntity.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_deletingEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.deletingEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('deletingEntity_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when an entity is deleted.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.deletingEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_deletingEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.deletingEntity.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_addingEntity'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.addingEntity');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('addingEntity_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when an entity is added to Interface\'s local in-memory tree of entities it knows about. This may occur whenentities are loaded upon visiting a domain, when the user rotates their view so that more entities become visible, and when any type of entity is created (e.g., by {@link Entities.addEntity|addEntity}).');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.addingEntity');
    }
};
javascript.javascriptGenerator.forBlock['Entities_addingEntity'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.addingEntity.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_deletingWearable'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.deletingWearable');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('deletingWearable_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a "wearable" entity is deleted, for example when removing a "wearable" from your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.deletingWearable');
    }
};
javascript.javascriptGenerator.forBlock['Entities_deletingWearable'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.deletingWearable.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_addingWearable'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.addingWearable');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('addingWearable_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a "wearable" entity is added to Interface\'s local in-memory tree of entities it knows about, for example when adding a "wearable" to your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.addingWearable');
    }
};
javascript.javascriptGenerator.forBlock['Entities_addingWearable'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.addingWearable.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_clearingEntities'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.clearingEntities');


        this.setColour('#EA9958');
        this.setTooltip('Triggered when you disconnect from a domain, at which time Interface\'s local in-memory tree of entities that it knows about is cleared.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.clearingEntities');
    }
};
javascript.javascriptGenerator.forBlock['Entities_clearingEntities'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Entities.clearingEntities.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Entities_webEventReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.webEventReceived');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('webEventReceived_entityID'), 'entityID');
        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('webEventReceived_message'), 'message');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when a script in a {@link Entities.EntityProperties-Web|Web} entity\'s HTML sends an event over the entity\'s HTML event bridge. The HTML web page can send a message by calling:<pre class="prettyprint"><code>EventBridge.emitWebEvent(message);</code></pre><p>Use {@link Entities.emitScriptEvent} to send messages to the Web entity\'s HTML page.</p><p>Alternatively, you can use {@link Entities.getEntityObject} to exchange messages over a Web entity\'s HTML event bridge.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.webEventReceived');
    }
};
javascript.javascriptGenerator.forBlock['Entities_webEventReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const message = generator.getVariableName(block.getFieldValue('message'));

return `Entities.webEventReceived.connect((_entityID,_message) => { 
  ${entityID} = _entityID; 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Entities_EntityType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.EntityType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>An entity may be one of the following types:</p><table>  <thead>    <tr><th>Value</th><th>Description</th><th>Properties</th></tr>  </thead>  <tbody>    <tr><td><code>"Shape"</code></td><td>A basic entity such as a cube.      See also, the <code>"Box"</code> and <code>"Sphere"</code> entity types.</td>      <td>{@link Entities.EntityProperties-Shape|EntityProperties-Shape}</td></tr>    <tr><td><code>"Box"</code></td><td>A rectangular prism. This is a synonym of <code>"Shape"</code> for the case      where the entity\'s <code>shape</code> property value is <code>"Cube"</code>.      <p>If an entity is created with its <code>type</code>       set to <code>"Box"</code> it will always be created with a <code>shape</code> property value of       <code>"Cube"</code>. If an entity of type <code>Shape</code> or <code>Sphere</code> has its <code>shape</code> set       to <code>"Cube"</code> then its <code>type</code> will be reported as <code>"Box"</code>.</p></td>      <td>{@link Entities.EntityProperties-Box|EntityProperties-Box}</td></tr>    <tr><td><code>"Sphere"</code></td><td>A sphere. This is a synonym of <code>"Shape"</code> for the case      where the entity\'s <code>shape</code> property value is <code>"Sphere"</code>.      <p>If an entity is created with its <code>type</code>      set to <code>"Sphere"</code> it will always be created with a <code>shape</code> property value of      <code>"Sphere"</code>. If an entity of type <code>Box</code> or <code>Shape</code> has its <code>shape</code> set      to <code>"Sphere"</code> then its <code>type</code> will be reported as <code>"Sphere"</code>.</td>      <td>{@link Entities.EntityProperties-Sphere|EntityProperties-Sphere}</td></tr>    <tr><td><code>"Model"</code></td><td>A mesh model from a glTF, FBX, or OBJ file.</td>      <td>{@link Entities.EntityProperties-Model|EntityProperties-Model}</td></tr>    <tr><td><code>"Text"</code></td><td>A pane of text oriented in space.</td>      <td>{@link Entities.EntityProperties-Text|EntityProperties-Text}</td></tr>    <tr><td><code>"Image"</code></td><td>An image oriented in space.</td>      <td>{@link Entities.EntityProperties-Image|EntityProperties-Image}</td></tr>    <tr><td><code>"Web"</code></td><td>A browsable web page.</td>      <td>{@link Entities.EntityProperties-Web|EntityProperties-Web}</td></tr>    <tr><td><code>"ParticleEffect"</code></td><td>A particle system that can be used to simulate things such as fire,       smoke, snow, magic spells, etc.</td>      <td>{@link Entities.EntityProperties-ParticleEffect|EntityProperties-ParticleEffect}</td></tr>    <tr><td><code>"Line"</code></td><td>A sequence of one or more simple straight lines.</td>      <td>{@link Entities.EntityProperties-Line|EntityProperties-Line}</td></tr>    <tr><td><code>"PolyLine"</code></td><td>A sequence of one or more textured straight lines.</td>      <td>{@link Entities.EntityProperties-PolyLine|EntityProperties-PolyLine}</td></tr>    <tr><td><code>"PolyVox"</code></td><td>A set of textured voxels.</td>      <td>{@link Entities.EntityProperties-PolyVox|EntityProperties-PolyVox}</td></tr>    <tr><td><code>"Grid"</code></td><td>A grid of lines in a plane.</td>      <td>{@link Entities.EntityProperties-Grid|EntityProperties-Grid}</td></tr>    <tr><td><code>"Gizmo"</code></td><td>A gizmo intended for UI.</td>      <td>{@link Entities.EntityProperties-Gizmo|EntityProperties-Gizmo}</td></tr>    <tr><td><code>"Light"</code></td><td>A local lighting effect.</td>      <td>{@link Entities.EntityProperties-Light|EntityProperties-Light}</td></tr>    <tr><td><code>"Zone"</code></td><td>A volume of lighting effects and avatar permissions.</td>      <td>{@link Entities.EntityProperties-Zone|EntityProperties-Zone}</td></tr>    <tr><td><code>"Material"</code></td><td>Modifies the existing materials on entities and avatars.</td>      <td>{@link Entities.EntityProperties-Material|EntityProperties-Material}</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.EntityType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_EntityType'] = (block, generator) => {

    return [`new Entities.EntityType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Grab'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Grab')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('grabbable') 
            .setCheck('Boolean')
            .appendField('grabbable');
        this.appendValueInput('grabKinematic') 
            .setCheck('Boolean')
            .appendField('grabKinematic');
        this.appendValueInput('grabFollowsController') 
            .setCheck('Boolean')
            .appendField('grabFollowsController');
        this.appendValueInput('triggerable') 
            .setCheck('Boolean')
            .appendField('triggerable');
        this.appendValueInput('grabDelegateToParent') 
            .setCheck('Boolean')
            .appendField('grabDelegateToParent');
        this.appendValueInput('equippable') 
            .setCheck('Boolean')
            .appendField('equippable');
        this.appendValueInput('equippableLeftPosition') 
            .setCheck('Vec3')
            .appendField('equippableLeftPosition');
        this.appendValueInput('equippableLeftRotation') 
            .setCheck('Quat')
            .appendField('equippableLeftRotation');
        this.appendValueInput('equippableRightPosition') 
            .setCheck('Vec3')
            .appendField('equippableRightPosition');
        this.appendValueInput('equippableRightRotation') 
            .setCheck('Quat')
            .appendField('equippableRightRotation');
        this.appendValueInput('equippableIndicatorURL') 
            .setCheck('String')
            .appendField('equippableIndicatorURL');
        this.appendValueInput('equippableIndicatorScale') 
            .setCheck('Vec3')
            .appendField('equippableIndicatorScale');
        this.appendValueInput('equippableIndicatorOffset') 
            .setCheck('Vec3')
            .appendField('equippableIndicatorOffset');
        this.setColour('#EA9958');
        this.setTooltip('Grabbing behavior is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Grab');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Grab'] = (block, generator) => {
    const _grabbable = dfv(generator.valueToCode(block, 'grabbable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _grabKinematic = dfv(generator.valueToCode(block, 'grabKinematic', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _grabFollowsController = dfv(generator.valueToCode(block, 'grabFollowsController', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _triggerable = dfv(generator.valueToCode(block, 'triggerable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _grabDelegateToParent = dfv(generator.valueToCode(block, 'grabDelegateToParent', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _equippable = dfv(generator.valueToCode(block, 'equippable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _equippableLeftPosition = dfv(generator.valueToCode(block, 'equippableLeftPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _equippableLeftRotation = dfv(generator.valueToCode(block, 'equippableLeftRotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _equippableRightPosition = dfv(generator.valueToCode(block, 'equippableRightPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _equippableRightRotation = dfv(generator.valueToCode(block, 'equippableRightRotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _equippableIndicatorURL = dfv(generator.valueToCode(block, 'equippableIndicatorURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _equippableIndicatorScale = dfv(generator.valueToCode(block, 'equippableIndicatorScale', javascript.javascriptGenerator.ORDER_ATOMIC), `1,1,1`);
    const _equippableIndicatorOffset = dfv(generator.valueToCode(block, 'equippableIndicatorOffset', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);

    return [`new Entities.Grab(${_grabbable},${_grabKinematic},${_grabFollowsController},${_triggerable},${_grabDelegateToParent},${_equippable},${_equippableLeftPosition},${_equippableLeftRotation},${_equippableRightPosition},${_equippableRightRotation},${_equippableIndicatorURL},${_equippableIndicatorScale},${_equippableIndicatorOffset})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Haze'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Haze')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('hazeRange') 
            .setCheck('Number')
            .appendField('hazeRange');
        this.appendValueInput('hazeColor') 
            .setCheck('Color')
            .appendField('hazeColor');
        this.appendValueInput('hazeEnableGlare') 
            .setCheck('Boolean')
            .appendField('hazeEnableGlare');
        this.appendValueInput('hazeGlareColor') 
            .setCheck('Color')
            .appendField('hazeGlareColor');
        this.appendValueInput('hazeGlareAngle') 
            .setCheck('Number')
            .appendField('hazeGlareAngle');
        this.appendValueInput('hazeAltitudeEffect') 
            .setCheck('Boolean')
            .appendField('hazeAltitudeEffect');
        this.appendValueInput('hazeBaseRef') 
            .setCheck('Number')
            .appendField('hazeBaseRef');
        this.appendValueInput('hazeCeiling') 
            .setCheck('Number')
            .appendField('hazeCeiling');
        this.appendValueInput('hazeBackgroundBlend') 
            .setCheck('Number')
            .appendField('hazeBackgroundBlend');
        this.appendValueInput('hazeAttenuateKeyLight') 
            .setCheck('Boolean')
            .appendField('hazeAttenuateKeyLight');
        this.appendValueInput('hazeKeyLightRange') 
            .setCheck('Number')
            .appendField('hazeKeyLightRange');
        this.appendValueInput('hazeKeyLightAltitude') 
            .setCheck('Number')
            .appendField('hazeKeyLightAltitude');
        this.setColour('#EA9958');
        this.setTooltip('Haze is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Haze');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Haze'] = (block, generator) => {
    const _hazeRange = dfv(generator.valueToCode(block, 'hazeRange', javascript.javascriptGenerator.ORDER_ATOMIC), `1000`);
    const _hazeColor = dfv(generator.valueToCode(block, 'hazeColor', javascript.javascriptGenerator.ORDER_ATOMIC), `128,154,179`);
    const _hazeEnableGlare = dfv(generator.valueToCode(block, 'hazeEnableGlare', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _hazeGlareColor = dfv(generator.valueToCode(block, 'hazeGlareColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,299,179`);
    const _hazeGlareAngle = dfv(generator.valueToCode(block, 'hazeGlareAngle', javascript.javascriptGenerator.ORDER_ATOMIC), `20`);
    const _hazeAltitudeEffect = dfv(generator.valueToCode(block, 'hazeAltitudeEffect', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _hazeBaseRef = dfv(generator.valueToCode(block, 'hazeBaseRef', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _hazeCeiling = dfv(generator.valueToCode(block, 'hazeCeiling', javascript.javascriptGenerator.ORDER_ATOMIC), `200`);
    const _hazeBackgroundBlend = dfv(generator.valueToCode(block, 'hazeBackgroundBlend', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _hazeAttenuateKeyLight = dfv(generator.valueToCode(block, 'hazeAttenuateKeyLight', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _hazeKeyLightRange = dfv(generator.valueToCode(block, 'hazeKeyLightRange', javascript.javascriptGenerator.ORDER_ATOMIC), `1000`);
    const _hazeKeyLightAltitude = dfv(generator.valueToCode(block, 'hazeKeyLightAltitude', javascript.javascriptGenerator.ORDER_ATOMIC), `200`);

    return [`new Entities.Haze(${_hazeRange},${_hazeColor},${_hazeEnableGlare},${_hazeGlareColor},${_hazeGlareAngle},${_hazeAltitudeEffect},${_hazeBaseRef},${_hazeCeiling},${_hazeBackgroundBlend},${_hazeAttenuateKeyLight},${_hazeKeyLightRange},${_hazeKeyLightAltitude})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_KeyLight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.KeyLight')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('intensity') 
            .setCheck('Number')
            .appendField('intensity');
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('castShadows') 
            .setCheck('Boolean')
            .appendField('castShadows');
        this.appendValueInput('shadowBias') 
            .setCheck('Number')
            .appendField('shadowBias');
        this.appendValueInput('shadowMaxDistance') 
            .setCheck('Number')
            .appendField('shadowMaxDistance');
        this.setColour('#EA9958');
        this.setTooltip('A key light is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.KeyLight');
    }
};
javascript.javascriptGenerator.forBlock['Entities_KeyLight'] = (block, generator) => {
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _intensity = dfv(generator.valueToCode(block, 'intensity', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), `0,-1,0`);
    const _castShadows = dfv(generator.valueToCode(block, 'castShadows', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _shadowBias = dfv(generator.valueToCode(block, 'shadowBias', javascript.javascriptGenerator.ORDER_ATOMIC), `0.5`);
    const _shadowMaxDistance = dfv(generator.valueToCode(block, 'shadowMaxDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `40.0`);

    return [`new Entities.KeyLight(${_color},${_intensity},${_direction},${_castShadows},${_shadowBias},${_shadowMaxDistance})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_PolyVoxSurfaceStyle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.PolyVoxSurfaceStyle')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>The surface of a {@link Entities.EntityProperties-PolyVox|PolyVox} entity may be one of the following styles:</p><table>  <thead>    <tr><th>Value</th><th>Type</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>Marching cubes.</td><td>Chamfered edges. Open volume.      Joins neighboring PolyVox entities reasonably well.</td></tr>    <tr><td><code>1</code></td><td>Cubic.</td><td>Square edges. Open volume.      Joins neighboring PolyVox entities cleanly.</td></tr>    <tr><td><code>2</code></td><td>Edged cubic.</td><td>Square edges. Enclosed volume.      Joins neighboring PolyVox entities cleanly.</td></tr>    <tr><td><code>3</code></td><td>Edged marching cubes.</td><td>Chamfered edges. Enclosed volume.      Doesn\'t join neighboring PolyVox entities.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.PolyVoxSurfaceStyle');
    }
};
javascript.javascriptGenerator.forBlock['Entities_PolyVoxSurfaceStyle'] = (block, generator) => {

    return [`new Entities.PolyVoxSurfaceStyle()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Pulse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Pulse')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('min') 
            .setCheck('Number')
            .appendField('min');
        this.appendValueInput('max') 
            .setCheck('Number')
            .appendField('max');
        this.appendValueInput('period') 
            .setCheck('Number')
            .appendField('period');
        this.appendValueInput('colorMode') 
            .setCheck('Entities.PulseMode')
            .appendField('colorMode');
        this.appendValueInput('alphaMode') 
            .setCheck('Entities.PulseMode')
            .appendField('alphaMode');
        this.setColour('#EA9958');
        this.setTooltip('A color and alpha pulse that an entity may have.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Pulse');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Pulse'] = (block, generator) => {
    const _min = dfv(generator.valueToCode(block, 'min', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _max = dfv(generator.valueToCode(block, 'max', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _period = dfv(generator.valueToCode(block, 'period', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _colorMode = dfv(generator.valueToCode(block, 'colorMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);
    const _alphaMode = dfv(generator.valueToCode(block, 'alphaMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);

    return [`new Entities.Pulse(${_min},${_max},${_period},${_colorMode},${_alphaMode})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_RingGizmo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.RingGizmo')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('startAngle') 
            .setCheck('Number')
            .appendField('startAngle');
        this.appendValueInput('endAngle') 
            .setCheck('Number')
            .appendField('endAngle');
        this.appendValueInput('innerRadius') 
            .setCheck('Number')
            .appendField('innerRadius');
        this.appendValueInput('innerStartColor') 
            .setCheck('Color')
            .appendField('innerStartColor');
        this.appendValueInput('innerEndColor') 
            .setCheck('Color')
            .appendField('innerEndColor');
        this.appendValueInput('outerStartColor') 
            .setCheck('Color')
            .appendField('outerStartColor');
        this.appendValueInput('outerEndColor') 
            .setCheck('Color')
            .appendField('outerEndColor');
        this.appendValueInput('innerStartAlpha') 
            .setCheck('Number')
            .appendField('innerStartAlpha');
        this.appendValueInput('innerEndAlpha') 
            .setCheck('Number')
            .appendField('innerEndAlpha');
        this.appendValueInput('outerStartAlpha') 
            .setCheck('Number')
            .appendField('outerStartAlpha');
        this.appendValueInput('outerEndAlpha') 
            .setCheck('Number')
            .appendField('outerEndAlpha');
        this.appendValueInput('hasTickMarks') 
            .setCheck('Boolean')
            .appendField('hasTickMarks');
        this.appendValueInput('majorTickMarksAngle') 
            .setCheck('Number')
            .appendField('majorTickMarksAngle');
        this.appendValueInput('minorTickMarksAngle') 
            .setCheck('Number')
            .appendField('minorTickMarksAngle');
        this.appendValueInput('majorTickMarksLength') 
            .setCheck('Number')
            .appendField('majorTickMarksLength');
        this.appendValueInput('minorTickMarksLength') 
            .setCheck('Number')
            .appendField('minorTickMarksLength');
        this.appendValueInput('majorTickMarksColor') 
            .setCheck('Color')
            .appendField('majorTickMarksColor');
        this.appendValueInput('minorTickMarksColor') 
            .setCheck('Color')
            .appendField('minorTickMarksColor');
        this.setColour('#EA9958');
        this.setTooltip('A {@link Entities.EntityProperties-Gizmo|ring Gizmo} entity is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.RingGizmo');
    }
};
javascript.javascriptGenerator.forBlock['Entities_RingGizmo'] = (block, generator) => {
    const _startAngle = dfv(generator.valueToCode(block, 'startAngle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _endAngle = dfv(generator.valueToCode(block, 'endAngle', javascript.javascriptGenerator.ORDER_ATOMIC), `360`);
    const _innerRadius = dfv(generator.valueToCode(block, 'innerRadius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _innerStartColor = dfv(generator.valueToCode(block, 'innerStartColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _innerEndColor = dfv(generator.valueToCode(block, 'innerEndColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _outerStartColor = dfv(generator.valueToCode(block, 'outerStartColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _outerEndColor = dfv(generator.valueToCode(block, 'outerEndColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _innerStartAlpha = dfv(generator.valueToCode(block, 'innerStartAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _innerEndAlpha = dfv(generator.valueToCode(block, 'innerEndAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _outerStartAlpha = dfv(generator.valueToCode(block, 'outerStartAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _outerEndAlpha = dfv(generator.valueToCode(block, 'outerEndAlpha', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _hasTickMarks = dfv(generator.valueToCode(block, 'hasTickMarks', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _majorTickMarksAngle = dfv(generator.valueToCode(block, 'majorTickMarksAngle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _minorTickMarksAngle = dfv(generator.valueToCode(block, 'minorTickMarksAngle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _majorTickMarksLength = dfv(generator.valueToCode(block, 'majorTickMarksLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _minorTickMarksLength = dfv(generator.valueToCode(block, 'minorTickMarksLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _majorTickMarksColor = dfv(generator.valueToCode(block, 'majorTickMarksColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);
    const _minorTickMarksColor = dfv(generator.valueToCode(block, 'minorTickMarksColor', javascript.javascriptGenerator.ORDER_ATOMIC), `255,255,255`);

    return [`new Entities.RingGizmo(${_startAngle},${_endAngle},${_innerRadius},${_innerStartColor},${_innerEndColor},${_outerStartColor},${_outerEndColor},${_innerStartAlpha},${_innerEndAlpha},${_outerStartAlpha},${_outerEndAlpha},${_hasTickMarks},${_majorTickMarksAngle},${_minorTickMarksAngle},${_majorTickMarksLength},${_minorTickMarksLength},${_majorTickMarksColor},${_minorTickMarksColor})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Shape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Shape')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>A <code>"Shape"</code>, <code>"Box"</code>, or <code>"Sphere"</code> {@link Entities.EntityType|EntityType} may display as one of the following geometrical shapes:</p><table>  <thead>    <tr><th>Value</th><th>Dimensions</th><th>Notes</th></tr>  </thead>  <tbody>    <tr><td><code>"Circle"</code></td><td>2D</td><td>A circle oriented in 3D.</td></tr>    <tr><td><code>"Cone"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Cube"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Cylinder"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Dodecahedron"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Hexagon"</code></td><td>3D</td><td>A hexagonal prism.</td></tr>    <tr><td><code>"Icosahedron"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Octagon"</code></td><td>3D</td><td>An octagonal prism.</td></tr>    <tr><td><code>"Octahedron"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Quad"</code></td><td>2D</td><td>A square oriented in 3D.</td></tr>    <tr><td><code>"Sphere"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Tetrahedron"</code></td><td>3D</td><td></td></tr>    <tr><td><code>"Torus"</code></td><td>3D</td><td><em>Not implemented.</em></td></tr>    <tr><td><code>"Triangle"</code></td><td>3D</td><td>A triangular prism.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Shape');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Shape'] = (block, generator) => {

    return [`new Entities.Shape()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Skybox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Skybox')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('color') 
            .setCheck('Color')
            .appendField('color');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#EA9958');
        this.setTooltip('A skybox is defined by the following properties:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Skybox');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Skybox'] = (block, generator) => {
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

    return [`new Entities.Skybox(${_color},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_BufferTypeName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.BufferTypeName')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#D334DF');
        this.setTooltip('<p>The type name of a graphics buffer.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"position"</code></td><td>Position buffer.</td></tr>    <tr><td><code>"normal"</code></td><td>normal buffer.</td></tr>    <tr><td><code>"tangent"</code></td><td>Tangent buffer.</td></tr>    <tr><td><code>"color"</code></td><td>Color buffer.</td></tr>    <tr><td><code>"skin_cluster_index"</code></td><td>Skin cluster index buffer.</td></tr>    <tr><td><code>"skin_cluster_weight"</code></td><td>Skin cluster weight buffer.</td></tr>    <tr><td><code>"texcoord0"</code></td><td>First UV coordinates buffer.</td></tr>    <tr><td><code>"texcoord1"</code></td><td>Second UV coordinates buffer.</td></tr>    <tr><td><code>"texcoord2"</code></td><td>Third UV coordinates buffer.</td></tr>    <tr><td><code>"texcoord3"</code></td><td>Fourth UV coordinates buffer.</td></tr>    <tr><td><code>"texcoord4"</code></td><td>Fifth UV coordinates buffer.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.BufferTypeName');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_BufferTypeName'] = (block, generator) => {

    return [`new Graphics.BufferTypeName()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_BufferType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.BufferType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#D334DF');
        this.setTooltip('<p>The type of a graphics buffer value as accessed by JavaScript.</p><table>  <thead>    <tr><th>Type</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td>{@link Vec3}</td><td><code>"position"</code></td><td>Position buffer.</td></tr>    <tr><td>{@link Vec3}</td><td><code>"normal"</code></td><td>normal buffer.</td></tr>    <tr><td>{@link Vec3}</td><td><code>"tangent"</code></td><td>Tangent buffer.</td></tr>    <tr><td>{@link Vec4}</td><td><code>"color"</code></td><td>Color buffer.</td></tr>    <tr><td>{@link Vec4}</td><td><code>"skin_cluster_index"</code></td><td>Skin cluster index buffer.</td></tr>    <tr><td>{@link Vec4}</td><td><code>"skin_cluster_weight"</code></td><td>Skin cluster weight buffer.</td></tr>    <tr><td>{@link Vec2}</td><td><code>"texcoord0"</code></td><td>First UV coordinates buffer.</td></tr>    <tr><td>{@link Vec2}</td><td><code>"texcoord1"</code></td><td>Second UV coordinates buffer.</td></tr>    <tr><td>{@link Vec2}</td><td><code>"texcoord2"</code></td><td>Third UV coordinates buffer.</td></tr>    <tr><td>{@link Vec2}</td><td><code>"texcoord3"</code></td><td>Fourth UV coordinates buffer.</td></tr>    <tr><td>{@link Vec2}</td><td><code>"texcoord4"</code></td><td>Fifth UV coordinates buffer.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.BufferType');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_BufferType'] = (block, generator) => {

    return [`new Graphics.BufferType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_MeshTopology'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.MeshTopology')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#D334DF');
        this.setTooltip('<p>The interpretation of mesh elements.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"points"</code></td><td>Points.</td></tr>    <tr><td><code>"lines"</code></td><td>Lines.</td></tr>    <tr><td><code>"line_strip"</code></td><td>Line strip.</td></tr>    <tr><td><code>"triangles"</code></td><td>Triangles.</td></tr>    <tr><td><code>"triangle_strip"</code></td><td>Triangle strip.</td></tr>    <tr><td><code>"quads"</code></td><td>Quads.</td></tr>    <tr><td><code>"quad_strip"</code></td><td>Quad strip.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.MeshTopology');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_MeshTopology'] = (block, generator) => {

    return [`new Graphics.MeshTopology()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_MaterialLayer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.MaterialLayer')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('material') 
            .setCheck('Entities.Material')
            .appendField('material');
        this.appendValueInput('priority') 
            .setCheck('Number')
            .appendField('priority');
        this.setColour('#D334DF');
        this.setTooltip('A material layer.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.MaterialLayer');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_MaterialLayer'] = (block, generator) => {
    const _material = dfv(generator.valueToCode(block, 'material', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _priority = dfv(generator.valueToCode(block, 'priority', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Graphics.MaterialLayer(${_material},${_priority})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_IFSData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.IFSData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('topology') 
            .setCheck('Graphics.MeshTopology')
            .appendField('topology');
        this.appendValueInput('indices') 
            .setCheck('Array')
            .appendField('indices');
        this.appendValueInput('positions') 
            .setCheck('Array')
            .appendField('positions');
        this.appendValueInput('normals') 
            .setCheck('Array')
            .appendField('normals');
        this.appendValueInput('colors') 
            .setCheck('Array')
            .appendField('colors');
        this.appendValueInput('texCoords0') 
            .setCheck('Array')
            .appendField('texCoords0');
        this.setColour('#D334DF');
        this.setTooltip('IFS (Indexed-Face Set) data defining a mesh.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.IFSData');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_IFSData'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _topology = dfv(generator.valueToCode(block, 'topology', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _indices = dfv(generator.valueToCode(block, 'indices', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _positions = dfv(generator.valueToCode(block, 'positions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _normals = dfv(generator.valueToCode(block, 'normals', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _colors = dfv(generator.valueToCode(block, 'colors', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _texCoords0 = dfv(generator.valueToCode(block, 'texCoords0', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);

    return [`new Graphics.IFSData(${_name},${_topology},${_indices},${_positions},${_normals},${_colors},${_texCoords0})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Graphics_getModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.getModel')
        // Returns data
        this.setOutput(true, '["GraphicsModel"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('UUID')
            .appendField('id');

        this.setColour('#D334DF');
        this.setTooltip('Gets a handle to the model data used for displaying an avatar, 3D entity, or 3D overlay.<p>Note: The model data may be used for more than one instance of the item displayed in the scene.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.getModel');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_getModel'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Graphics.getModel(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Graphics_updateModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.updateModel')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('model') 
            .setCheck('GraphicsModel')
            .appendField('model');

        this.setColour('#D334DF');
        this.setTooltip('Updates the model for an avatar, 3D entity, or 3D overlay in the rendered scene.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.updateModel');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_updateModel'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Graphics.updateModel(${_id},${_model})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Graphics_canUpdateModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.canUpdateModel')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');
        this.appendValueInput('meshIndex') 
            .setCheck('Number')
            .appendField('meshIndex');
        this.appendValueInput('partNumber') 
            .setCheck('Number')
            .appendField('partNumber');

        this.setColour('#D334DF');
        this.setTooltip('Checks whether the model for an avatar, entity, or overlay can be updated in the rendered scene. Only avatars,<code>"Model"</code> entities and <code>"model"</code> overlays can have their meshes updated.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.canUpdateModel');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_canUpdateModel'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _meshIndex = dfv(generator.valueToCode(block, 'meshIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);
    const _partNumber = dfv(generator.valueToCode(block, 'partNumber', javascript.javascriptGenerator.ORDER_ATOMIC), `-1`);

return [`Graphics.canUpdateModel(${_id},${_meshIndex},${_partNumber})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Graphics_newModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.newModel')
        // Returns data
        this.setOutput(true, '["GraphicsModel"]');

        // Params data
        this.appendValueInput('meshes') 
            .setCheck('Array')
            .appendField('meshes');

        this.setColour('#D334DF');
        this.setTooltip('Creates a new graphics model from meshes.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.newModel');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_newModel'] = (block, generator) => {
    const _meshes = dfv(generator.valueToCode(block, 'meshes', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Graphics.newModel(${_meshes})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Graphics_newMesh'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.newMesh')
        // Returns data
        this.setOutput(true, '["GraphicsMesh"]');

        // Params data
        this.appendValueInput('ifsMeshData') 
            .setCheck('Graphics.IFSData')
            .appendField('ifsMeshData');

        this.setColour('#D334DF');
        this.setTooltip('Creates a new graphics mesh.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.newMesh');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_newMesh'] = (block, generator) => {
    const _ifsMeshData = dfv(generator.valueToCode(block, 'ifsMeshData', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Graphics.newMesh(${_ifsMeshData})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Graphics_exportModelToOBJ'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.exportModelToOBJ')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('model') 
            .setCheck('GraphicsModel')
            .appendField('model');

        this.setColour('#D334DF');
        this.setTooltip('Exports a model to OBJ format.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.exportModelToOBJ');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_exportModelToOBJ'] = (block, generator) => {
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Graphics.exportModelToOBJ(${_model})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Graphics_MeshExtents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.MeshExtents')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('brn') 
            .setCheck('Vec3')
            .appendField('brn');
        this.appendValueInput('tfl') 
            .setCheck('Vec3')
            .appendField('tfl');
        this.appendValueInput('center') 
            .setCheck('Vec3')
            .appendField('center');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.setColour('#D334DF');
        this.setTooltip('The extents of a mesh.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.MeshExtents');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_MeshExtents'] = (block, generator) => {
    const _brn = dfv(generator.valueToCode(block, 'brn', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _tfl = dfv(generator.valueToCode(block, 'tfl', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _center = dfv(generator.valueToCode(block, 'center', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Graphics.MeshExtents(${_brn},${_tfl},${_center},${_dimensions})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_BufferElementFormat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.BufferElementFormat')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('String')
            .appendField('type');
        this.appendValueInput('semantic') 
            .setCheck('String')
            .appendField('semantic');
        this.appendValueInput('dimension') 
            .setCheck('String')
            .appendField('dimension');
        this.appendValueInput('scalarCount') 
            .setCheck('Number')
            .appendField('scalarCount');
        this.appendValueInput('byteSize') 
            .setCheck('Number')
            .appendField('byteSize');
        this.appendValueInput('BYTESPERELEMENT') 
            .setCheck('Number')
            .appendField('BYTESPERELEMENT');
        this.setColour('#D334DF');
        this.setTooltip('Details of a buffer element\'s format.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.BufferElementFormat');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_BufferElementFormat'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _semantic = dfv(generator.valueToCode(block, 'semantic', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _dimension = dfv(generator.valueToCode(block, 'dimension', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scalarCount = dfv(generator.valueToCode(block, 'scalarCount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _byteSize = dfv(generator.valueToCode(block, 'byteSize', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _BYTESPERELEMENT = dfv(generator.valueToCode(block, 'BYTESPERELEMENT', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Graphics.BufferElementFormat(${_type},${_semantic},${_dimension},${_scalarCount},${_byteSize},${_BYTESPERELEMENT})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Graphics_BufferFormat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Graphics.BufferFormat')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('slot') 
            .setCheck('Number')
            .appendField('slot');
        this.appendValueInput('length') 
            .setCheck('Number')
            .appendField('length');
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('offset') 
            .setCheck('Number')
            .appendField('offset');
        this.appendValueInput('stride') 
            .setCheck('Number')
            .appendField('stride');
        this.appendValueInput('element') 
            .setCheck('Graphics.BufferElementFormat')
            .appendField('element');
        this.setColour('#D334DF');
        this.setTooltip('Details of buffer\'s format.');
        this.setHelpUrl('https://apidocs.overte.org/Graphics.html#.BufferFormat');
    }
};
javascript.javascriptGenerator.forBlock['Graphics_BufferFormat'] = (block, generator) => {
    const _slot = dfv(generator.valueToCode(block, 'slot', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _length = dfv(generator.valueToCode(block, 'length', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _offset = dfv(generator.valueToCode(block, 'offset', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _stride = dfv(generator.valueToCode(block, 'stride', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _element = dfv(generator.valueToCode(block, 'element', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Graphics.BufferFormat(${_slot},${_length},${_byteLength},${_offset},${_stride},${_element})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['GraphicsMesh~forEachVertextCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh~forEachVertextCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#50BBEC');
        this.setTooltip('Called for each vertex when {@link GraphicsMesh.updateVertexAttributes} is called.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh~forEachVertextCallback');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh~forEachVertextCallback'] = (block, generator) => {

    return [`new GraphicsMesh~forEachVertextCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['GraphicsMesh~updateVertexAttributesCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh~updateVertexAttributesCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#50BBEC');
        this.setTooltip('Called for each vertex when {@link GraphicsMesh.updateVertexAttributes} is called. The value returned by the script functionshould be the modified attributes to update the vertex with, or <code>false</code> to not update the particular vertex.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh~updateVertexAttributesCallback');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh~updateVertexAttributesCallback'] = (block, generator) => {

    return [`new GraphicsMesh~updateVertexAttributesCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['GraphicsMesh'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('numParts') 
            .setCheck('Number')
            .appendField('numParts');
        this.appendValueInput('parts') 
            .setCheck('Array')
            .appendField('parts');
        this.appendValueInput('numIndices') 
            .setCheck('Number')
            .appendField('numIndices');
        this.appendValueInput('numVertices') 
            .setCheck('Number')
            .appendField('numVertices');
        this.appendValueInput('numAttributes') 
            .setCheck('Number')
            .appendField('numAttributes');
        this.appendValueInput('attributeNames') 
            .setCheck('Array')
            .appendField('attributeNames');
        this.appendValueInput('valid') 
            .setCheck('Boolean')
            .appendField('valid');
        this.appendValueInput('strong') 
            .setCheck('Boolean')
            .appendField('strong');
        this.appendValueInput('extents') 
            .setCheck('Graphics.MeshExtents')
            .appendField('extents');
        this.appendValueInput('bufferFormats') 
            .setCheck('Object.<Graphics.BufferTypeName, Graphics.BufferFormat>')
            .appendField('bufferFormats');
        this.setColour('#50BBEC');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>A handle to in-memory mesh data in a {@link GraphicsModel}.<p>Create using the {@link Graphics} API, {@link GraphicsModel.cloneModel}, or {@link GraphicsMesh.cloneMesh}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh'] = (block, generator) => {
    const _numParts = dfv(generator.valueToCode(block, 'numParts', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _parts = dfv(generator.valueToCode(block, 'parts', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _numIndices = dfv(generator.valueToCode(block, 'numIndices', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _numVertices = dfv(generator.valueToCode(block, 'numVertices', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _numAttributes = dfv(generator.valueToCode(block, 'numAttributes', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _attributeNames = dfv(generator.valueToCode(block, 'attributeNames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _valid = dfv(generator.valueToCode(block, 'valid', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _strong = dfv(generator.valueToCode(block, 'strong', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _extents = dfv(generator.valueToCode(block, 'extents', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _bufferFormats = dfv(generator.valueToCode(block, 'bufferFormats', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new GraphicsMesh(${_numParts},${_parts},${_numIndices},${_numVertices},${_numAttributes},${_attributeNames},${_valid},${_strong},${_extents},${_bufferFormats})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['GraphicsMesh_getParentModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.getParentModel')
        // Returns data
        this.setOutput(true, '["GraphicsModel"]');

        // Params data

        this.setColour('#50BBEC');
        this.setTooltip('Gets the model the mesh is part of.<p><em>Currently doesn\'t work.</em></p>');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.getParentModel');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_getParentModel'] = (block, generator) => {

return [`GraphicsMesh.getParentModel()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_getIndices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.getIndices')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#50BBEC');
        this.setTooltip('Gets the vertex indices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.getIndices');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_getIndices'] = (block, generator) => {

return [`GraphicsMesh.getIndices()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_findNearbyVertexIndices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.findNearbyVertexIndices')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');
        this.appendValueInput('epsilon') 
            .setCheck('Number')
            .appendField('epsilon');

        this.setColour('#50BBEC');
        this.setTooltip('Gets the indices of nearby vertices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.findNearbyVertexIndices');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_findNearbyVertexIndices'] = (block, generator) => {
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _epsilon = dfv(generator.valueToCode(block, 'epsilon', javascript.javascriptGenerator.ORDER_ATOMIC), `1e-6`);

return [`GraphicsMesh.findNearbyVertexIndices(${_origin},${_epsilon})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_addAttribute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.addAttribute')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');
        this.appendValueInput('defaultValue') 
            .setCheck('Graphics.BufferType')
            .appendField('defaultValue');

        this.setColour('#50BBEC');
        this.setTooltip('Adds an attribute for all vertices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.addAttribute');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_addAttribute'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultValue = dfv(generator.valueToCode(block, 'defaultValue', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.addAttribute(${_name},${_defaultValue})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_fillAttribute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.fillAttribute')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('Graphics.BufferType')
            .appendField('value');

        this.setColour('#50BBEC');
        this.setTooltip('Sets the value of an attribute for all vertices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.fillAttribute');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_fillAttribute'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.fillAttribute(${_name},${_value})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_removeAttribute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.removeAttribute')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');

        this.setColour('#50BBEC');
        this.setTooltip('Removes an attribute from all vertices.<p>Note: The <code>"position"</code> attribute cannot be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.removeAttribute');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_removeAttribute'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.removeAttribute(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_queryVertexAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.queryVertexAttributes')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');

        this.setColour('#50BBEC');
        this.setTooltip('Gets the value of an attribute for all vertices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.queryVertexAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_queryVertexAttributes'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.queryVertexAttributes(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_getVertexAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.getVertexAttributes')
        // Returns data
        this.setOutput(true, '["Object.<Graphics.BufferTypeName, Graphics.BufferType>"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#50BBEC');
        this.setTooltip('Gets the attributes and attribute values of a vertex.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.getVertexAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_getVertexAttributes'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`GraphicsMesh.getVertexAttributes(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_setVertexAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.setVertexAttributes')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('values') 
            .setCheck('Object.<Graphics.BufferTypeNAme, Graphics.BufferType>')
            .appendField('values');

        this.setColour('#50BBEC');
        this.setTooltip('Updates attribute values of a vertex.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.setVertexAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_setVertexAttributes'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _values = dfv(generator.valueToCode(block, 'values', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.setVertexAttributes(${_index},${_values})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_getVertexProperty'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.getVertexProperty')
        // Returns data
        this.setOutput(true, '["Graphics.BufferType"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');

        this.setColour('#50BBEC');
        this.setTooltip('Gets the value of a vertex\'s attribute.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.getVertexProperty');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_getVertexProperty'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.getVertexProperty(${_index},${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_setVertexProperty'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.setVertexProperty')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('Graphics.BufferType')
            .appendField('value');

        this.setColour('#50BBEC');
        this.setTooltip('Sets the value of a vertex\'s attribute.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.setVertexProperty');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_setVertexProperty'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.setVertexProperty(${_index},${_name},${_value})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_cloneMesh'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.cloneMesh')
        // Returns data
        this.setOutput(true, '["GraphicsMesh"]');

        // Params data

        this.setColour('#50BBEC');
        this.setTooltip('Makes a copy of the mesh.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.cloneMesh');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_cloneMesh'] = (block, generator) => {

return [`GraphicsMesh.cloneMesh()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_updateVertexAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.updateVertexAttributes')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('callback') 
            .setCheck('GraphicsMesh~updateVertexAttributesCallback')
            .appendField('callback');

        this.setColour('#50BBEC');
        this.setTooltip('Updates vertex attributes by calling a function for each vertex. The function can return modified attributes to update the vertex with.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.updateVertexAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_updateVertexAttributes'] = (block, generator) => {
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.updateVertexAttributes(${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_forEachVertex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.forEachVertex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('callback') 
            .setCheck('GraphicsMesh~forEachVertexCallback')
            .appendField('callback');

        this.setColour('#50BBEC');
        this.setTooltip('Calls a function for each vertex.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.forEachVertex');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_forEachVertex'] = (block, generator) => {
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.forEachVertex(${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMesh_isValidIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMesh.isValidIndex')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('attribute') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('attribute');

        this.setColour('#50BBEC');
        this.setTooltip('Checks if an index is valid and, optionally, that vertex has a particular attribute.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMesh.html#.isValidIndex');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMesh_isValidIndex'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _attribute = dfv(generator.valueToCode(block, 'attribute', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMesh.isValidIndex(${_index},${_attribute})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['GraphicsMeshPart'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('valid') 
            .setCheck('Boolean')
            .appendField('valid');
        this.appendValueInput('partIndex') 
            .setCheck('Number')
            .appendField('partIndex');
        this.appendValueInput('firstVertexIndex') 
            .setCheck('Number')
            .appendField('firstVertexIndex');
        this.appendValueInput('baseVertexIndex') 
            .setCheck('Number')
            .appendField('baseVertexIndex');
        this.appendValueInput('lastVertexIndex') 
            .setCheck('Number')
            .appendField('lastVertexIndex');
        this.appendValueInput('topology') 
            .setCheck('Graphics.MeshTopology')
            .appendField('topology');
        this.appendValueInput('numIndices') 
            .setCheck('Number')
            .appendField('numIndices');
        this.appendValueInput('numVertices') 
            .setCheck('Number')
            .appendField('numVertices');
        this.appendValueInput('numVerticesPerFace') 
            .setCheck('Number')
            .appendField('numVerticesPerFace');
        this.appendValueInput('numFaces') 
            .setCheck('Number')
            .appendField('numFaces');
        this.appendValueInput('numAttributes') 
            .setCheck('Number')
            .appendField('numAttributes');
        this.appendValueInput('attributeNames') 
            .setCheck('Array')
            .appendField('attributeNames');
        this.appendValueInput('extents') 
            .setCheck('Graphics.MeshExtents')
            .appendField('extents');
        this.appendValueInput('bufferFormats') 
            .setCheck('Object.<Graphics.BufferTypeName, Graphics.BufferFormat>')
            .appendField('bufferFormats');
        this.setColour('#8BBD83');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>A handle to in-memory mesh part data in a {@link GraphicsModel}.<p>Create using the {@link Graphics} API, {@link GraphicsModel.cloneModel}, {@link GraphicsMesh.cloneMesh}, or {@link GraphicsMeshPart.cloneMeshPart}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart'] = (block, generator) => {
    const _valid = dfv(generator.valueToCode(block, 'valid', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _partIndex = dfv(generator.valueToCode(block, 'partIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _firstVertexIndex = dfv(generator.valueToCode(block, 'firstVertexIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _baseVertexIndex = dfv(generator.valueToCode(block, 'baseVertexIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastVertexIndex = dfv(generator.valueToCode(block, 'lastVertexIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _topology = dfv(generator.valueToCode(block, 'topology', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _numIndices = dfv(generator.valueToCode(block, 'numIndices', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _numVertices = dfv(generator.valueToCode(block, 'numVertices', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _numVerticesPerFace = dfv(generator.valueToCode(block, 'numVerticesPerFace', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _numFaces = dfv(generator.valueToCode(block, 'numFaces', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _numAttributes = dfv(generator.valueToCode(block, 'numAttributes', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _attributeNames = dfv(generator.valueToCode(block, 'attributeNames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extents = dfv(generator.valueToCode(block, 'extents', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _bufferFormats = dfv(generator.valueToCode(block, 'bufferFormats', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new GraphicsMeshPart(${_valid},${_partIndex},${_firstVertexIndex},${_baseVertexIndex},${_lastVertexIndex},${_topology},${_numIndices},${_numVertices},${_numVerticesPerFace},${_numFaces},${_numAttributes},${_attributeNames},${_extents},${_bufferFormats})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['GraphicsMeshPart_getIndices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.getIndices')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#8BBD83');
        this.setTooltip('Gets the vertex indices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.getIndices');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_getIndices'] = (block, generator) => {

return [`GraphicsMeshPart.getIndices()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_setIndices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.setIndices')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('indices') 
            .setCheck('Array')
            .appendField('indices');

        this.setColour('#8BBD83');
        this.setTooltip('Sets the vertex indices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.setIndices');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_setIndices'] = (block, generator) => {
    const _indices = dfv(generator.valueToCode(block, 'indices', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.setIndices(${_indices})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_findNearbyPartVertexIndices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.findNearbyPartVertexIndices')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');
        this.appendValueInput('epsilon') 
            .setCheck('Number')
            .appendField('epsilon');

        this.setColour('#8BBD83');
        this.setTooltip('Gets the indices of nearby vertices in the mesh part.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.findNearbyPartVertexIndices');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_findNearbyPartVertexIndices'] = (block, generator) => {
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _epsilon = dfv(generator.valueToCode(block, 'epsilon', javascript.javascriptGenerator.ORDER_ATOMIC), `1e-6`);

return [`GraphicsMeshPart.findNearbyPartVertexIndices(${_origin},${_epsilon})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPArt_queryVertexAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPArt.queryVertexAttributes')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');

        this.setColour('#8D46C2');
        this.setTooltip('Gets the value of an attribute for all vertices in the <em>whole</em> mesh (i.e., parent and mesh parts).');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPArt.html#.queryVertexAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPArt_queryVertexAttributes'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPArt.queryVertexAttributes(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_getVertexProperty'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.getVertexProperty')
        // Returns data
        this.setOutput(true, '["Graphics.BufferType"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');

        this.setColour('#8BBD83');
        this.setTooltip('Gets the value of a vertex\'s attribute.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.getVertexProperty');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_getVertexProperty'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.getVertexProperty(${_index},${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_setVertexProperty'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.setVertexProperty')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('Graphics.BufferType')
            .appendField('value');

        this.setColour('#8BBD83');
        this.setTooltip('Sets the value of a vertex\'s attribute.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.setVertexProperty');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_setVertexProperty'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.setVertexProperty(${_index},${_name},${_value})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_getFace'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.getFace')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#8BBD83');
        this.setTooltip('Gets the vertex indices that make up a face.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.getFace');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_getFace'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`GraphicsMeshPart.getFace(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_scaleToFit'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.scaleToFit')
        // Returns data
        this.setOutput(true, '["Graphics.MeshExtents"]');

        // Params data
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');

        this.setColour('#8BBD83');
        this.setTooltip('Scales the mesh to so that it\'s maximum model coordinate dimension is a specified length.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.scaleToFit');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_scaleToFit'] = (block, generator) => {
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`GraphicsMeshPart.scaleToFit(${_scale})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_translate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.translate')
        // Returns data
        this.setOutput(true, '["Graphics.MeshExtents"]');

        // Params data
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setColour('#8BBD83');
        this.setTooltip('Translates the mesh part.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.translate');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_translate'] = (block, generator) => {
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.translate(${_translation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_scale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.scale')
        // Returns data
        this.setOutput(true, '["Graphics.MeshExtents"]');

        // Params data
        this.appendValueInput('scale') 
            .setCheck('Vec3')
            .appendField('scale');
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');

        this.setColour('#8BBD83');
        this.setTooltip('Scales the mesh part.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.scale');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_scale'] = (block, generator) => {
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.scale(${_scale},${_origin})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_rotateDegrees'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.rotateDegrees')
        // Returns data
        this.setOutput(true, '["Graphics.MeshExtents"]');

        // Params data
        this.appendValueInput('eulerAngles') 
            .setCheck('Vec3')
            .appendField('eulerAngles');
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');

        this.setColour('#8BBD83');
        this.setTooltip('Rotates the mesh part, using Euler angles.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.rotateDegrees');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_rotateDegrees'] = (block, generator) => {
    const _eulerAngles = dfv(generator.valueToCode(block, 'eulerAngles', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.rotateDegrees(${_eulerAngles},${_origin})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_rotate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.rotate')
        // Returns data
        this.setOutput(true, '["Graphics.MeshExtents"]');

        // Params data
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');

        this.setColour('#8BBD83');
        this.setTooltip('Rotates the mesh part, using a quaternion.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.rotate');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_rotate'] = (block, generator) => {
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.rotate(${_rotation},${_origin})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_transform'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.transform')
        // Returns data
        this.setOutput(true, '["Graphics.MeshExtents"]');

        // Params data
        this.appendValueInput('transform') 
            .setCheck('Mat4')
            .appendField('transform');

        this.setColour('#8BBD83');
        this.setTooltip('Scales, rotates, and translates the mesh.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.transform');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_transform'] = (block, generator) => {
    const _transform = dfv(generator.valueToCode(block, 'transform', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.transform(${_transform})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_fillAttribute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.fillAttribute')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('Graphics.BufferType')
            .appendField('value');

        this.setColour('#8BBD83');
        this.setTooltip('Sets the value of an attribute for all vertices in the <em>whole</em> mesh (i.e., parent and mesh parts).');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.fillAttribute');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_fillAttribute'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.fillAttribute(${_name},${_value})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPArt_removeAttribute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPArt.removeAttribute')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');

        this.setColour('#8D46C2');
        this.setTooltip('Removes an attribute from all vertices in the <em>whole</em> mesh (i.e., parent and mesh parts).<p>Note: The <code>"position"</code> attribute cannot be removed.</p>');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPArt.html#.removeAttribute');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPArt_removeAttribute'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPArt.removeAttribute(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_dedupeVertices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.dedupeVertices')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('epsilon') 
            .setCheck('Number')
            .appendField('epsilon');

        this.setColour('#8BBD83');
        this.setTooltip('Deduplicates vertices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.dedupeVertices');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_dedupeVertices'] = (block, generator) => {
    const _epsilon = dfv(generator.valueToCode(block, 'epsilon', javascript.javascriptGenerator.ORDER_ATOMIC), `1e-6`);

return [`GraphicsMeshPart.dedupeVertices(${_epsilon})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_getParentMesh'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.getParentMesh')
        // Returns data
        this.setOutput(true, '["GraphicsMesh"]');

        // Params data

        this.setColour('#8BBD83');
        this.setTooltip('Gets the parent mesh.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.getParentMesh');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_getParentMesh'] = (block, generator) => {

return [`GraphicsMeshPart.getParentMesh()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_replaceMeshPartData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.replaceMeshPartData')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('source') 
            .setCheck('GrphicsMeshPart')
            .appendField('source');
        this.appendValueInput('attributes') 
            .setCheck('Array')
            .appendField('attributes');

        this.setColour('#8BBD83');
        this.setTooltip('Replaces a mesh part with a copy of another mesh part.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.replaceMeshPartData');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_replaceMeshPartData'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _attributes = dfv(generator.valueToCode(block, 'attributes', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.replaceMeshPartData(${_source},${_attributes})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_cloneMeshPart'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.cloneMeshPart')
        // Returns data
        this.setOutput(true, '["GraphicsMeshPart"]');

        // Params data

        this.setColour('#8BBD83');
        this.setTooltip('Makes a copy of the mesh part.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.cloneMeshPart');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_cloneMeshPart'] = (block, generator) => {

return [`GraphicsMeshPart.cloneMeshPart()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_toOBJ'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.toOBJ')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#8BBD83');
        this.setTooltip('Exports the mesh part to OBJ format.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.toOBJ');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_toOBJ'] = (block, generator) => {

return [`GraphicsMeshPart.toOBJ()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_updateVertexAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.updateVertexAttributes')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('callback') 
            .setCheck('GraphicsMesh~updateVertexAttributesCallback')
            .appendField('callback');

        this.setColour('#8BBD83');
        this.setTooltip('Updates vertex attributes by calling a function for each vertex in the <em>whole</em> mesh (i.e., the parent and mesh parts). The function can return modified attributes to update the vertex with.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.updateVertexAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_updateVertexAttributes'] = (block, generator) => {
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.updateVertexAttributes(${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPArt_forEachVertex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPArt.forEachVertex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('callback') 
            .setCheck('GraphicsMesh~forEachVertexCallback')
            .appendField('callback');

        this.setColour('#8D46C2');
        this.setTooltip('Calls a function for each vertex in the <em>whole</em> mesh (i.e., parent and mesh parts).');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPArt.html#.forEachVertex');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPArt_forEachVertex'] = (block, generator) => {
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPArt.forEachVertex(${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_isValidIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.isValidIndex')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('attribute') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('attribute');

        this.setColour('#8BBD83');
        this.setTooltip('Checks if an index is valid and, optionally, that vertex has a particular attribute.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.isValidIndex');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_isValidIndex'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _attribute = dfv(generator.valueToCode(block, 'attribute', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.isValidIndex(${_index},${_attribute})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['GraphicsModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsModel')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('objectID') 
            .setCheck('Uuid')
            .appendField('objectID');
        this.appendValueInput('numMeshes') 
            .setCheck('Number')
            .appendField('numMeshes');
        this.appendValueInput('meshes') 
            .setCheck('Array')
            .appendField('meshes');
        this.appendValueInput('materialNames') 
            .setCheck('Array')
            .appendField('materialNames');
        this.appendValueInput('materialLayers') 
            .setCheck('Array')
            .appendField('materialLayers');
        this.setColour('#383EEC');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>A handle to in-memory model data such as may be used in displaying avatars, 3D entities, or 3D overlays in the rendered scene. Changes made to the model are visible only to yourself; they are not persisted.<p>Note: The model may be used for more than one instance of an item displayed in the scene. Modifying the model updates all instances displayed.</p><p>Create using the {@link Graphics} API or {@link GraphicsModel.cloneModel}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsModel');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsModel'] = (block, generator) => {
    const _objectID = dfv(generator.valueToCode(block, 'objectID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _numMeshes = dfv(generator.valueToCode(block, 'numMeshes', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _meshes = dfv(generator.valueToCode(block, 'meshes', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _materialNames = dfv(generator.valueToCode(block, 'materialNames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _materialLayers = dfv(generator.valueToCode(block, 'materialLayers', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new GraphicsModel(${_objectID},${_numMeshes},${_meshes},${_materialNames},${_materialLayers})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['GraphicsModel_cloneModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsModel.cloneModel')
        // Returns data
        this.setOutput(true, '["GraphicsModel"]');

        // Params data
        this.appendValueInput('options') 
            .setCheck('object')
            .appendField('options');

        this.setColour('#383EEC');
        this.setTooltip('Makes a copy of the model.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsModel.html#.cloneModel');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsModel_cloneModel'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsModel.cloneModel(${_options})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsModel_toString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsModel.toString')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#383EEC');
        this.setTooltip('Gets a string description of the model.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsModel.html#.toString');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsModel_toString'] = (block, generator) => {

return [`GraphicsModel.toString()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['TextureCache_TextureType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.TextureType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#CFB8C8');
        this.setTooltip('<p>Describes the type of texture.</p><p>See also: {@link Material} and{@link https://docs.overte.org/create/3d-models/pbr-materials-guide.html|PBR Materials Guide}.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>Default</td><td>Basic color.</td></tr>    <tr><td><code>1</code></td><td>Strict</td><td>Basic color. Quality never downgraded.</td></tr>    <tr><td><code>2</code></td><td>Albedo</td><td>Color for PBR.</td></tr>    <tr><td><code>3</code></td><td>Normal</td><td>Normal map.</td></tr>    <tr><td><code>4</code></td><td>Bump</td><td>Bump map.</td></tr>    <tr><td><code>5</code></td><td>Specular or metallic</td><td>Metallic or not.</td></tr>    <tr><td><code>6</code></td><td>Roughness</td><td>Rough or matte.</td></tr>    <tr><td><code>7</code></td><td>Gloss</td><td>Gloss or shine.</td></tr>    <tr><td><code>8</code></td><td>Emissive</td><td>The amount of light reflected.</td></tr>    <tr><td><code>9</code></td><td>Cube</td><td>Cubic image for sky boxes.</td></tr>    <tr><td><code>10</code></td><td>Occlusion or scattering</td><td>How objects or human skin interact with light.</td></tr>    <tr><td><code>11</code></td><td>Lightmap</td><td>Light map.</td></tr>    <tr><td><code>12</code></td><td>Unused</td><td>Texture is not currently used.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.TextureType');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_TextureType'] = (block, generator) => {

    return [`new TextureCache.TextureType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_Hardware-Keyboard'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hardware-Keyboard')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Hardware.Keyboard</code> object has properties representing keyboard, mouse, and display touch events. The property values are integer IDs, uniquely identifying each output. <em>Read-only.</em></p><p>These events can be mapped to actions or functions or <code>Controller.Standard</code> items in a {@link RouteObject}mapping. For presses, each data value is either <code>1.0</code> for "true" or <code>0.0</code> for "false".</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Data</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code> &ndash; <code>9</code></td><td>number</td><td>number</td><td>A "0" &ndash; "1" key on the       keyboard or keypad is pressed.</td></tr>    <tr><td><code>A</code> &ndash; <code>Z</code></td><td>number</td><td>number</td><td>A "A" &ndash; "Z" key on the       keyboard is pressed.</td></tr>    <tr><td><code>Space</code></td><td>number</td><td>number</td><td>The space bar on the keyboard is pressed.</td></tr>    <tr><td><code>Tab</code></td><td>number</td><td>number</td><td>The tab key on the keyboard is pressed.</td></tr>    <tr><td><code>Shift</code></td><td>number</td><td>number</td><td>The shift key on the keyboard is pressed.</td></tr>    <tr><td><code>Control</code></td><td>number</td><td>number</td><td>The control key on the keyboard is pressed. (The       "Command" key on OSX.)</td></tr>    <tr><td><code>Left</code></td><td>number</td><td>number</td><td>The left arrow key on the keyboard or keypad is pressed.      </td></tr>    <tr><td><code>Right</code></td><td>number</td><td>number</td><td>The right arrow key on the keyboard or keypad is       pressed.</td></tr>    <tr><td><code>Up</code></td><td>number</td><td>number</td><td>The up arrow key on the keyboard or keypad is pressed.      </td></tr>    <tr><td><code>Down</code></td><td>number</td><td>number</td><td>The down arrow key on the keyboard or keypad is pressed.      </td></tr>    <tr><td><code>PgUp</code></td><td>number</td><td>number</td><td>The page up key on the keyboard or keypad is pressed.      </td></tr>    <tr><td><code>PgDown</code></td><td>number</td><td>number</td><td>The page down key on the keyboard or keypad is pressed.      </td></tr>    <tr><td><code>LeftMouseButton</code></td><td>number</td><td>number</td><td>The left mouse button is pressed.</td></tr>    <tr><td><code>MiddleMouseButton</code></td><td>number</td><td>number</td><td>The middle mouse button is pressed.      </td></tr>    <tr><td><code>RightMouseButton</code></td><td>number</td><td>number</td><td>The right mouse button is pressed.</td></tr>    <tr><td><code>LeftMouseClicked</code></td><td>number</td><td>number</td><td>The left mouse button was clicked.</td></tr>    <tr><td><code>MiddleMouseClicked</code></td><td>number</td><td>number</td><td>The middle mouse button was clicked.      </td></tr>    <tr><td><code>RightMouseClicked</code></td><td>number</td><td>number</td><td>The right mouse button was clicked.      </td></tr>    <tr><td><code>MouseMoveRight</code></td><td>number</td><td>number</td><td>The mouse moved right. The data value is how       far it moved.</td></tr>    <tr><td><code>MouseMoveLeft</code></td><td>number</td><td>number</td><td>The mouse moved left. The data value is how far       it moved.</td></tr>    <tr><td><code>MouseMoveUp</code></td><td>number</td><td>number</td><td>The mouse moved up. The data value is how far it       moved.</td></tr>    <tr><td><code>MouseMoveDown</code></td><td>number</td><td>number</td><td>The mouse moved down. The data value is how far       it moved.</td></tr>    <tr><td><code>MouseX</code></td><td>number</td><td>number</td><td>The mouse x-coordinate changed. The data value is its       new x-coordinate value.</td></tr>    <tr><td><code>MouseY</code></td><td>number</td><td>number</td><td>The mouse y-coordinate changed. The data value is its       new y-coordinate value.</td></tr>    <tr><td><code>MouseWheelRight</code></td><td>number</td><td>number</td><td>The mouse wheel rotated right or two-finger       swipe moved right. The data value is the number of units moved (typically <code>1.0</code>).</td></tr>    <tr><td><code>MouseWheelLeft</code></td><td>number</td><td>number</td><td>The mouse wheel rotated left or two-finger       swipe moved left. The data value is the number of units moved (typically <code>1.0</code>).</td></tr>    <tr><td><code>MouseWheelUp</code></td><td>number</td><td>number</td><td>The mouse wheel rotated up or two-finger swipe       moved up. The data value is the number of units move3d (typically <code>1.0</code>).      <p><strong>Warning:</strong> The mouse wheel in an ordinary mouse generates left/right wheel events instead of       up/down.</p>      </td></tr>    <tr><td><code>MouseWheelDown</code></td><td>number</td><td>number</td><td>The mouse wheel rotated down or two-finger       swipe moved down. The data value is the number of units moved (typically <code>1.0</code>).      <p><strong>Warning:</strong> The mouse wheel in an ordinary mouse generates left/right wheel events instead of       up/down.</p>      </td></tr>    <tr><td><code>TouchpadRight</code></td><td>number</td><td>number</td><td>The average touch on a touch-enabled device       moved right. The data value is how far the average position of all touch points moved.</td></tr>    <tr><td><code>TouchpadLeft</code></td><td>number</td><td>number</td><td>The average touch on a touch-enabled device       moved left. The data value is how far the average position of all touch points moved.</td></tr>    <tr><td><code>TouchpadUp</code></td><td>number</td><td>number</td><td>The average touch on a touch-enabled device       moved up. The data value is how far the average position of all touch points moved.</td></tr>    <tr><td><code>TouchpadDown</code></td><td>number</td><td>number</td><td>The average touch on a touch-enabled device       moved down. The data value is how far the average position of all touch points moved.</td></tr>    <tr><td><code>GesturePinchOut</code></td><td>number</td><td>number</td><td>The average of two touches on a touch-enabled       device moved out. The data value is how far the average positions of the touch points moved out.</td></tr>    <tr><td><code>GesturePinchOut</code></td><td>number</td><td>number</td><td>The average of two touches on a touch-enabled      device moved in. The data value is how far the average positions of the touch points moved in.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hardware-Keyboard');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hardware-Keyboard'] = (block, generator) => {

    return [`new Controller.Hardware-Keyboard()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Window_DisplayTexture'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.DisplayTexture')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#C89686');
        this.setTooltip('<p>The views that may be visible on the PC display.</p><table>  <thead>    <tr>      <th>Value</th>      <th>View Displayed</th>    </tr>  </thead>  <tbody>    <tr>      <td><code>""</code></td>      <td>Normal view.</td>    </tr>    <tr>      <td><code>"resource://hmdPreviewFrame"</code></td>      <td>HMD preview.</td>    </tr>    <tr>      <td><code>"resource://spectatorCameraFrame"</code></td>      <td>Entity camera view.</td>    </tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.DisplayTexture');
    }
};
javascript.javascriptGenerator.forBlock['Window_DisplayTexture'] = (block, generator) => {

    return [`new Window.DisplayTexture()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['TextureCache_numTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.numTotal')       
        this.setOutput(true, '');
        this.setColour('#CFB8C8');
        this.setTooltip('Total number of total resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.numTotal');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_numTotal'] = (block, generator) => {
    return [`TextureCache.numTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['TextureCache_numCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.numCached')       
        this.setOutput(true, '');
        this.setColour('#CFB8C8');
        this.setTooltip('Total number of cached resource. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.numCached');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_numCached'] = (block, generator) => {
    return [`TextureCache.numCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['TextureCache_sizeTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.sizeTotal')       
        this.setOutput(true, '');
        this.setColour('#CFB8C8');
        this.setTooltip('Size in bytes of all resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.sizeTotal');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_sizeTotal'] = (block, generator) => {
    return [`TextureCache.sizeTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['TextureCache_sizeCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.sizeCached')       
        this.setOutput(true, '');
        this.setColour('#CFB8C8');
        this.setTooltip('Size in bytes of all cached resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.sizeCached');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_sizeCached'] = (block, generator) => {
    return [`TextureCache.sizeCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['TextureCache_numGlobalQueriesPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.numGlobalQueriesPending')       
        this.setOutput(true, '');
        this.setColour('#CFB8C8');
        this.setTooltip('Total number of global queries pending (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.numGlobalQueriesPending');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_numGlobalQueriesPending'] = (block, generator) => {
    return [`TextureCache.numGlobalQueriesPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['TextureCache_numGlobalQueriesLoading'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.numGlobalQueriesLoading')       
        this.setOutput(true, '');
        this.setColour('#CFB8C8');
        this.setTooltip('Total number of global queries loading (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.numGlobalQueriesLoading');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_numGlobalQueriesLoading'] = (block, generator) => {
    return [`TextureCache.numGlobalQueriesLoading`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['TextureCache_prefetch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('type') 
            .setCheck('TextureCache.TextureType')
            .appendField('type');
        this.appendValueInput('maxNumPixels') 
            .setCheck('Number')
            .appendField('maxNumPixels');

        this.setColour('#CFB8C8');
        this.setTooltip('Prefetches a texture resource of specific type.');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_prefetch'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _maxNumPixels = dfv(generator.valueToCode(block, 'maxNumPixels', javascript.javascriptGenerator.ORDER_ATOMIC), `67108864`);

return [`TextureCache.prefetch(${_url},${_type},${_maxNumPixels})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Midi_MidiMessage'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.MidiMessage')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('device') 
            .setCheck('Number')
            .appendField('device');
        this.appendValueInput('raw') 
            .setCheck('Midi.RawMidiMessage')
            .appendField('raw');
        this.appendValueInput('status') 
            .setCheck('Number')
            .appendField('status');
        this.appendValueInput('channel') 
            .setCheck('Number')
            .appendField('channel');
        this.appendValueInput('type') 
            .setCheck('Number')
            .appendField('type');
        this.appendValueInput('note') 
            .setCheck('Number')
            .appendField('note');
        this.appendValueInput('velocity') 
            .setCheck('Number')
            .appendField('velocity');
        this.appendValueInput('bend') 
            .setCheck('Number')
            .appendField('bend');
        this.appendValueInput('program') 
            .setCheck('Number')
            .appendField('program');
        this.setColour('#3FEC52');
        this.setTooltip('A MIDI message.<p><strong>Warning:</strong> The <code>status</code> property is NOT a MIDI status value.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.MidiMessage');
    }
};
javascript.javascriptGenerator.forBlock['Midi_MidiMessage'] = (block, generator) => {
    const _device = dfv(generator.valueToCode(block, 'device', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _raw = dfv(generator.valueToCode(block, 'raw', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _status = dfv(generator.valueToCode(block, 'status', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _note = dfv(generator.valueToCode(block, 'note', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _bend = dfv(generator.valueToCode(block, 'bend', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _program = dfv(generator.valueToCode(block, 'program', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Midi.MidiMessage(${_device},${_raw},${_status},${_channel},${_type},${_note},${_velocity},${_bend},${_program})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Midi_RawMidiMessage'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.RawMidiMessage')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#3FEC52');
        this.setTooltip('An integer DWORD (unsigned 32 bit) message with bits having values as follows:<table>  <tbody>    <tr>      <td width=25%><code>00000000</code></td>      <td width=25%><code>0vvvvvvv</code></td>      <td width=25%><code>0nnnnnnn</code></td>      <td width=12%><code>1sss</code></td>      <td width=12%><code>cccc</code></td>  </tbody></table><p>Where:</p><ul>  <li><code>v</code> = Velocity.  <li><code>n</code> = Note.  <li><code>s</code> = Status - {@link Midi.MidiStatus}  <li><code>c</code> = Channel.</ul><p>The number in the first bit of each byte denotes whether it is a command (1) or data .');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.RawMidiMessage');
    }
};
javascript.javascriptGenerator.forBlock['Midi_RawMidiMessage'] = (block, generator) => {

    return [`new Midi.RawMidiMessage()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Midi_MidiStatus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.MidiStatus')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#3FEC52');
        this.setTooltip('<p>A MIDI status value. The following MIDI status values are supported:</p><table>  <thead>    <tr><th>Value</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>8</code></td><td>Note off.</td></tr>    <tr><td><code>9</code></td><td>Note on.</td></tr>    <tr><td><code>10</code></td><td>Polyphonic key pressure.</td></tr>    <tr><td><code>11</code></td><td>Control change.</td></tr>    <tr><td><code>12</code></td><td>Program change.</td></tr>    <tr><td><code>13</code></td><td>Channel pressure.</td></tr>    <tr><td><code>14</code></td><td>Pitch bend.</td></tr>    <tr><td><code>15</code></td><td>System message.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.MidiStatus');
    }
};
javascript.javascriptGenerator.forBlock['Midi_MidiStatus'] = (block, generator) => {

    return [`new Midi.MidiStatus()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly signal
Blockly.Blocks['Midi_midiMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Midi.midiMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('midiMessage_message'), 'message');

        this.setColour('#3FEC52');
        this.setTooltip('Triggered when a connected device sends an output.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.midiMessage');
    }
};
javascript.javascriptGenerator.forBlock['Midi_midiMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `Midi.midiMessage.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Midi_midiReset'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Midi.midiReset');


        this.setColour('#3FEC52');
        this.setTooltip('Triggered when the system detects there was a reset such as when a device is plugged in or unplugged.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.midiReset');
    }
};
javascript.javascriptGenerator.forBlock['Midi_midiReset'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Midi.midiReset.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['Midi_sendRawDword'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.sendRawDword')
        // Returns data

        // Params data
        this.appendValueInput('device') 
            .setCheck('Number')
            .appendField('device');
        this.appendValueInput('raw') 
            .setCheck('Midi.RawMidiMessage')
            .appendField('raw');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Sends a raw MIDI packet to a particular device.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.sendRawDword');
    }
};
javascript.javascriptGenerator.forBlock['Midi_sendRawDword'] = (block, generator) => {
    const _device = dfv(generator.valueToCode(block, 'device', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _raw = dfv(generator.valueToCode(block, 'raw', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Midi.sendRawDword(${_device},${_raw});\n`;};


// Blockly function
Blockly.Blocks['Midi_sendMidiMessage'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.sendMidiMessage')
        // Returns data

        // Params data
        this.appendValueInput('device') 
            .setCheck('Number')
            .appendField('device');
        this.appendValueInput('channel') 
            .setCheck('Number')
            .appendField('channel');
        this.appendValueInput('type') 
            .setCheck('Midi.MidiStatus')
            .appendField('type');
        this.appendValueInput('note') 
            .setCheck('Number')
            .appendField('note');
        this.appendValueInput('velocity') 
            .setCheck('Number')
            .appendField('velocity');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Sends a MIDI message to a particular device.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.sendMidiMessage');
    }
};
javascript.javascriptGenerator.forBlock['Midi_sendMidiMessage'] = (block, generator) => {
    const _device = dfv(generator.valueToCode(block, 'device', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _note = dfv(generator.valueToCode(block, 'note', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Midi.sendMidiMessage(${_device},${_channel},${_type},${_note},${_velocity});\n`;};


// Blockly function
Blockly.Blocks['Midi_playMidiNote'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.playMidiNote')
        // Returns data

        // Params data
        this.appendValueInput('status') 
            .setCheck('MidiStatus')
            .appendField('status');
        this.appendValueInput('note') 
            .setCheck('Number')
            .appendField('note');
        this.appendValueInput('velocity') 
            .setCheck('Number')
            .appendField('velocity');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Plays a note on all connected devices.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.playMidiNote');
    }
};
javascript.javascriptGenerator.forBlock['Midi_playMidiNote'] = (block, generator) => {
    const _status = dfv(generator.valueToCode(block, 'status', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _note = dfv(generator.valueToCode(block, 'note', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Midi.playMidiNote(${_status},${_note},${_velocity});\n`;};


// Blockly function
Blockly.Blocks['Midi_allNotesOff'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.allNotesOff')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Turns off all notes on all connected MIDI devices.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.allNotesOff');
    }
};
javascript.javascriptGenerator.forBlock['Midi_allNotesOff'] = (block, generator) => {


    return `Midi.allNotesOff();\n`;};


// Blockly function
Blockly.Blocks['Midi_resetDevices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.resetDevices')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Cleans up and rediscovers attached MIDI devices.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.resetDevices');
    }
};
javascript.javascriptGenerator.forBlock['Midi_resetDevices'] = (block, generator) => {


    return `Midi.resetDevices();\n`;};


// Blockly function
Blockly.Blocks['Midi_listMidiDevices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.listMidiDevices')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('output') 
            .setCheck('Boolean')
            .appendField('output');

        this.setColour('#3FEC52');
        this.setTooltip('Gets a list of MIDI input or output devices.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.listMidiDevices');
    }
};
javascript.javascriptGenerator.forBlock['Midi_listMidiDevices'] = (block, generator) => {
    const _output = dfv(generator.valueToCode(block, 'output', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`Midi.listMidiDevices(${_output})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Midi_blockMidiDevice'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.blockMidiDevice')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('output') 
            .setCheck('Boolean')
            .appendField('output');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Blocks a MIDI device\'s input or output.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.blockMidiDevice');
    }
};
javascript.javascriptGenerator.forBlock['Midi_blockMidiDevice'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _output = dfv(generator.valueToCode(block, 'output', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.blockMidiDevice(${_name},${_output});\n`;};


// Blockly function
Blockly.Blocks['Midi_unblockMidiDevice'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.unblockMidiDevice')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('output') 
            .setCheck('Boolean')
            .appendField('output');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Unblocks a MIDI device\'s input or output.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.unblockMidiDevice');
    }
};
javascript.javascriptGenerator.forBlock['Midi_unblockMidiDevice'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _output = dfv(generator.valueToCode(block, 'output', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.unblockMidiDevice(${_name},${_output});\n`;};


// Blockly function
Blockly.Blocks['Midi_thruModeEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.thruModeEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables repeating all incoming notes to all outputs. (Default is disabled.)');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.thruModeEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_thruModeEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.thruModeEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_broadcastEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.broadcastEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables broadcasts to all unblocked devices.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.broadcastEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_broadcastEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.broadcastEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typeNoteOffEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typeNoteOffEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables note off events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typeNoteOffEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typeNoteOffEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typeNoteOffEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typeNoteOnEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typeNoteOnEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables note on events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typeNoteOnEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typeNoteOnEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typeNoteOnEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typePolyKeyPressureEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typePolyKeyPressureEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables poly key pressure events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typePolyKeyPressureEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typePolyKeyPressureEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typePolyKeyPressureEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typeControlChangeEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typeControlChangeEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables control change events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typeControlChangeEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typeControlChangeEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typeControlChangeEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typeProgramChangeEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typeProgramChangeEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables program change events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typeProgramChangeEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typeProgramChangeEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typeProgramChangeEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typeChanPressureEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typeChanPressureEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables channel pressure events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typeChanPressureEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typeChanPressureEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typeChanPressureEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typePitchBendEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typePitchBendEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables pitch bend events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typePitchBendEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typePitchBendEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typePitchBendEnable(${_enable});\n`;};


// Blockly function
Blockly.Blocks['Midi_typeSystemMessageEnable'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Midi.typeSystemMessageEnable')
        // Returns data

        // Params data
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#3FEC52');
        this.setTooltip('Enables or disables system message events.');
        this.setHelpUrl('https://apidocs.overte.org/Midi.html#.typeSystemMessageEnable');
    }
};
javascript.javascriptGenerator.forBlock['Midi_typeSystemMessageEnable'] = (block, generator) => {
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Midi.typeSystemMessageEnable(${_enable});\n`;};


// Blockly namespace
Blockly.Blocks['ModelCache_numTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.numTotal')       
        this.setOutput(true, '');
        this.setColour('#C1E06C');
        this.setTooltip('Total number of total resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.numTotal');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_numTotal'] = (block, generator) => {
    return [`ModelCache.numTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ModelCache_numCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.numCached')       
        this.setOutput(true, '');
        this.setColour('#C1E06C');
        this.setTooltip('Total number of cached resource. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.numCached');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_numCached'] = (block, generator) => {
    return [`ModelCache.numCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ModelCache_sizeTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.sizeTotal')       
        this.setOutput(true, '');
        this.setColour('#C1E06C');
        this.setTooltip('Size in bytes of all resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.sizeTotal');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_sizeTotal'] = (block, generator) => {
    return [`ModelCache.sizeTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ModelCache_sizeCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.sizeCached')       
        this.setOutput(true, '');
        this.setColour('#C1E06C');
        this.setTooltip('Size in bytes of all cached resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.sizeCached');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_sizeCached'] = (block, generator) => {
    return [`ModelCache.sizeCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ModelCache_numGlobalQueriesPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.numGlobalQueriesPending')       
        this.setOutput(true, '');
        this.setColour('#C1E06C');
        this.setTooltip('Total number of global queries pending (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.numGlobalQueriesPending');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_numGlobalQueriesPending'] = (block, generator) => {
    return [`ModelCache.numGlobalQueriesPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ModelCache_numGlobalQueriesLoading'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.numGlobalQueriesLoading')       
        this.setOutput(true, '');
        this.setColour('#C1E06C');
        this.setTooltip('Total number of global queries loading (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.numGlobalQueriesLoading');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_numGlobalQueriesLoading'] = (block, generator) => {
    return [`ModelCache.numGlobalQueriesLoading`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_domainID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.domainID')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('A UUID uniquely identifying the domain you\'re visiting. Is {@link Uuid|Uuid.NULL} if you\'re not    connected to the domain or are in a serverless domain.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.domainID');
    }
};
javascript.javascriptGenerator.forBlock['location_domainID'] = (block, generator) => {
    return [`location.domainID`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_hostname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.hostname')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('The name of the domain for your current directory services address (e.g., <code>"DomainName"</code>,    <code>localhost</code>, or an IP address). Is blank if you\'re in a serverless domain.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.hostname');
    }
};
javascript.javascriptGenerator.forBlock['location_hostname'] = (block, generator) => {
    return [`location.hostname`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_href'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.href')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('Your current directory services address (e.g., <code>"hifi://domainname/15,-10,26/0,0,0,1"</code>)    regardless of whether or not you\'re connected to the domain. Starts with <code>"file:///"</code> if you\'re in a    serverless domain.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.href');
    }
};
javascript.javascriptGenerator.forBlock['location_href'] = (block, generator) => {
    return [`location.href`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_isConnected'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.isConnected')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('<code>true</code> if you\'re connected to the domain in your current <code>href</code>    directory services address, otherwise <code>false</code>.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.isConnected');
    }
};
javascript.javascriptGenerator.forBlock['location_isConnected'] = (block, generator) => {
    return [`location.isConnected`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_pathname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.pathname')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('The location and orientation in your current <code>href</code> directory services address    (e.g., <code>"/15,-10,26/0,0,0,1"</code>).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.pathname');
    }
};
javascript.javascriptGenerator.forBlock['location_pathname'] = (block, generator) => {
    return [`location.pathname`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_placename'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.placename')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('The place name in your current <code>href</code> directory services address    (e.g., <code>"DomainName"</code>). Is blank if your <code>hostname</code> is an IP address.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.placename');
    }
};
javascript.javascriptGenerator.forBlock['location_placename'] = (block, generator) => {
    return [`location.placename`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['location_protocol'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.protocol')       
        this.setOutput(true, '');
        this.setColour('#D5189D');
        this.setTooltip('The protocol of your current <code>href</code> directory services address (e.g., <code>"hifi"</code>).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.protocol');
    }
};
javascript.javascriptGenerator.forBlock['location_protocol'] = (block, generator) => {
    return [`location.protocol`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly typedef
Blockly.Blocks['location_LookupTrigger'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.LookupTrigger')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#D5189D');
        this.setTooltip('<p>The reasons for an address lookup via the Directory Services API are defined by numeric values:</p><table>  <thead>    <tr>      <th>Name</th>      <th>Value</th>      <th>Description</th>    </tr>  </thead>  <tbody>    <tr>      <td><strong>UserInput</strong></td>      <td><code>0</code></td>      <td>User-typed input.</td>    </tr>    <tr>      <td><strong>Back</strong></td>      <td><code>1</code></td>      <td>Address from a {@link location.goBack|goBack} call.</td>    </tr>    <tr>      <td><strong>Forward</strong></td>      <td><code>2</code></td>      <td>Address from a {@link location.goForward|goForward} call.</td>    </tr>    <tr>      <td><strong>StartupFromSettings</strong></td>      <td><code>3</code></td>      <td>Initial location at Interface start-up from settings.</td>    </tr>    <tr>      <td><strong>DomainPathResponse</strong></td>      <td><code>4</code></td>      <td>A named path in the domain.</td>    </tr>    <tr>      <td><strong>Internal</strong></td>      <td><code>5</code></td>      <td>An internal attempt to resolve an alternative path.</td>    </tr>    <tr>      <td><strong>AttemptedRefresh</strong></td>      <td><code>6</code></td>      <td>A refresh after connecting to a domain.</td>    </tr>    <tr>      <td><strong>Suggestions</strong></td>      <td><code>7</code></td>      <td>Address from the Goto dialog.</td>    </tr>    <tr>      <td><strong>VisitUserFromPAL</strong></td>      <td><code>8</code></td>      <td>User from the People dialog.</td>    </tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.LookupTrigger');
    }
};
javascript.javascriptGenerator.forBlock['location_LookupTrigger'] = (block, generator) => {

    return [`new location.LookupTrigger()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['location_handleLookupString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.handleLookupString')
        // Returns data

        // Params data
        this.appendValueInput('address') 
            .setCheck('String')
            .appendField('address');
        this.appendValueInput('fromSuggestions') 
            .setCheck('Boolean')
            .appendField('fromSuggestions');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you to a specified directory services address.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.handleLookupString');
    }
};
javascript.javascriptGenerator.forBlock['location_handleLookupString'] = (block, generator) => {
    const _address = dfv(generator.valueToCode(block, 'address', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fromSuggestions = dfv(generator.valueToCode(block, 'fromSuggestions', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `location.handleLookupString(${_address},${_fromSuggestions});\n`;};


// Blockly function
Blockly.Blocks['location_goBack'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.goBack')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you back to the previous location in your navigation history, if there is one.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goBack');
    }
};
javascript.javascriptGenerator.forBlock['location_goBack'] = (block, generator) => {


    return `location.goBack();\n`;};


// Blockly function
Blockly.Blocks['location_goForward'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.goForward')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you forward to the next location in your navigation history, if there is one.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goForward');
    }
};
javascript.javascriptGenerator.forBlock['location_goForward'] = (block, generator) => {


    return `location.goForward();\n`;};


// Blockly function
Blockly.Blocks['location_goToLocalSandbox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.goToLocalSandbox')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('trigger') 
            .setCheck('location.LookupTrigger')
            .appendField('trigger');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you to the local Sandbox server that\'s running on the same PC as Interface.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goToLocalSandbox');
    }
};
javascript.javascriptGenerator.forBlock['location_goToLocalSandbox'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _trigger = dfv(generator.valueToCode(block, 'trigger', javascript.javascriptGenerator.ORDER_ATOMIC), `StartupFromSettings`);


    return `location.goToLocalSandbox(${_path},${_trigger});\n`;};


// Blockly function
Blockly.Blocks['location_goToEntry'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.goToEntry')
        // Returns data

        // Params data
        this.appendValueInput('trigger') 
            .setCheck('location.LookupTrigger')
            .appendField('trigger');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you to the default "welcome" directory services address.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goToEntry');
    }
};
javascript.javascriptGenerator.forBlock['location_goToEntry'] = (block, generator) => {
    const _trigger = dfv(generator.valueToCode(block, 'trigger', javascript.javascriptGenerator.ORDER_ATOMIC), `StartupFromSettings`);


    return `location.goToEntry(${_trigger});\n`;};


// Blockly function
Blockly.Blocks['location_goToUser'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.goToUser')
        // Returns data

        // Params data
        this.appendValueInput('username') 
            .setCheck('String')
            .appendField('username');
        this.appendValueInput('matchOrientation') 
            .setCheck('Boolean')
            .appendField('matchOrientation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you to the specified user\'s location.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goToUser');
    }
};
javascript.javascriptGenerator.forBlock['location_goToUser'] = (block, generator) => {
    const _username = dfv(generator.valueToCode(block, 'username', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _matchOrientation = dfv(generator.valueToCode(block, 'matchOrientation', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);


    return `location.goToUser(${_username},${_matchOrientation});\n`;};


// Blockly function
Blockly.Blocks['location_goToLastAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.goToLastAddress')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Takes you to the last address tried. This will be the last URL tried from <code>location.handleLookupString</code>.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goToLastAddress');
    }
};
javascript.javascriptGenerator.forBlock['location_goToLastAddress'] = (block, generator) => {


    return `location.goToLastAddress();\n`;};


// Blockly function
Blockly.Blocks['location_canGoBack'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.canGoBack')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#D5189D');
        this.setTooltip('Checks if going back to the previous location is possible.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.canGoBack');
    }
};
javascript.javascriptGenerator.forBlock['location_canGoBack'] = (block, generator) => {

return [`location.canGoBack()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['location_storeCurrentAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.storeCurrentAddress')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Updates your current directory services location in Interface\'s {@link Settings} file as your last-known address. This can be usedto ensure that you start up at that address if you exit Interface without a later address automatically being saved.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.storeCurrentAddress');
    }
};
javascript.javascriptGenerator.forBlock['location_storeCurrentAddress'] = (block, generator) => {


    return `location.storeCurrentAddress();\n`;};


// Blockly function
Blockly.Blocks['location_copyAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.copyAddress')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Copies your current directory services address (i.e., <code>location.href</code> property value) to the OS clipboard.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.copyAddress');
    }
};
javascript.javascriptGenerator.forBlock['location_copyAddress'] = (block, generator) => {


    return `location.copyAddress();\n`;};


// Blockly function
Blockly.Blocks['location_copyPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('location.copyPath')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#D5189D');
        this.setTooltip('Copies your current directory services location and orientation (i.e., <code>location.pathname</code> property value) to the OSclipboard.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.copyPath');
    }
};
javascript.javascriptGenerator.forBlock['location_copyPath'] = (block, generator) => {


    return `location.copyPath();\n`;};


// Blockly signal
Blockly.Blocks['location_lookupResultsFinished'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.lookupResultsFinished');


        this.setColour('#D5189D');
        this.setTooltip('Triggered when looking up the details of a directory services user or location to go to has completed (successfully orunsuccessfully).');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.lookupResultsFinished');
    }
};
javascript.javascriptGenerator.forBlock['location_lookupResultsFinished'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `location.lookupResultsFinished.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_lookupResultIsOffline'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.lookupResultIsOffline');


        this.setColour('#D5189D');
        this.setTooltip('Triggered when looking up the details of a directory services user or location to go to has completed and the domain or user isoffline.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.lookupResultIsOffline');
    }
};
javascript.javascriptGenerator.forBlock['location_lookupResultIsOffline'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `location.lookupResultIsOffline.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_lookupResultIsNotFound'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.lookupResultIsNotFound');


        this.setColour('#D5189D');
        this.setTooltip('Triggered when looking up the details of a directory services user or location to go to has completed and the domain or user couldnot be found.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.lookupResultIsNotFound');
    }
};
javascript.javascriptGenerator.forBlock['location_lookupResultIsNotFound'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `location.lookupResultIsNotFound.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_possibleDomainChangeRequired'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.possibleDomainChangeRequired');

        this.appendDummyInput('domainURL')
            .appendField('domainURL:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequired_domainURL'), 'domainURL');
        this.appendDummyInput('domainID')
            .appendField('domainID:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequired_domainID'), 'domainID');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when a request is made to go to a URL or IP address.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.possibleDomainChangeRequired');
    }
};
javascript.javascriptGenerator.forBlock['location_possibleDomainChangeRequired'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const domainURL = generator.getVariableName(block.getFieldValue('domainURL'));
    const domainID = generator.getVariableName(block.getFieldValue('domainID'));

return `location.possibleDomainChangeRequired.connect((_domainURL,_domainID) => { 
  ${domainURL} = _domainURL; 
  ${domainID} = _domainID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_possibleDomainChangeRequiredViaICEForID'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.possibleDomainChangeRequiredViaICEForID');

        this.appendDummyInput('iceServerHostName')
            .appendField('iceServerHostName:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequiredViaICEForID_iceServerHostName'), 'iceServerHostName');
        this.appendDummyInput('domainID')
            .appendField('domainID:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequiredViaICEForID_domainID'), 'domainID');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when a request is made to go to a named domain or user.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.possibleDomainChangeRequiredViaICEForID');
    }
};
javascript.javascriptGenerator.forBlock['location_possibleDomainChangeRequiredViaICEForID'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const iceServerHostName = generator.getVariableName(block.getFieldValue('iceServerHostName'));
    const domainID = generator.getVariableName(block.getFieldValue('domainID'));

return `location.possibleDomainChangeRequiredViaICEForID.connect((_iceServerHostName,_domainID) => { 
  ${iceServerHostName} = _iceServerHostName; 
  ${domainID} = _domainID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_locationChangeRequired'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.locationChangeRequired');

        this.appendDummyInput('position')
            .appendField('position:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_position'), 'position');
        this.appendDummyInput('hasOrientationChange')
            .appendField('hasOrientationChange:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_hasOrientationChange'), 'hasOrientationChange');
        this.appendDummyInput('orientation')
            .appendField('orientation:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_orientation'), 'orientation');
        this.appendDummyInput('shouldFaceLocation')
            .appendField('shouldFaceLocation:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_shouldFaceLocation'), 'shouldFaceLocation');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when an attempt is made to send your avatar to a specified position on the current domain. For example, whenyou change domains or enter a position to go to in the "Goto" dialog.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.locationChangeRequired');
    }
};
javascript.javascriptGenerator.forBlock['location_locationChangeRequired'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const position = generator.getVariableName(block.getFieldValue('position'));
    const hasOrientationChange = generator.getVariableName(block.getFieldValue('hasOrientationChange'));
    const orientation = generator.getVariableName(block.getFieldValue('orientation'));
    const shouldFaceLocation = generator.getVariableName(block.getFieldValue('shouldFaceLocation'));

return `location.locationChangeRequired.connect((_position,_hasOrientationChange,_orientation,_shouldFaceLocation) => { 
  ${position} = _position; 
  ${hasOrientationChange} = _hasOrientationChange; 
  ${orientation} = _orientation; 
  ${shouldFaceLocation} = _shouldFaceLocation;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_pathChangeRequired'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.pathChangeRequired');

        this.appendDummyInput('path')
            .appendField('path:')
            .appendField(new Blockly.FieldVariable('pathChangeRequired_path'), 'path');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when an attempt is made to send your avatar to a new named path on the domain (set in the domain server\'ssettings). For example, when you enter a "/" followed by the path\'s name in the "GOTO" dialog.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.pathChangeRequired');
    }
};
javascript.javascriptGenerator.forBlock['location_pathChangeRequired'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const path = generator.getVariableName(block.getFieldValue('path'));

return `location.pathChangeRequired.connect((_path) => { 
  ${path} = _path;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_hostChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.hostChanged');

        this.appendDummyInput('hostname')
            .appendField('hostname:')
            .appendField(new Blockly.FieldVariable('hostChanged_hostname'), 'hostname');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when you navigate to a new domain.');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.hostChanged');
    }
};
javascript.javascriptGenerator.forBlock['location_hostChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const hostname = generator.getVariableName(block.getFieldValue('hostname'));

return `location.hostChanged.connect((_hostname) => { 
  ${hostname} = _hostname;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_goBackPossible'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.goBackPossible');

        this.appendDummyInput('isPossible')
            .appendField('isPossible:')
            .appendField(new Blockly.FieldVariable('goBackPossible_isPossible'), 'isPossible');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when there\'s a change in whether or not there\'s a previous location that can be navigated to using{@link location.goBack|goBack}. (Reflects changes in the state of the "Goto" dialog\'s back arrow.)');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goBackPossible');
    }
};
javascript.javascriptGenerator.forBlock['location_goBackPossible'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isPossible = generator.getVariableName(block.getFieldValue('isPossible'));

return `location.goBackPossible.connect((_isPossible) => { 
  ${isPossible} = _isPossible;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['location_goForwardPossible'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('location.goForwardPossible');

        this.appendDummyInput('isPossible')
            .appendField('isPossible:')
            .appendField(new Blockly.FieldVariable('goForwardPossible_isPossible'), 'isPossible');

        this.setColour('#D5189D');
        this.setTooltip('Triggered when there\'s a change in whether or not there\'s a forward location that can be navigated to using{@link location.goForward|goForward}. (Reflects changes in the state of the "Goto" dialog\'s forward arrow.)');
        this.setHelpUrl('https://apidocs.overte.org/location.html#.goForwardPossible');
    }
};
javascript.javascriptGenerator.forBlock['location_goForwardPossible'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isPossible = generator.getVariableName(block.getFieldValue('isPossible'));

return `location.goForwardPossible.connect((_isPossible) => { 
  ${isPossible} = _isPossible;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Assets_GetCacheStatusResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.GetCacheStatusResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('cacheDirectory') 
            .setCheck('String')
            .appendField('cacheDirectory');
        this.appendValueInput('cacheSize') 
            .setCheck('Number')
            .appendField('cacheSize');
        this.appendValueInput('maximumCacheSize') 
            .setCheck('Number')
            .appendField('maximumCacheSize');
        this.setColour('#9AEDEA');
        this.setTooltip('Cache status value returned by {@link Assets.getCacheStatus}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.GetCacheStatusResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_GetCacheStatusResult'] = (block, generator) => {
    const _cacheDirectory = dfv(generator.valueToCode(block, 'cacheDirectory', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _cacheSize = dfv(generator.valueToCode(block, 'cacheSize', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _maximumCacheSize = dfv(generator.valueToCode(block, 'maximumCacheSize', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Assets.GetCacheStatusResult(${_cacheDirectory},${_cacheSize},${_maximumCacheSize})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_CacheItemMetaData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.CacheItemMetaData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('attributes') 
            .setCheck('object')
            .appendField('attributes');
        this.appendValueInput('expirationDate') 
            .setCheck('Date')
            .appendField('expirationDate');
        this.appendValueInput('isValid') 
            .setCheck('Boolean')
            .appendField('isValid');
        this.appendValueInput('lastModified') 
            .setCheck('Date')
            .appendField('lastModified');
        this.appendValueInput('rawHeaders') 
            .setCheck('object')
            .appendField('rawHeaders');
        this.appendValueInput('saveToDisk') 
            .setCheck('Boolean')
            .appendField('saveToDisk');
        this.appendValueInput('urlmetaDataURL') 
            .setCheck('String')
            .appendField('urlmetaDataURL');
        this.setColour('#9AEDEA');
        this.setTooltip('Information on an asset in the cache. Value returned by {@link Assets.queryCacheMeta} and included in the data returned by {@link Assets.loadFromCache}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.CacheItemMetaData');
    }
};
javascript.javascriptGenerator.forBlock['Assets_CacheItemMetaData'] = (block, generator) => {
    const _attributes = dfv(generator.valueToCode(block, 'attributes', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _expirationDate = dfv(generator.valueToCode(block, 'expirationDate', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isValid = dfv(generator.valueToCode(block, 'isValid', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _lastModified = dfv(generator.valueToCode(block, 'lastModified', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rawHeaders = dfv(generator.valueToCode(block, 'rawHeaders', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _saveToDisk = dfv(generator.valueToCode(block, 'saveToDisk', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _urlmetaDataURL = dfv(generator.valueToCode(block, 'urlmetaDataURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.CacheItemMetaData(${_attributes},${_expirationDate},${_isValid},${_lastModified},${_rawHeaders},${_saveToDisk},${_urlmetaDataURL})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_SaveToCacheHeaders'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.SaveToCacheHeaders')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('expires') 
            .setCheck('String')
            .appendField('expires');
        this.appendValueInput('lastmodified') 
            .setCheck('String')
            .appendField('lastmodified');
        this.setColour('#9AEDEA');
        this.setTooltip('Last-modified and expiry times for a cache item.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.SaveToCacheHeaders');
    }
};
javascript.javascriptGenerator.forBlock['Assets_SaveToCacheHeaders'] = (block, generator) => {
    const _expires = dfv(generator.valueToCode(block, 'expires', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _lastmodified = dfv(generator.valueToCode(block, 'lastmodified', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.SaveToCacheHeaders(${_expires},${_lastmodified})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_SaveToCacheResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.SaveToCacheResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('expirationDate') 
            .setCheck('Date')
            .appendField('expirationDate');
        this.appendValueInput('lastModified') 
            .setCheck('Date')
            .appendField('lastModified');
        this.appendValueInput('metaDataURL') 
            .setCheck('String')
            .appendField('metaDataURL');
        this.appendValueInput('success') 
            .setCheck('Boolean')
            .appendField('success');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('Information on saving asset data to the cache with {@link Assets.saveToCache}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.SaveToCacheResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_SaveToCacheResult'] = (block, generator) => {
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _expirationDate = dfv(generator.valueToCode(block, 'expirationDate', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _lastModified = dfv(generator.valueToCode(block, 'lastModified', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _metaDataURL = dfv(generator.valueToCode(block, 'metaDataURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _success = dfv(generator.valueToCode(block, 'success', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.SaveToCacheResult(${_byteLength},${_expirationDate},${_lastModified},${_metaDataURL},${_success},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_LoadFromCacheResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.LoadFromCacheResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('contentType') 
            .setCheck('String')
            .appendField('contentType');
        this.appendValueInput('data') 
            .setCheck('Array')
            .appendField('data');
        this.appendValueInput('metadata') 
            .setCheck('Assets.CacheItemMetaData')
            .appendField('metadata');
        this.appendValueInput('response') 
            .setCheck('String')
            .appendField('response');
        this.appendValueInput('responseType') 
            .setCheck('Assets.ResponseType')
            .appendField('responseType');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('Data and information returned by {@link Assets.loadFromCache}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.LoadFromCacheResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_LoadFromCacheResult'] = (block, generator) => {
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _contentType = dfv(generator.valueToCode(block, 'contentType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _metadata = dfv(generator.valueToCode(block, 'metadata', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _response = dfv(generator.valueToCode(block, 'response', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.LoadFromCacheResult(${_byteLength},${_contentType},${_data},${_metadata},${_response},${_responseType},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_ResponseType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.ResponseType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('<p>Types of response that {@link Assets.decompressData}, {@link Assets.getAsset}, or {@link Assets.loadFromCache} may provide.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"arraybuffer"</code></td><td>A binary <code>ArrayBuffer</code> object.</td></tr>    <tr><td><code>"json"</code></td><td>A parsed <code>JSON</code> object.</td></tr>    <tr><td><code>"text"</code></td><td>UTF-8 decoded <code>string</code> value.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.ResponseType');
    }
};
javascript.javascriptGenerator.forBlock['Assets_ResponseType'] = (block, generator) => {

    return [`new Assets.ResponseType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_isValidPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.isValidPath')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setColour('#9AEDEA');
        this.setTooltip('Checks whether a string is a valid path. Note: A valid path must start with a <code>"/"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.isValidPath');
    }
};
javascript.javascriptGenerator.forBlock['Assets_isValidPath'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.isValidPath(${_path})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_isValidFilePath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.isValidFilePath')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setColour('#9AEDEA');
        this.setTooltip('Checks whether a string is a valid path and filename. Note: A valid path and filename must start with a <code>"/"</code> but must not end with a <code>"/"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.isValidFilePath');
    }
};
javascript.javascriptGenerator.forBlock['Assets_isValidFilePath'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.isValidFilePath(${_path})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_getATPUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.getATPUrl')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#9AEDEA');
        this.setTooltip('Gets the normalized ATP URL for a path or hash: ensures that it has <code>"atp:"</code> at the start.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.getATPUrl');
    }
};
javascript.javascriptGenerator.forBlock['Assets_getATPUrl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.getATPUrl(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_extractAssetHash'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.extractAssetHash')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#9AEDEA');
        this.setTooltip('Gets the SHA256 hexadecimal hash portion of an asset server URL.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.extractAssetHash');
    }
};
javascript.javascriptGenerator.forBlock['Assets_extractAssetHash'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.extractAssetHash(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_isValidHash'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.isValidHash')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('hash') 
            .setCheck('String')
            .appendField('hash');

        this.setColour('#9AEDEA');
        this.setTooltip('Checks whether a string is a valid SHA256 hexadecimal hash, i.e., 64 hexadecimal characters.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.isValidHash');
    }
};
javascript.javascriptGenerator.forBlock['Assets_isValidHash'] = (block, generator) => {
    const _hash = dfv(generator.valueToCode(block, 'hash', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.isValidHash(${_hash})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_hashData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.hashData')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');

        this.setColour('#9AEDEA');
        this.setTooltip('Calculates the SHA256 hash of given data.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.hashData');
    }
};
javascript.javascriptGenerator.forBlock['Assets_hashData'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.hashData(${_data})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_hashDataHex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.hashDataHex')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');

        this.setColour('#9AEDEA');
        this.setTooltip('Calculates the SHA256 hash of given data, in hexadecimal format.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.hashDataHex');
    }
};
javascript.javascriptGenerator.forBlock['Assets_hashDataHex'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.hashDataHex(${_data})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Window_ConnectionRefusedReason'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Window.ConnectionRefusedReason')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#C89686');
        this.setTooltip('<p>The reasons that you may be refused connection to a domain are defined by numeric values:</p><table>  <thead>    <tr>      <th>Reason</th>      <th>Value</th>      <th>Description</th>    </tr>  </thead>  <tbody>    <tr>      <td><strong>Unknown</strong></td>      <td><code>0</code></td>      <td>Some unknown reason.</td>    </tr>    <tr>      <td><strong>ProtocolMismatch</strong></td>      <td><code>1</code></td>      <td>The communications protocols of the domain and your Interface are not the same.</td>    </tr>    <tr>      <td><strong>LoginErrorMetaverse</strong></td>      <td><code>2</code></td>      <td>You could not be logged into the domain per your Directory Services login.</td>    </tr>    <tr>      <td><strong>NotAuthorizedMetaverse</strong></td>      <td><code>3</code></td>      <td>You are not authorized to connect to the domain per your Directory Services login.</td>    </tr>    <tr>      <td><strong>TooManyUsers</strong></td>      <td><code>4</code></td>      <td>The domain already has its maximum number of users.</td>    </tr>    <tr>      <td><strong>TimedOut</strong></td>      <td><code>5</code></td>      <td>Connecting to the domain timed out.</td>    </tr>    <tr>      <td><strong>LoginErrorDomain</strong></td>      <td><code>2</code></td>      <td>You could not be logged into the domain per your domain login.</td>    </tr>    <tr>      <td><strong>NotAuthorizedDomain</strong></td>      <td><code>6</code></td>      <td>You are not authorized to connect to the domain per your domain login.</td>    </tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Window.html#.ConnectionRefusedReason');
    }
};
javascript.javascriptGenerator.forBlock['Window_ConnectionRefusedReason'] = (block, generator) => {

    return [`new Window.ConnectionRefusedReason()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Script_ResourceBuckets'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.ResourceBuckets')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('Assets') 
            .setCheck('Script.ResourceBucket')
            .appendField('Assets');
        this.appendValueInput('HFPublic') 
            .setCheck('Script.ResourceBucket')
            .appendField('HFPublic');
        this.appendValueInput('HFContent') 
            .setCheck('Script.ResourceBucket')
            .appendField('HFContent');
        this.appendValueInput('HFMarketplace') 
            .setCheck('Script.ResourceBucket')
            .appendField('HFMarketplace');
        this.setColour('#F907E6');
        this.setTooltip('<p>An external resource bucket.</p><p>The original High Fidelity used "Public", "Content", and "MPAssets" Amazon S3 buckets. The intention is that thecommunity-run versions of these will keep the original data and structure, and any new additions will be made to Overte\'s "Assets" bucket. This should ease the transition from High Fidelity and ensure a clean separation.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.ResourceBuckets');
    }
};
javascript.javascriptGenerator.forBlock['Script_ResourceBuckets'] = (block, generator) => {
    const _Assets = dfv(generator.valueToCode(block, 'Assets', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _HFPublic = dfv(generator.valueToCode(block, 'HFPublic', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _HFContent = dfv(generator.valueToCode(block, 'HFContent', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _HFMarketplace = dfv(generator.valueToCode(block, 'HFMarketplace', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Script.ResourceBuckets(${_Assets},${_HFPublic},${_HFContent},${_HFMarketplace})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Script_ResourceBucket'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.ResourceBucket')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F907E6');
        this.setTooltip('<p>An external resource bucket.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>HF_Public</td><td>Assets that used to be in High Fidelity\'s <code>hifi-public</code>      Amazon S3 bucket.</td></tr>    <tr><td><code>1</code></td><td>HF_Content</td><td>Assets that used to be in High Fidelity\'s <code>hifi-content</code>      Amazon S3 bucket.</td></tr>    <tr><td><code>2</code></td><td>HF_Marketplace</td><td>Assets that used to be in the High Fidelity\'s       <code>mpassets</code> Amazon S3 bucket. (High Fidelity marketplace.)</td></tr>    <tr><td><code>3</code></td><td>Assets</td><td>Overte assets.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.ResourceBucket');
    }
};
javascript.javascriptGenerator.forBlock['Script_ResourceBucket'] = (block, generator) => {

    return [`new Script.ResourceBucket()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Messages_sendMessage'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Messages.sendMessage')
        // Returns data

        // Params data
        this.appendValueInput('channel') 
            .setCheck('String')
            .appendField('channel');
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');
        this.appendValueInput('localOnly') 
            .setCheck('Boolean')
            .appendField('localOnly');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#41DE6D');
        this.setTooltip('Sends a text message on a channel.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.sendMessage');
    }
};
javascript.javascriptGenerator.forBlock['Messages_sendMessage'] = (block, generator) => {
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _localOnly = dfv(generator.valueToCode(block, 'localOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Messages.sendMessage(${_channel},${_message},${_localOnly});\n`;};


// Blockly function
Blockly.Blocks['Messages_sendLocalMessage'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Messages.sendLocalMessage')
        // Returns data

        // Params data
        this.appendValueInput('channel') 
            .setCheck('String')
            .appendField('channel');
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#41DE6D');
        this.setTooltip('Sends a text message locally on a channel.This is the same as calling {@link Messages.sendMessage|sendMessage} with <code>localOnly == true</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.sendLocalMessage');
    }
};
javascript.javascriptGenerator.forBlock['Messages_sendLocalMessage'] = (block, generator) => {
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Messages.sendLocalMessage(${_channel},${_message});\n`;};


// Blockly function
Blockly.Blocks['Messages_sendData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Messages.sendData')
        // Returns data

        // Params data
        this.appendValueInput('channel') 
            .setCheck('String')
            .appendField('channel');
        this.appendValueInput('data') 
            .setCheck('object')
            .appendField('data');
        this.appendValueInput('localOnly') 
            .setCheck('Boolean')
            .appendField('localOnly');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#41DE6D');
        this.setTooltip('Sends a data message on a channel.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.sendData');
    }
};
javascript.javascriptGenerator.forBlock['Messages_sendData'] = (block, generator) => {
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _localOnly = dfv(generator.valueToCode(block, 'localOnly', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Messages.sendData(${_channel},${_data},${_localOnly});\n`;};


// Blockly function
Blockly.Blocks['Messages_subscribe'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Messages.subscribe')
        // Returns data

        // Params data
        this.appendValueInput('channel') 
            .setCheck('String')
            .appendField('channel');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#41DE6D');
        this.setTooltip('Subscribes the scripting environment &mdash; Interface, the entity script server, or assignment client instance &mdash; to receive messages on a specific channel. This means, for example, that if there are two Interface scripts that subscribe to different channels, both scripts will receive messages on both channels.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.subscribe');
    }
};
javascript.javascriptGenerator.forBlock['Messages_subscribe'] = (block, generator) => {
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Messages.subscribe(${_channel});\n`;};


// Blockly function
Blockly.Blocks['Messages_unsubscribe'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Messages.unsubscribe')
        // Returns data

        // Params data
        this.appendValueInput('channel') 
            .setCheck('String')
            .appendField('channel');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#41DE6D');
        this.setTooltip('Unsubscribes the scripting environment from receiving messages on a specific channel.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.unsubscribe');
    }
};
javascript.javascriptGenerator.forBlock['Messages_unsubscribe'] = (block, generator) => {
    const _channel = dfv(generator.valueToCode(block, 'channel', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Messages.unsubscribe(${_channel});\n`;};


// Blockly signal
Blockly.Blocks['Messages_messageReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Messages.messageReceived');

        this.appendDummyInput('channel')
            .appendField('channel:')
            .appendField(new Blockly.FieldVariable('messageReceived_channel'), 'channel');
        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('messageReceived_message'), 'message');
        this.appendDummyInput('senderID')
            .appendField('senderID:')
            .appendField(new Blockly.FieldVariable('messageReceived_senderID'), 'senderID');
        this.appendDummyInput('localOnly')
            .appendField('localOnly:')
            .appendField(new Blockly.FieldVariable('messageReceived_localOnly'), 'localOnly');

        this.setColour('#41DE6D');
        this.setTooltip('Triggered when a text message is received.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.messageReceived');
    }
};
javascript.javascriptGenerator.forBlock['Messages_messageReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const channel = generator.getVariableName(block.getFieldValue('channel'));
    const message = generator.getVariableName(block.getFieldValue('message'));
    const senderID = generator.getVariableName(block.getFieldValue('senderID'));
    const localOnly = generator.getVariableName(block.getFieldValue('localOnly'));

return `Messages.messageReceived.connect((_channel,_message,_senderID,_localOnly) => { 
  ${channel} = _channel; 
  ${message} = _message; 
  ${senderID} = _senderID; 
  ${localOnly} = _localOnly;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Messages_dataReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Messages.dataReceived');

        this.appendDummyInput('channel')
            .appendField('channel:')
            .appendField(new Blockly.FieldVariable('dataReceived_channel'), 'channel');
        this.appendDummyInput('data')
            .appendField('data:')
            .appendField(new Blockly.FieldVariable('dataReceived_data'), 'data');
        this.appendDummyInput('senderID')
            .appendField('senderID:')
            .appendField(new Blockly.FieldVariable('dataReceived_senderID'), 'senderID');
        this.appendDummyInput('localOnly')
            .appendField('localOnly:')
            .appendField(new Blockly.FieldVariable('dataReceived_localOnly'), 'localOnly');

        this.setColour('#41DE6D');
        this.setTooltip('Triggered when a data message is received.');
        this.setHelpUrl('https://apidocs.overte.org/Messages.html#.dataReceived');
    }
};
javascript.javascriptGenerator.forBlock['Messages_dataReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const channel = generator.getVariableName(block.getFieldValue('channel'));
    const data = generator.getVariableName(block.getFieldValue('data'));
    const senderID = generator.getVariableName(block.getFieldValue('senderID'));
    const localOnly = generator.getVariableName(block.getFieldValue('localOnly'));

return `Messages.dataReceived.connect((_channel,_data,_senderID,_localOnly) => { 
  ${channel} = _channel; 
  ${data} = _data; 
  ${senderID} = _senderID; 
  ${localOnly} = _localOnly;
${innerCode}
});\n`;};

// Blockly class
Blockly.Blocks['ResourceObject'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ResourceObject')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('state') 
            .setCheck('Resource.State')
            .appendField('state');
        this.setColour('#07B47A');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Information about a cached resource. Created by {@link AnimationCache.prefetch}, {@link MaterialCache.prefetch},{@link ModelCache.prefetch}, {@link SoundCache.prefetch}, or {@link TextureCache.prefetch}.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceObject');
    }
};
javascript.javascriptGenerator.forBlock['ResourceObject'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _state = dfv(generator.valueToCode(block, 'state', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ResourceObject(${_url},${_state})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Resource_State'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Resource.State')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('QUEUED') 
            .setCheck('Number')
            .appendField('QUEUED');
        this.appendValueInput('LOADING') 
            .setCheck('Number')
            .appendField('LOADING');
        this.appendValueInput('LOADED') 
            .setCheck('Number')
            .appendField('LOADED');
        this.appendValueInput('FINISHED') 
            .setCheck('Number')
            .appendField('FINISHED');
        this.appendValueInput('FAILED') 
            .setCheck('Number')
            .appendField('FAILED');
        this.setColour('#BE8545');
        this.setTooltip('The loading state of a resource.');
        this.setHelpUrl('https://apidocs.overte.org/Resource.html#.State');
    }
};
javascript.javascriptGenerator.forBlock['Resource_State'] = (block, generator) => {
    const _QUEUED = dfv(generator.valueToCode(block, 'QUEUED', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _LOADING = dfv(generator.valueToCode(block, 'LOADING', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _LOADED = dfv(generator.valueToCode(block, 'LOADED', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _FINISHED = dfv(generator.valueToCode(block, 'FINISHED', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _FAILED = dfv(generator.valueToCode(block, 'FAILED', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Resource.State(${_QUEUED},${_LOADING},${_LOADED},${_FINISHED},${_FAILED})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['ResourceObject#release'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ResourceObject#release')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#07B47A');
        this.setTooltip('Releases the resource.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceObject#release');
    }
};
javascript.javascriptGenerator.forBlock['ResourceObject#release'] = (block, generator) => {


    return `ResourceObject#release();\n`;};


// Blockly signal
Blockly.Blocks['ResourceObject#progressChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ResourceObject#progressChanged');

        this.appendDummyInput('bytesReceived')
            .appendField('bytesReceived:')
            .appendField(new Blockly.FieldVariable('progressChanged_bytesReceived'), 'bytesReceived');
        this.appendDummyInput('bytesTotal')
            .appendField('bytesTotal:')
            .appendField(new Blockly.FieldVariable('progressChanged_bytesTotal'), 'bytesTotal');

        this.setColour('#07B47A');
        this.setTooltip('Triggered when the resource\'s download progress changes.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceObject#progressChanged');
    }
};
javascript.javascriptGenerator.forBlock['ResourceObject#progressChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const bytesReceived = generator.getVariableName(block.getFieldValue('bytesReceived'));
    const bytesTotal = generator.getVariableName(block.getFieldValue('bytesTotal'));

return `ResourceObject#progressChanged.connect((_bytesReceived,_bytesTotal) => { 
  ${bytesReceived} = _bytesReceived; 
  ${bytesTotal} = _bytesTotal;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ResourceObject#stateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ResourceObject#stateChanged');

        this.appendDummyInput('state')
            .appendField('state:')
            .appendField(new Blockly.FieldVariable('stateChanged_state'), 'state');

        this.setColour('#07B47A');
        this.setTooltip('Triggered when the resource\'s loading state changes.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceObject#stateChanged');
    }
};
javascript.javascriptGenerator.forBlock['ResourceObject#stateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const state = generator.getVariableName(block.getFieldValue('state'));

return `ResourceObject#stateChanged.connect((_state) => { 
  ${state} = _state;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['ResourceCache_getResourceList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ResourceCache.getResourceList')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#EF9B9F');
        this.setTooltip('Gets the URLs of all resources in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceCache.html#.getResourceList');
    }
};
javascript.javascriptGenerator.forBlock['ResourceCache_getResourceList'] = (block, generator) => {

return [`ResourceCache.getResourceList()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ResourceCache_prefetch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ResourceCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#EF9B9F');
        this.setTooltip('Prefetches a resource.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['ResourceCache_prefetch'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ResourceCache.prefetch(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['ResourceCache_dirty'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ResourceCache.dirty');


        this.setColour('#EF9B9F');
        this.setTooltip('Triggered when the cache content has changed.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceCache.html#.dirty');
    }
};
javascript.javascriptGenerator.forBlock['ResourceCache_dirty'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ResourceCache.dirty.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['Resources_overrideUrlPrefix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Resources.overrideUrlPrefix')
        // Returns data

        // Params data
        this.appendValueInput('prefix') 
            .setCheck('String')
            .appendField('prefix');
        this.appendValueInput('replacement') 
            .setCheck('String')
            .appendField('replacement');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DDCF50');
        this.setTooltip('Overrides a path prefix with an alternative path.');
        this.setHelpUrl('https://apidocs.overte.org/Resources.html#.overrideUrlPrefix');
    }
};
javascript.javascriptGenerator.forBlock['Resources_overrideUrlPrefix'] = (block, generator) => {
    const _prefix = dfv(generator.valueToCode(block, 'prefix', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _replacement = dfv(generator.valueToCode(block, 'replacement', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Resources.overrideUrlPrefix(${_prefix},${_replacement});\n`;};


// Blockly function
Blockly.Blocks['Resources_restoreUrlPrefix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Resources.restoreUrlPrefix')
        // Returns data

        // Params data
        this.appendValueInput('prefix') 
            .setCheck('String')
            .appendField('prefix');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DDCF50');
        this.setTooltip('Restores the default path for a specified prefix.');
        this.setHelpUrl('https://apidocs.overte.org/Resources.html#.restoreUrlPrefix');
    }
};
javascript.javascriptGenerator.forBlock['Resources_restoreUrlPrefix'] = (block, generator) => {
    const _prefix = dfv(generator.valueToCode(block, 'prefix', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Resources.restoreUrlPrefix(${_prefix});\n`;};


// Blockly function
Blockly.Blocks['Entities_setPacketsPerSecond'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.setPacketsPerSecond')
        // Returns data

        // Params data
        this.appendValueInput('packetsPerSecond') 
            .setCheck('Number')
            .appendField('packetsPerSecond');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EA9958');
        this.setTooltip('Sets the maximum number of entity packets that the client can send per second.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.setPacketsPerSecond');
    }
};
javascript.javascriptGenerator.forBlock['Entities_setPacketsPerSecond'] = (block, generator) => {
    const _packetsPerSecond = dfv(generator.valueToCode(block, 'packetsPerSecond', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Entities.setPacketsPerSecond(${_packetsPerSecond});\n`;};


// Blockly function
Blockly.Blocks['Entities_getPacketsPerSecond'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getPacketsPerSecond')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the maximum number of entity packets that the client can send per second.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getPacketsPerSecond');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getPacketsPerSecond'] = (block, generator) => {

return [`Entities.getPacketsPerSecond()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_serversExist'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.serversExist')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether servers exist for the client to send entity packets to, i.e., whether you are connected to a domain andits entity server is working.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.serversExist');
    }
};
javascript.javascriptGenerator.forBlock['Entities_serversExist'] = (block, generator) => {

return [`Entities.serversExist()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_hasPacketsToSend'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.hasPacketsToSend')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Checks whether the client has entity packets waiting to be sent.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.hasPacketsToSend');
    }
};
javascript.javascriptGenerator.forBlock['Entities_hasPacketsToSend'] = (block, generator) => {

return [`Entities.hasPacketsToSend()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_packetsToSendCount'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.packetsToSendCount')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the number of entity packets the client has waiting to be sent.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.packetsToSendCount');
    }
};
javascript.javascriptGenerator.forBlock['Entities_packetsToSendCount'] = (block, generator) => {

return [`Entities.packetsToSendCount()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimePPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimePPS')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the entity packets per second send rate of the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimePPS');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimePPS'] = (block, generator) => {

return [`Entities.getLifetimePPS()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimeBPS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimeBPS')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the entity bytes per second send rate of the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimeBPS');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimeBPS'] = (block, generator) => {

return [`Entities.getLifetimeBPS()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimePPSQueued'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimePPSQueued')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the entity packets per second queued rate of the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimePPSQueued');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimePPSQueued'] = (block, generator) => {

return [`Entities.getLifetimePPSQueued()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimeBPSQueued'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimeBPSQueued')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the entity bytes per second queued rate of the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimeBPSQueued');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimeBPSQueued'] = (block, generator) => {

return [`Entities.getLifetimeBPSQueued()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimeInUsecs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimeInUsecs')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the lifetime of the client from the first entity packet sent until now, in microseconds.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimeInUsecs');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimeInUsecs'] = (block, generator) => {

return [`Entities.getLifetimeInUsecs()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimeInSeconds'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimeInSeconds')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the lifetime of the client from the first entity packet sent until now, in seconds.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimeInSeconds');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimeInSeconds'] = (block, generator) => {

return [`Entities.getLifetimeInSeconds()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimePacketsSent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimePacketsSent')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the total number of entity packets sent by the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimePacketsSent');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimePacketsSent'] = (block, generator) => {

return [`Entities.getLifetimePacketsSent()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimeBytesSent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimeBytesSent')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the total bytes of entity packets sent by the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimeBytesSent');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimeBytesSent'] = (block, generator) => {

return [`Entities.getLifetimeBytesSent()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimePacketsQueued'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimePacketsQueued')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the total number of entity packets queued by the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimePacketsQueued');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimePacketsQueued'] = (block, generator) => {

return [`Entities.getLifetimePacketsQueued()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Entities_getLifetimeBytesQueued'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.getLifetimeBytesQueued')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#EA9958');
        this.setTooltip('Gets the total bytes of entity packets queued by the client over its lifetime.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.getLifetimeBytesQueued');
    }
};
javascript.javascriptGenerator.forBlock['Entities_getLifetimeBytesQueued'] = (block, generator) => {

return [`Entities.getLifetimeBytesQueued()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-Offset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-Offset')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('pointToOffsetFrom') 
            .setCheck('Vec3')
            .appendField('pointToOffsetFrom');
        this.appendValueInput('linearDistance') 
            .setCheck('Number')
            .appendField('linearDistance');
        this.appendValueInput('linearTimeScale') 
            .setCheck('Number')
            .appendField('linearTimeScale');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"offset"</code> {@link Entities.ActionType|ActionType} moves an entity so that it is a defined distance away from a target point.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-Offset');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-Offset'] = (block, generator) => {
    const _pointToOffsetFrom = dfv(generator.valueToCode(block, 'pointToOffsetFrom', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _linearDistance = dfv(generator.valueToCode(block, 'linearDistance', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _linearTimeScale = dfv(generator.valueToCode(block, 'linearTimeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `34e+38`);

    return [`new Entities.ActionArguments-Offset(${_pointToOffsetFrom},${_linearDistance},${_linearTimeScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-Tractor'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-Tractor')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('otherID') 
            .setCheck('Uuid')
            .appendField('otherID');
        this.appendValueInput('otherJointIndex') 
            .setCheck('Uuid')
            .appendField('otherJointIndex');
        this.appendValueInput('targetPosition') 
            .setCheck('Vec3')
            .appendField('targetPosition');
        this.appendValueInput('targetRotation') 
            .setCheck('Quat')
            .appendField('targetRotation');
        this.appendValueInput('linearTimeScale') 
            .setCheck('Number')
            .appendField('linearTimeScale');
        this.appendValueInput('angularTimeScale') 
            .setCheck('Number')
            .appendField('angularTimeScale');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"tractor"</code> {@link Entities.ActionType|ActionType} moves and rotates an entity to a target position andorientation, optionally relative to another entity.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-Tractor');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-Tractor'] = (block, generator) => {
    const _otherID = dfv(generator.valueToCode(block, 'otherID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _otherJointIndex = dfv(generator.valueToCode(block, 'otherJointIndex', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _targetPosition = dfv(generator.valueToCode(block, 'targetPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _targetRotation = dfv(generator.valueToCode(block, 'targetRotation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0,1`);
    const _linearTimeScale = dfv(generator.valueToCode(block, 'linearTimeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `3.4E+38`);
    const _angularTimeScale = dfv(generator.valueToCode(block, 'angularTimeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `3.4E+38`);

    return [`new Entities.ActionArguments-Tractor(${_otherID},${_otherJointIndex},${_targetPosition},${_targetRotation},${_linearTimeScale},${_angularTimeScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-TravelOriented'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-TravelOriented')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('forward') 
            .setCheck('Vec3')
            .appendField('forward');
        this.appendValueInput('angularTimeScale') 
            .setCheck('Number')
            .appendField('angularTimeScale');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"travel-oriented"</code> {@link Entities.ActionType|ActionType} orients an entity to align with its direction of travel.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-TravelOriented');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-TravelOriented'] = (block, generator) => {
    const _forward = dfv(generator.valueToCode(block, 'forward', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _angularTimeScale = dfv(generator.valueToCode(block, 'angularTimeScale', javascript.javascriptGenerator.ORDER_ATOMIC), `0.1`);

    return [`new Entities.ActionArguments-TravelOriented(${_forward},${_angularTimeScale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-BallSocket'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-BallSocket')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('otherEntityID') 
            .setCheck('Uuid')
            .appendField('otherEntityID');
        this.appendValueInput('pivot') 
            .setCheck('Vec3')
            .appendField('pivot');
        this.appendValueInput('otherPivot') 
            .setCheck('Vec3')
            .appendField('otherPivot');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"ball-socket"</code> {@link Entities.ActionType|ActionType} connects two entities with a ball and socket joint. It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-BallSocket');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-BallSocket'] = (block, generator) => {
    const _otherEntityID = dfv(generator.valueToCode(block, 'otherEntityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pivot = dfv(generator.valueToCode(block, 'pivot', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _otherPivot = dfv(generator.valueToCode(block, 'otherPivot', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);

    return [`new Entities.ActionArguments-BallSocket(${_otherEntityID},${_pivot},${_otherPivot})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-ConeTwist'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-ConeTwist')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('otherEntityID') 
            .setCheck('Uuid')
            .appendField('otherEntityID');
        this.appendValueInput('pivot') 
            .setCheck('Vec3')
            .appendField('pivot');
        this.appendValueInput('axis') 
            .setCheck('Vec3')
            .appendField('axis');
        this.appendValueInput('otherPivot') 
            .setCheck('Vec3')
            .appendField('otherPivot');
        this.appendValueInput('otherAxis') 
            .setCheck('Vec3')
            .appendField('otherAxis');
        this.appendValueInput('swingSpan1') 
            .setCheck('Number')
            .appendField('swingSpan1');
        this.appendValueInput('swingSpan2') 
            .setCheck('Number')
            .appendField('swingSpan2');
        this.appendValueInput('twistSpan') 
            .setCheck('Number')
            .appendField('twistSpan');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"cone-twist"</code> {@link Entities.ActionType|ActionType} connects two entities with a joint that can move through a cone and can twist.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-ConeTwist');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-ConeTwist'] = (block, generator) => {
    const _otherEntityID = dfv(generator.valueToCode(block, 'otherEntityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pivot = dfv(generator.valueToCode(block, 'pivot', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _axis = dfv(generator.valueToCode(block, 'axis', javascript.javascriptGenerator.ORDER_ATOMIC), `1,0,0`);
    const _otherPivot = dfv(generator.valueToCode(block, 'otherPivot', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _otherAxis = dfv(generator.valueToCode(block, 'otherAxis', javascript.javascriptGenerator.ORDER_ATOMIC), `1,0,0`);
    const _swingSpan1 = dfv(generator.valueToCode(block, 'swingSpan1', javascript.javascriptGenerator.ORDER_ATOMIC), `2*Math.PI`);
    const _swingSpan2 = dfv(generator.valueToCode(block, 'swingSpan2', javascript.javascriptGenerator.ORDER_ATOMIC), `2*Math.PI`);
    const _twistSpan = dfv(generator.valueToCode(block, 'twistSpan', javascript.javascriptGenerator.ORDER_ATOMIC), `2*Math.PI`);

    return [`new Entities.ActionArguments-ConeTwist(${_otherEntityID},${_pivot},${_axis},${_otherPivot},${_otherAxis},${_swingSpan1},${_swingSpan2},${_twistSpan})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-Hinge'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-Hinge')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('otherEntityID') 
            .setCheck('Uuid')
            .appendField('otherEntityID');
        this.appendValueInput('pivot') 
            .setCheck('Vec3')
            .appendField('pivot');
        this.appendValueInput('axis') 
            .setCheck('Vec3')
            .appendField('axis');
        this.appendValueInput('otherPivot') 
            .setCheck('Vec3')
            .appendField('otherPivot');
        this.appendValueInput('otherAxis') 
            .setCheck('Vec3')
            .appendField('otherAxis');
        this.appendValueInput('low') 
            .setCheck('Number')
            .appendField('low');
        this.appendValueInput('high') 
            .setCheck('Number')
            .appendField('high');
        this.appendValueInput('angle') 
            .setCheck('Number')
            .appendField('angle');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"hinge"</code> {@link Entities.ActionType|ActionType} lets an entity pivot about an axis or connects two entitieswith a hinge joint.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-Hinge');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-Hinge'] = (block, generator) => {
    const _otherEntityID = dfv(generator.valueToCode(block, 'otherEntityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pivot = dfv(generator.valueToCode(block, 'pivot', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _axis = dfv(generator.valueToCode(block, 'axis', javascript.javascriptGenerator.ORDER_ATOMIC), `1,0,0`);
    const _otherPivot = dfv(generator.valueToCode(block, 'otherPivot', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _otherAxis = dfv(generator.valueToCode(block, 'otherAxis', javascript.javascriptGenerator.ORDER_ATOMIC), `1,0,0`);
    const _low = dfv(generator.valueToCode(block, 'low', javascript.javascriptGenerator.ORDER_ATOMIC), `-2*Math.PI`);
    const _high = dfv(generator.valueToCode(block, 'high', javascript.javascriptGenerator.ORDER_ATOMIC), `2*Math.PI`);
    const _angle = dfv(generator.valueToCode(block, 'angle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Entities.ActionArguments-Hinge(${_otherEntityID},${_pivot},${_axis},${_otherPivot},${_otherAxis},${_low},${_high},${_angle})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments-Slider'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments-Slider')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('otherEntityID') 
            .setCheck('Uuid')
            .appendField('otherEntityID');
        this.appendValueInput('point') 
            .setCheck('Vec3')
            .appendField('point');
        this.appendValueInput('axis') 
            .setCheck('Vec3')
            .appendField('axis');
        this.appendValueInput('otherPoint') 
            .setCheck('Vec3')
            .appendField('otherPoint');
        this.appendValueInput('otherAxis') 
            .setCheck('Vec3')
            .appendField('otherAxis');
        this.appendValueInput('linearLow') 
            .setCheck('Number')
            .appendField('linearLow');
        this.appendValueInput('linearHigh') 
            .setCheck('Number')
            .appendField('linearHigh');
        this.appendValueInput('angularLow') 
            .setCheck('Number')
            .appendField('angularLow');
        this.appendValueInput('angularHigh') 
            .setCheck('Number')
            .appendField('angularHigh');
        this.appendValueInput('linearPosition') 
            .setCheck('Number')
            .appendField('linearPosition');
        this.appendValueInput('angularPosition') 
            .setCheck('Number')
            .appendField('angularPosition');
        this.setColour('#EA9958');
        this.setTooltip('The <code>"slider"</code> {@link Entities.ActionType|ActionType} lets an entity slide and rotate along an axis, or connects two entities that slide and rotate along a shared axis.It has arguments in addition to the common {@link Entities.ActionArguments|ActionArguments}:');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments-Slider');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments-Slider'] = (block, generator) => {
    const _otherEntityID = dfv(generator.valueToCode(block, 'otherEntityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _point = dfv(generator.valueToCode(block, 'point', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _axis = dfv(generator.valueToCode(block, 'axis', javascript.javascriptGenerator.ORDER_ATOMIC), `1,0,0`);
    const _otherPoint = dfv(generator.valueToCode(block, 'otherPoint', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _otherAxis = dfv(generator.valueToCode(block, 'otherAxis', javascript.javascriptGenerator.ORDER_ATOMIC), `1,0,0`);
    const _linearLow = dfv(generator.valueToCode(block, 'linearLow', javascript.javascriptGenerator.ORDER_ATOMIC), `1.17E-38`);
    const _linearHigh = dfv(generator.valueToCode(block, 'linearHigh', javascript.javascriptGenerator.ORDER_ATOMIC), `3.40e+38`);
    const _angularLow = dfv(generator.valueToCode(block, 'angularLow', javascript.javascriptGenerator.ORDER_ATOMIC), `-2*Math.PI`);
    const _angularHigh = dfv(generator.valueToCode(block, 'angularHigh', javascript.javascriptGenerator.ORDER_ATOMIC), `Math.PI`);
    const _linearPosition = dfv(generator.valueToCode(block, 'linearPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _angularPosition = dfv(generator.valueToCode(block, 'angularPosition', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Entities.ActionArguments-Slider(${_otherEntityID},${_point},${_axis},${_otherPoint},${_otherAxis},${_linearLow},${_linearHigh},${_angularLow},${_angularHigh},${_linearPosition},${_angularPosition})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ActionArguments'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ActionArguments')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('Entities.ActionType')
            .appendField('type');
        this.appendValueInput('tag') 
            .setCheck('String')
            .appendField('tag');
        this.appendValueInput('ttl') 
            .setCheck('Number')
            .appendField('ttl');
        this.appendValueInput('isMine') 
            .setCheck('Boolean')
            .appendField('isMine');
        this.appendValueInput('nomotionstate') 
            .setCheck('Boolean')
            .appendField('nomotionstate');
        this.appendValueInput('active') 
            .setCheck('Boolean')
            .appendField('active');
        this.appendValueInput('motiontype') 
            .setCheck('Entities.PhysicsMotionType')
            .appendField('motiontype');
        this.setColour('#EA9958');
        this.setTooltip('Different entity action types have different arguments: some common to all actions (listed in the table) and some specific to each {@link Entities.ActionType|ActionType} (linked to below).');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ActionArguments');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ActionArguments'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _tag = dfv(generator.valueToCode(block, 'tag', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _ttl = dfv(generator.valueToCode(block, 'ttl', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _isMine = dfv(generator.valueToCode(block, 'isMine', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _nomotionstate = dfv(generator.valueToCode(block, 'nomotionstate', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _active = dfv(generator.valueToCode(block, 'active', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _motiontype = dfv(generator.valueToCode(block, 'motiontype', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.ActionArguments(${_type},${_tag},${_ttl},${_isMine},${_nomotionstate},${_active},${_motiontype})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_PhysicsMotionType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.PhysicsMotionType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>An entity\'s physics motion type may be one of the following:</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"static"</code></td><td>There is no motion because the entity is locked  &mdash; its <code>locked</code>         property is set to <code>true</code>.</td></tr>    <tr><td><code>"kinematic"</code></td><td>Motion is applied without physical laws (e.g., damping) because the entity is         not locked and has its <code>dynamic</code> property set to <code>false</code>.</td></tr>    <tr><td><code>"dynamic"</code></td><td>Motion is applied according to physical laws (e.g., damping) because the entity         is not locked and has its <code>dynamic</code> property set to <code>true</code>.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.PhysicsMotionType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_PhysicsMotionType'] = (block, generator) => {

    return [`new Entities.PhysicsMotionType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_PlatformDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.PlatformDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('computer') 
            .setCheck('PlatformInfo.ComputerDescription')
            .appendField('computer');
        this.appendValueInput('cpus') 
            .setCheck('Array')
            .appendField('cpus');
        this.appendValueInput('displays') 
            .setCheck('Array')
            .appendField('displays');
        this.appendValueInput('gpus') 
            .setCheck('Array')
            .appendField('gpus');
        this.appendValueInput('graphicsAPIs') 
            .setCheck('Array')
            .appendField('graphicsAPIs');
        this.appendValueInput('memory') 
            .setCheck('PlatformInfo.MemoryDescription')
            .appendField('memory');
        this.appendValueInput('nics') 
            .setCheck('PlatformInfo.NICDescription')
            .appendField('nics');
        this.setColour('#178142');
        this.setTooltip('Information on the computer platform as a whole.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.PlatformDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_PlatformDescription'] = (block, generator) => {
    const _computer = dfv(generator.valueToCode(block, 'computer', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _cpus = dfv(generator.valueToCode(block, 'cpus', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _displays = dfv(generator.valueToCode(block, 'displays', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _gpus = dfv(generator.valueToCode(block, 'gpus', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _graphicsAPIs = dfv(generator.valueToCode(block, 'graphicsAPIs', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _memory = dfv(generator.valueToCode(block, 'memory', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _nics = dfv(generator.valueToCode(block, 'nics', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PlatformInfo.PlatformDescription(${_computer},${_cpus},${_displays},${_gpus},${_graphicsAPIs},${_memory},${_nics})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_CPUDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.CPUDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('vendor') 
            .setCheck('String')
            .appendField('vendor');
        this.appendValueInput('model') 
            .setCheck('String')
            .appendField('model');
        this.appendValueInput('numCores') 
            .setCheck('Number')
            .appendField('numCores');
        this.appendValueInput('isPrimary') 
            .setCheck('Boolean')
            .appendField('isPrimary');
        this.setColour('#178142');
        this.setTooltip('Information on a CPU.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.CPUDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_CPUDescription'] = (block, generator) => {
    const _vendor = dfv(generator.valueToCode(block, 'vendor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _numCores = dfv(generator.valueToCode(block, 'numCores', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _isPrimary = dfv(generator.valueToCode(block, 'isPrimary', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new PlatformInfo.CPUDescription(${_vendor},${_model},${_numCores},${_isPrimary})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_GPUDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.GPUDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('vendor') 
            .setCheck('String')
            .appendField('vendor');
        this.appendValueInput('model') 
            .setCheck('String')
            .appendField('model');
        this.appendValueInput('driver') 
            .setCheck('String')
            .appendField('driver');
        this.appendValueInput('videoMemory') 
            .setCheck('Number')
            .appendField('videoMemory');
        this.appendValueInput('displays') 
            .setCheck('Array')
            .appendField('displays');
        this.appendValueInput('isPrimary') 
            .setCheck('Boolean')
            .appendField('isPrimary');
        this.setColour('#178142');
        this.setTooltip('Information on a GPU.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.GPUDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_GPUDescription'] = (block, generator) => {
    const _vendor = dfv(generator.valueToCode(block, 'vendor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _driver = dfv(generator.valueToCode(block, 'driver', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _videoMemory = dfv(generator.valueToCode(block, 'videoMemory', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _displays = dfv(generator.valueToCode(block, 'displays', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isPrimary = dfv(generator.valueToCode(block, 'isPrimary', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new PlatformInfo.GPUDescription(${_vendor},${_model},${_driver},${_videoMemory},${_displays},${_isPrimary})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_GraphicsAPIDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.GraphicsAPIDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('version') 
            .setCheck('String')
            .appendField('version');
        this.appendValueInput('renderer') 
            .setCheck('String')
            .appendField('renderer');
        this.appendValueInput('vendor') 
            .setCheck('String')
            .appendField('vendor');
        this.appendValueInput('shadingLanguageVersion') 
            .setCheck('String')
            .appendField('shadingLanguageVersion');
        this.appendValueInput('extensions') 
            .setCheck('Array')
            .appendField('extensions');
        this.appendValueInput('devices') 
            .setCheck('Array')
            .appendField('devices');
        this.setColour('#178142');
        this.setTooltip('Information on a graphics API.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.GraphicsAPIDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_GraphicsAPIDescription'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _version = dfv(generator.valueToCode(block, 'version', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _renderer = dfv(generator.valueToCode(block, 'renderer', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _vendor = dfv(generator.valueToCode(block, 'vendor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shadingLanguageVersion = dfv(generator.valueToCode(block, 'shadingLanguageVersion', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extensions = dfv(generator.valueToCode(block, 'extensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _devices = dfv(generator.valueToCode(block, 'devices', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PlatformInfo.GraphicsAPIDescription(${_name},${_version},${_renderer},${_vendor},${_shadingLanguageVersion},${_extensions},${_devices})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_VulkanAPIDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.VulkanAPIDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('prop0') 
            .setCheck('String')
            .appendField('prop0');
        this.appendValueInput('driverVersion') 
            .setCheck('String')
            .appendField('driverVersion');
        this.appendValueInput('apiVersion') 
            .setCheck('String')
            .appendField('apiVersion');
        this.appendValueInput('deviceType') 
            .setCheck('String')
            .appendField('deviceType');
        this.appendValueInput('vendor') 
            .setCheck('String')
            .appendField('vendor');
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('extensions') 
            .setCheck('Array')
            .appendField('extensions');
        this.appendValueInput('queues') 
            .setCheck('Array')
            .appendField('queues');
        this.appendValueInput('heaps') 
            .setCheck('Array')
            .appendField('heaps');
        this.setColour('#178142');
        this.setTooltip('Information on a Vulkan graphics API.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.VulkanAPIDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_VulkanAPIDescription'] = (block, generator) => {
    const _prop0 = dfv(generator.valueToCode(block, 'prop0', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _driverVersion = dfv(generator.valueToCode(block, 'driverVersion', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _apiVersion = dfv(generator.valueToCode(block, 'apiVersion', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _deviceType = dfv(generator.valueToCode(block, 'deviceType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _vendor = dfv(generator.valueToCode(block, 'vendor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _extensions = dfv(generator.valueToCode(block, 'extensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _queues = dfv(generator.valueToCode(block, 'queues', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _heaps = dfv(generator.valueToCode(block, 'heaps', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PlatformInfo.VulkanAPIDescription(${_prop0},${_driverVersion},${_apiVersion},${_deviceType},${_vendor},${_name},${_extensions},${_queues},${_heaps})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_VulkanQueueDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.VulkanQueueDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('flags') 
            .setCheck('String')
            .appendField('flags');
        this.appendValueInput('count') 
            .setCheck('Number')
            .appendField('count');
        this.setColour('#178142');
        this.setTooltip('Information on a Vulkan queue.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.VulkanQueueDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_VulkanQueueDescription'] = (block, generator) => {
    const _flags = dfv(generator.valueToCode(block, 'flags', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _count = dfv(generator.valueToCode(block, 'count', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new PlatformInfo.VulkanQueueDescription(${_flags},${_count})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_VulkanHeapDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.VulkanHeapDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('flags') 
            .setCheck('String')
            .appendField('flags');
        this.appendValueInput('size') 
            .setCheck('Number')
            .appendField('size');
        this.setColour('#178142');
        this.setTooltip('Information on a Vulkan heap.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.VulkanHeapDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_VulkanHeapDescription'] = (block, generator) => {
    const _flags = dfv(generator.valueToCode(block, 'flags', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new PlatformInfo.VulkanHeapDescription(${_flags},${_size})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_NICDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.NICDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('mac') 
            .setCheck('String')
            .appendField('mac');
        this.setColour('#178142');
        this.setTooltip('Information on a network card.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.NICDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_NICDescription'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _mac = dfv(generator.valueToCode(block, 'mac', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PlatformInfo.NICDescription(${_name},${_mac})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_DisplayDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.DisplayDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('description') 
            .setCheck('String')
            .appendField('description');
        this.appendValueInput('deviceName') 
            .setCheck('String')
            .appendField('deviceName');
        this.appendValueInput('boundsLeft') 
            .setCheck('Number')
            .appendField('boundsLeft');
        this.appendValueInput('boundsRight') 
            .setCheck('Number')
            .appendField('boundsRight');
        this.appendValueInput('boundsTop') 
            .setCheck('Number')
            .appendField('boundsTop');
        this.appendValueInput('boundsBottom') 
            .setCheck('Number')
            .appendField('boundsBottom');
        this.appendValueInput('gpu') 
            .setCheck('Number')
            .appendField('gpu');
        this.appendValueInput('ppi') 
            .setCheck('Number')
            .appendField('ppi');
        this.appendValueInput('ppiDesktop') 
            .setCheck('Number')
            .appendField('ppiDesktop');
        this.appendValueInput('physicalWidth') 
            .setCheck('Number')
            .appendField('physicalWidth');
        this.appendValueInput('physicalHeight') 
            .setCheck('Number')
            .appendField('physicalHeight');
        this.appendValueInput('modeRefreshrate') 
            .setCheck('Number')
            .appendField('modeRefreshrate');
        this.appendValueInput('modeWidth') 
            .setCheck('Number')
            .appendField('modeWidth');
        this.appendValueInput('modeHeight') 
            .setCheck('Number')
            .appendField('modeHeight');
        this.appendValueInput('isPrimary') 
            .setCheck('Boolean')
            .appendField('isPrimary');
        this.setColour('#178142');
        this.setTooltip('Information on a display.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.DisplayDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_DisplayDescription'] = (block, generator) => {
    const _description = dfv(generator.valueToCode(block, 'description', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _deviceName = dfv(generator.valueToCode(block, 'deviceName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _boundsLeft = dfv(generator.valueToCode(block, 'boundsLeft', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _boundsRight = dfv(generator.valueToCode(block, 'boundsRight', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _boundsTop = dfv(generator.valueToCode(block, 'boundsTop', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _boundsBottom = dfv(generator.valueToCode(block, 'boundsBottom', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _gpu = dfv(generator.valueToCode(block, 'gpu', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _ppi = dfv(generator.valueToCode(block, 'ppi', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _ppiDesktop = dfv(generator.valueToCode(block, 'ppiDesktop', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _physicalWidth = dfv(generator.valueToCode(block, 'physicalWidth', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _physicalHeight = dfv(generator.valueToCode(block, 'physicalHeight', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _modeRefreshrate = dfv(generator.valueToCode(block, 'modeRefreshrate', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _modeWidth = dfv(generator.valueToCode(block, 'modeWidth', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _modeHeight = dfv(generator.valueToCode(block, 'modeHeight', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _isPrimary = dfv(generator.valueToCode(block, 'isPrimary', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new PlatformInfo.DisplayDescription(${_description},${_deviceName},${_boundsLeft},${_boundsRight},${_boundsTop},${_boundsBottom},${_gpu},${_ppi},${_ppiDesktop},${_physicalWidth},${_physicalHeight},${_modeRefreshrate},${_modeWidth},${_modeHeight},${_isPrimary})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_MemoryDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.MemoryDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('memTotal') 
            .setCheck('Number')
            .appendField('memTotal');
        this.setColour('#178142');
        this.setTooltip('Information on the computer\'s memory.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.MemoryDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_MemoryDescription'] = (block, generator) => {
    const _memTotal = dfv(generator.valueToCode(block, 'memTotal', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new PlatformInfo.MemoryDescription(${_memTotal})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_ComputerDescription'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.ComputerDescription')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('OS') 
            .setCheck('PlatformInfo.ComputerOS')
            .appendField('OS');
        this.appendValueInput('OSversion') 
            .setCheck('String')
            .appendField('OSversion');
        this.appendValueInput('vendor') 
            .setCheck('String')
            .appendField('vendor');
        this.appendValueInput('model') 
            .setCheck('String')
            .appendField('model');
        this.appendValueInput('profileTier') 
            .setCheck('PlatformInfo.PlatformTier')
            .appendField('profileTier');
        this.setColour('#178142');
        this.setTooltip('Information on the computer.');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.ComputerDescription');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_ComputerDescription'] = (block, generator) => {
    const _OS = dfv(generator.valueToCode(block, 'OS', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _OSversion = dfv(generator.valueToCode(block, 'OSversion', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _vendor = dfv(generator.valueToCode(block, 'vendor', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _profileTier = dfv(generator.valueToCode(block, 'profileTier', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PlatformInfo.ComputerDescription(${_OS},${_OSversion},${_vendor},${_model},${_profileTier})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PlatformInfo_ComputerOS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PlatformInfo.ComputerOS')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#178142');
        this.setTooltip('<p>The computer operating system.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"WINDOWS"</code></td><td>Windows.</td></tr>    <tr><td><code>"MACOS"</code></td><td>Mac OS.</td></tr>    <tr><td><code>"LINUX"</code></td><td>Linux.</td></tr>    <tr><td><code>"ANDROID"</code></td><td>Android.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/PlatformInfo.html#.ComputerOS');
    }
};
javascript.javascriptGenerator.forBlock['PlatformInfo_ComputerOS'] = (block, generator) => {

    return [`new PlatformInfo.ComputerOS()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Steam_running'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Steam.running')       
        this.setOutput(true, '');
        this.setColour('#4DB456');
        this.setTooltip('<code>true</code> if Interface is running under Steam, <code>false</code> if it isn\'t.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Steam.html#.running');
    }
};
javascript.javascriptGenerator.forBlock['Steam_running'] = (block, generator) => {
    return [`Steam.running`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Steam_isRunning'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Steam.isRunning')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#4DB456');
        this.setTooltip('Gets whether Interface is running under Steam.');
        this.setHelpUrl('https://apidocs.overte.org/Steam.html#.isRunning');
    }
};
javascript.javascriptGenerator.forBlock['Steam_isRunning'] = (block, generator) => {

return [`Steam.isRunning()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Steam_openInviteOverlay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Steam.openInviteOverlay')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#4DB456');
        this.setTooltip('Opens Steam\'s "Choose Friends to invite" dialog if Interface is running under Steam.');
        this.setHelpUrl('https://apidocs.overte.org/Steam.html#.openInviteOverlay');
    }
};
javascript.javascriptGenerator.forBlock['Steam_openInviteOverlay'] = (block, generator) => {


    return `Steam.openInviteOverlay();\n`;};


// Blockly namespace
Blockly.Blocks['MaterialCache_numTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.numTotal')       
        this.setOutput(true, '');
        this.setColour('#8088DB');
        this.setTooltip('Total number of total resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.numTotal');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_numTotal'] = (block, generator) => {
    return [`MaterialCache.numTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MaterialCache_numCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.numCached')       
        this.setOutput(true, '');
        this.setColour('#8088DB');
        this.setTooltip('Total number of cached resource. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.numCached');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_numCached'] = (block, generator) => {
    return [`MaterialCache.numCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MaterialCache_sizeTotal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.sizeTotal')       
        this.setOutput(true, '');
        this.setColour('#8088DB');
        this.setTooltip('Size in bytes of all resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.sizeTotal');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_sizeTotal'] = (block, generator) => {
    return [`MaterialCache.sizeTotal`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MaterialCache_sizeCached'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.sizeCached')       
        this.setOutput(true, '');
        this.setColour('#8088DB');
        this.setTooltip('Size in bytes of all cached resources. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.sizeCached');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_sizeCached'] = (block, generator) => {
    return [`MaterialCache.sizeCached`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MaterialCache_numGlobalQueriesPending'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.numGlobalQueriesPending')       
        this.setOutput(true, '');
        this.setColour('#8088DB');
        this.setTooltip('Total number of global queries pending (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.numGlobalQueriesPending');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_numGlobalQueriesPending'] = (block, generator) => {
    return [`MaterialCache.numGlobalQueriesPending`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['MaterialCache_numGlobalQueriesLoading'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.numGlobalQueriesLoading')       
        this.setOutput(true, '');
        this.setColour('#8088DB');
        this.setTooltip('Total number of global queries loading (across all resource cache managers).    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.numGlobalQueriesLoading');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_numGlobalQueriesLoading'] = (block, generator) => {
    return [`MaterialCache.numGlobalQueriesLoading`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly typedef
Blockly.Blocks['ProceduralUniforms'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ProceduralUniforms')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#3D6B17');
        this.setTooltip('An object containing user-defined uniforms for communicating data to shaders.');
        this.setHelpUrl('https://apidocs.overte.org/ProceduralUniforms');
    }
};
javascript.javascriptGenerator.forBlock['ProceduralUniforms'] = (block, generator) => {

    return [`new ProceduralUniforms()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ProceduralData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ProceduralData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('version') 
            .setCheck('Number')
            .appendField('version');
        this.appendValueInput('vertexShaderURL') 
            .setCheck('String')
            .appendField('vertexShaderURL');
        this.appendValueInput('fragmentShaderURL') 
            .setCheck('String')
            .appendField('fragmentShaderURL');
        this.appendValueInput('channels') 
            .setCheck('Array')
            .appendField('channels');
        this.appendValueInput('uniforms') 
            .setCheck('ProceduralUniforms')
            .appendField('uniforms');
        this.setColour('#385674');
        this.setTooltip('The data used to define a Procedural shader material.');
        this.setHelpUrl('https://apidocs.overte.org/ProceduralData');
    }
};
javascript.javascriptGenerator.forBlock['ProceduralData'] = (block, generator) => {
    const _version = dfv(generator.valueToCode(block, 'version', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _vertexShaderURL = dfv(generator.valueToCode(block, 'vertexShaderURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fragmentShaderURL = dfv(generator.valueToCode(block, 'fragmentShaderURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _channels = dfv(generator.valueToCode(block, 'channels', javascript.javascriptGenerator.ORDER_ATOMIC), `[`);
    const _uniforms = dfv(generator.valueToCode(block, 'uniforms', javascript.javascriptGenerator.ORDER_ATOMIC), `{}`);

    return [`new ProceduralData(${_version},${_vertexShaderURL},${_fragmentShaderURL},${_channels},${_uniforms})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['RGBS'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('RGBS')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EB2CD0');
        this.setTooltip('<p>An RGB or SRGB color value.</p><table>  <thead>    <tr><th>Index</th><th>Type</th><th>Attributes</th><th>Default</th><th>Value</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>number</td><td></td><td></td>      <td>Red component value. Number in the range <code>0.0</code> &ndash; <code>1.0</code>.</td></tr>    <tr><td><code>1</code></td><td>number</td><td></td><td></td>      <td>Green component value. Number in the range <code>0.0</code> &ndash; <code>1.0</code>.</td></tr>    <tr><td><code>2</code></td><td>number</td><td></td><td></td>      <td>Blue component value. Number in the range <code>0.0</code> &ndash; <code>1.0</code>.</td></tr>    <tr><td><code>3</code></td><td>boolean</td><td>&lt;optional&gt;</td><td>false</td>      <td>If <code>true</code> then the color is an SRGB color.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/RGBS');
    }
};
javascript.javascriptGenerator.forBlock['RGBS'] = (block, generator) => {

    return [`new RGBS()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_MaterialResource'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.MaterialResource')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('materialVersion') 
            .setCheck('Number')
            .appendField('materialVersion');
        this.appendValueInput('materials') 
            .setCheck('Entities.Material')
            .appendField('materials');
        this.setColour('#EA9958');
        this.setTooltip('A material or set of materials used by a {@link Entities.EntityType|Material entity}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.MaterialResource');
    }
};
javascript.javascriptGenerator.forBlock['Entities_MaterialResource'] = (block, generator) => {
    const _materialVersion = dfv(generator.valueToCode(block, 'materialVersion', javascript.javascriptGenerator.ORDER_ATOMIC), `1`);
    const _materials = dfv(generator.valueToCode(block, 'materials', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Entities.MaterialResource(${_materialVersion},${_materials})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_Material'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.Material')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('model') 
            .setCheck('String')
            .appendField('model');
        this.appendValueInput('emissive') 
            .setCheck('ColorFloat')
            .appendField('emissive');
        this.appendValueInput('opacity') 
            .setCheck('Number')
            .appendField('opacity');
        this.appendValueInput('unlit') 
            .setCheck('Boolean')
            .appendField('unlit');
        this.appendValueInput('albedo') 
            .setCheck('ColorFloat')
            .appendField('albedo');
        this.appendValueInput('roughness') 
            .setCheck('Number')
            .appendField('roughness');
        this.appendValueInput('metallic') 
            .setCheck('Number')
            .appendField('metallic');
        this.appendValueInput('scattering') 
            .setCheck('Number')
            .appendField('scattering');
        this.appendValueInput('emissiveMap') 
            .setCheck('String')
            .appendField('emissiveMap');
        this.appendValueInput('albedoMap') 
            .setCheck('String')
            .appendField('albedoMap');
        this.appendValueInput('opacityMap') 
            .setCheck('String')
            .appendField('opacityMap');
        this.appendValueInput('opacityMapMode') 
            .setCheck('String')
            .appendField('opacityMapMode');
        this.appendValueInput('opacityCutoff') 
            .setCheck('Number')
            .appendField('opacityCutoff');
        this.appendValueInput('cullFaceMode') 
            .setCheck('String')
            .appendField('cullFaceMode');
        this.appendValueInput('roughnessMap') 
            .setCheck('String')
            .appendField('roughnessMap');
        this.appendValueInput('glossMap') 
            .setCheck('String')
            .appendField('glossMap');
        this.appendValueInput('metallicMap') 
            .setCheck('String')
            .appendField('metallicMap');
        this.appendValueInput('specularMap') 
            .setCheck('String')
            .appendField('specularMap');
        this.appendValueInput('normalMap') 
            .setCheck('String')
            .appendField('normalMap');
        this.appendValueInput('bumpMap') 
            .setCheck('String')
            .appendField('bumpMap');
        this.appendValueInput('occlusionMap') 
            .setCheck('String')
            .appendField('occlusionMap');
        this.appendValueInput('scatteringMap') 
            .setCheck('String')
            .appendField('scatteringMap');
        this.appendValueInput('lightMap') 
            .setCheck('String')
            .appendField('lightMap');
        this.appendValueInput('texCoordTransform0') 
            .setCheck('Mat4')
            .appendField('texCoordTransform0');
        this.appendValueInput('texCoordTransform1') 
            .setCheck('Mat4')
            .appendField('texCoordTransform1');
        this.appendValueInput('lightmapParams') 
            .setCheck('String')
            .appendField('lightmapParams');
        this.appendValueInput('materialParams') 
            .setCheck('String')
            .appendField('materialParams');
        this.appendValueInput('defaultFallthrough') 
            .setCheck('Boolean')
            .appendField('defaultFallthrough');
        this.appendValueInput('procedural') 
            .setCheck('ProceduralData')
            .appendField('procedural');
        this.appendValueInput('shade') 
            .setCheck('ColorFloat')
            .appendField('shade');
        this.appendValueInput('shadeMap') 
            .setCheck('String')
            .appendField('shadeMap');
        this.appendValueInput('shadingShift') 
            .setCheck('Number')
            .appendField('shadingShift');
        this.appendValueInput('shadingShiftMap') 
            .setCheck('String')
            .appendField('shadingShiftMap');
        this.appendValueInput('shadingToony') 
            .setCheck('Number')
            .appendField('shadingToony');
        this.appendValueInput('matcap') 
            .setCheck('ColorFloat')
            .appendField('matcap');
        this.appendValueInput('matcapMap') 
            .setCheck('String')
            .appendField('matcapMap');
        this.appendValueInput('parametricRim') 
            .setCheck('ColorFloat')
            .appendField('parametricRim');
        this.appendValueInput('parametricRimFresnelPower') 
            .setCheck('Number')
            .appendField('parametricRimFresnelPower');
        this.appendValueInput('parametricRimLift') 
            .setCheck('Number')
            .appendField('parametricRimLift');
        this.appendValueInput('rimMap') 
            .setCheck('String')
            .appendField('rimMap');
        this.appendValueInput('rimLightingMix') 
            .setCheck('Number')
            .appendField('rimLightingMix');
        this.appendValueInput('outlineWidthMode') 
            .setCheck('String')
            .appendField('outlineWidthMode');
        this.appendValueInput('outlineWidth') 
            .setCheck('Number')
            .appendField('outlineWidth');
        this.appendValueInput('outline') 
            .setCheck('ColorFloat')
            .appendField('outline');
        this.appendValueInput('uvAnimationMaskMap') 
            .setCheck('String')
            .appendField('uvAnimationMaskMap');
        this.appendValueInput('uvAnimationScrollXSpeed') 
            .setCheck('Number')
            .appendField('uvAnimationScrollXSpeed');
        this.appendValueInput('uvAnimationScrollYSpeed') 
            .setCheck('Number')
            .appendField('uvAnimationScrollYSpeed');
        this.appendValueInput('uvAnimationRotationSpeed') 
            .setCheck('Number')
            .appendField('uvAnimationRotationSpeed');
        this.setColour('#EA9958');
        this.setTooltip('A material used in a {@link Entities.MaterialResource|MaterialResource}.');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.Material');
    }
};
javascript.javascriptGenerator.forBlock['Entities_Material'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _model = dfv(generator.valueToCode(block, 'model', javascript.javascriptGenerator.ORDER_ATOMIC), `"hifi_pbr"`);
    const _emissive = dfv(generator.valueToCode(block, 'emissive', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _opacity = dfv(generator.valueToCode(block, 'opacity', javascript.javascriptGenerator.ORDER_ATOMIC), `1.0`);
    const _unlit = dfv(generator.valueToCode(block, 'unlit', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _albedo = dfv(generator.valueToCode(block, 'albedo', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _roughness = dfv(generator.valueToCode(block, 'roughness', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _metallic = dfv(generator.valueToCode(block, 'metallic', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _scattering = dfv(generator.valueToCode(block, 'scattering', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _emissiveMap = dfv(generator.valueToCode(block, 'emissiveMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _albedoMap = dfv(generator.valueToCode(block, 'albedoMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _opacityMap = dfv(generator.valueToCode(block, 'opacityMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _opacityMapMode = dfv(generator.valueToCode(block, 'opacityMapMode', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _opacityCutoff = dfv(generator.valueToCode(block, 'opacityCutoff', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _cullFaceMode = dfv(generator.valueToCode(block, 'cullFaceMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"CULL_BACK"`);
    const _roughnessMap = dfv(generator.valueToCode(block, 'roughnessMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _glossMap = dfv(generator.valueToCode(block, 'glossMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _metallicMap = dfv(generator.valueToCode(block, 'metallicMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _specularMap = dfv(generator.valueToCode(block, 'specularMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _normalMap = dfv(generator.valueToCode(block, 'normalMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _bumpMap = dfv(generator.valueToCode(block, 'bumpMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _occlusionMap = dfv(generator.valueToCode(block, 'occlusionMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scatteringMap = dfv(generator.valueToCode(block, 'scatteringMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _lightMap = dfv(generator.valueToCode(block, 'lightMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _texCoordTransform0 = dfv(generator.valueToCode(block, 'texCoordTransform0', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _texCoordTransform1 = dfv(generator.valueToCode(block, 'texCoordTransform1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _lightmapParams = dfv(generator.valueToCode(block, 'lightmapParams', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _materialParams = dfv(generator.valueToCode(block, 'materialParams', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultFallthrough = dfv(generator.valueToCode(block, 'defaultFallthrough', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _procedural = dfv(generator.valueToCode(block, 'procedural', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shade = dfv(generator.valueToCode(block, 'shade', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shadeMap = dfv(generator.valueToCode(block, 'shadeMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shadingShift = dfv(generator.valueToCode(block, 'shadingShift', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _shadingShiftMap = dfv(generator.valueToCode(block, 'shadingShiftMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shadingToony = dfv(generator.valueToCode(block, 'shadingToony', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _matcap = dfv(generator.valueToCode(block, 'matcap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _matcapMap = dfv(generator.valueToCode(block, 'matcapMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parametricRim = dfv(generator.valueToCode(block, 'parametricRim', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parametricRimFresnelPower = dfv(generator.valueToCode(block, 'parametricRimFresnelPower', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _parametricRimLift = dfv(generator.valueToCode(block, 'parametricRimLift', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rimMap = dfv(generator.valueToCode(block, 'rimMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rimLightingMix = dfv(generator.valueToCode(block, 'rimLightingMix', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _outlineWidthMode = dfv(generator.valueToCode(block, 'outlineWidthMode', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);
    const _outlineWidth = dfv(generator.valueToCode(block, 'outlineWidth', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _outline = dfv(generator.valueToCode(block, 'outline', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _uvAnimationMaskMap = dfv(generator.valueToCode(block, 'uvAnimationMaskMap', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _uvAnimationScrollXSpeed = dfv(generator.valueToCode(block, 'uvAnimationScrollXSpeed', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _uvAnimationScrollYSpeed = dfv(generator.valueToCode(block, 'uvAnimationScrollYSpeed', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _uvAnimationRotationSpeed = dfv(generator.valueToCode(block, 'uvAnimationRotationSpeed', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Entities.Material(${_name},${_model},${_emissive},${_opacity},${_unlit},${_albedo},${_roughness},${_metallic},${_scattering},${_emissiveMap},${_albedoMap},${_opacityMap},${_opacityMapMode},${_opacityCutoff},${_cullFaceMode},${_roughnessMap},${_glossMap},${_metallicMap},${_specularMap},${_normalMap},${_bumpMap},${_occlusionMap},${_scatteringMap},${_lightMap},${_texCoordTransform0},${_texCoordTransform1},${_lightmapParams},${_materialParams},${_defaultFallthrough},${_procedural},${_shade},${_shadeMap},${_shadingShift},${_shadingShiftMap},${_shadingToony},${_matcap},${_matcapMap},${_parametricRim},${_parametricRimFresnelPower},${_parametricRimLift},${_rimMap},${_rimLightingMix},${_outlineWidthMode},${_outlineWidth},${_outline},${_uvAnimationMaskMap},${_uvAnimationScrollXSpeed},${_uvAnimationScrollYSpeed},${_uvAnimationRotationSpeed})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['IntersectionType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('IntersectionType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9CDFA1');
        this.setTooltip('<p>The type of an intersection.</p><table>  <thead>    <tr><th>Name</th><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td>INTERSECTED_NONE</td><td><code>0</code></td><td>Intersected nothing.</td></tr>    <tr><td>INTERSECTED_ENTITY</td><td><code>1</code></td><td>Intersected an entity.</td></tr>    <tr><td>INTERSECTED_LOCAL_ENTITY</td><td><code>2</code></td><td>Intersected a local entity.</td></tr>    <tr><td>INTERSECTED_AVATAR</td><td><code>3</code></td><td>Intersected an avatar.</td></tr>    <tr><td>INTERSECTED_HUD</td><td><code>4</code></td><td>Intersected the HUD surface.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/IntersectionType');
    }
};
javascript.javascriptGenerator.forBlock['IntersectionType'] = (block, generator) => {

    return [`new IntersectionType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['PickType_Ray'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickType.Ray')       
        this.setOutput(true, '');
        this.setColour('#F0D8C7');
        this.setTooltip('Ray picks intersect a ray with objects in front of them, along their direction.');
        this.setHelpUrl('https://apidocs.overte.org/PickType.html#.Ray');
    }
};
javascript.javascriptGenerator.forBlock['PickType_Ray'] = (block, generator) => {
    return [`PickType.Ray`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['PickType_Parabola'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickType.Parabola')       
        this.setOutput(true, '');
        this.setColour('#F0D8C7');
        this.setTooltip('Parabola picks intersect a parabola with objects in front of them, along their arc.');
        this.setHelpUrl('https://apidocs.overte.org/PickType.html#.Parabola');
    }
};
javascript.javascriptGenerator.forBlock['PickType_Parabola'] = (block, generator) => {
    return [`PickType.Parabola`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['PickType_Stylus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickType.Stylus')       
        this.setOutput(true, '');
        this.setColour('#F0D8C7');
        this.setTooltip('Stylus picks provide "tapping" functionality on or into flat surfaces.');
        this.setHelpUrl('https://apidocs.overte.org/PickType.html#.Stylus');
    }
};
javascript.javascriptGenerator.forBlock['PickType_Stylus'] = (block, generator) => {
    return [`PickType.Stylus`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['PickType_Collision'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickType.Collision')       
        this.setOutput(true, '');
        this.setColour('#F0D8C7');
        this.setTooltip('Collision picks intersect a collision volume with avatars and entities that have     collisions.');
        this.setHelpUrl('https://apidocs.overte.org/PickType.html#.Collision');
    }
};
javascript.javascriptGenerator.forBlock['PickType_Collision'] = (block, generator) => {
    return [`PickType.Collision`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly typedef
Blockly.Blocks['PickType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F0D8C7');
        this.setTooltip('<p>A type of pick.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>{@link PickType|PickType.Ray}</code></td><td>Ray picks intersect a ray with objects in front of       them, along their direction.</td></tr>    <tr><td><code>{@link PickType|PickType.Parabola}</code></td><td>Parabola picks intersect a parabola with objects      in front of them, along their arc.</td></tr>    <tr><td><code>{@link PickType|PickType.Stylus}</code></td><td>Stylus picks provide "tapping" functionality on or      into flat surfaces.</td></tr>    <tr><td><code>{@link PickType|PickType.Collision}</code></td><td>Collision picks intersect a collision volume       with avatars and entities that have collisions.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/PickType');
    }
};
javascript.javascriptGenerator.forBlock['PickType'] = (block, generator) => {

    return [`new PickType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Recording~loadRecordingCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording~loadRecordingCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#C5564D');
        this.setTooltip('Called when a {@link Recording.loadRecording} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Recording~loadRecordingCallback');
    }
};
javascript.javascriptGenerator.forBlock['Recording~loadRecordingCallback'] = (block, generator) => {

    return [`new Recording~loadRecordingCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Recording_loadRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.loadRecording')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('callback') 
            .setCheck('Recording~loadRecordingCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Loads a recording so that it is ready for playing.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.loadRecording');
    }
};
javascript.javascriptGenerator.forBlock['Recording_loadRecording'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Recording.loadRecording(${_url},${_callback});\n`;};


// Blockly function
Blockly.Blocks['Recording_startPlaying'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.startPlaying')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Starts playing the recording currently loaded or paused.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.startPlaying');
    }
};
javascript.javascriptGenerator.forBlock['Recording_startPlaying'] = (block, generator) => {


    return `Recording.startPlaying();\n`;};


// Blockly function
Blockly.Blocks['Recording_pausePlayer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.pausePlayer')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Pauses playback of the recording currently playing. Use {@link Recording.startPlaying|startPlaying} to resume playback or {@link Recording.stopPlaying|stopPlaying} to stop playback.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.pausePlayer');
    }
};
javascript.javascriptGenerator.forBlock['Recording_pausePlayer'] = (block, generator) => {


    return `Recording.pausePlayer();\n`;};


// Blockly function
Blockly.Blocks['Recording_stopPlaying'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.stopPlaying')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Stops playing the recording currently playing or paused.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.stopPlaying');
    }
};
javascript.javascriptGenerator.forBlock['Recording_stopPlaying'] = (block, generator) => {


    return `Recording.stopPlaying();\n`;};


// Blockly function
Blockly.Blocks['Recording_isPlaying'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.isPlaying')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets whether a recording is currently playing.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.isPlaying');
    }
};
javascript.javascriptGenerator.forBlock['Recording_isPlaying'] = (block, generator) => {

return [`Recording.isPlaying()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_isPaused'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.isPaused')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets whether recording playback is currently paused.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.isPaused');
    }
};
javascript.javascriptGenerator.forBlock['Recording_isPaused'] = (block, generator) => {

return [`Recording.isPaused()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_playerElapsed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.playerElapsed')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets the current playback time in the loaded recording, in seconds.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.playerElapsed');
    }
};
javascript.javascriptGenerator.forBlock['Recording_playerElapsed'] = (block, generator) => {

return [`Recording.playerElapsed()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_playerLength'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.playerLength')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets the length of the loaded recording, in seconds.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.playerLength');
    }
};
javascript.javascriptGenerator.forBlock['Recording_playerLength'] = (block, generator) => {

return [`Recording.playerLength()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_setPlayerVolume'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayerVolume')
        // Returns data

        // Params data
        this.appendValueInput('volume') 
            .setCheck('Number')
            .appendField('volume');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Sets the playback audio volume.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayerVolume');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayerVolume'] = (block, generator) => {
    const _volume = dfv(generator.valueToCode(block, 'volume', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Recording.setPlayerVolume(${_volume});\n`;};


// Blockly function
Blockly.Blocks['Recording_setPlayerAudioOffset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayerAudioOffset')
        // Returns data

        // Params data
        this.appendValueInput('audioOffset') 
            .setCheck('Number')
            .appendField('audioOffset');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('<p class="important">Not implemented: This method is not implemented yet.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayerAudioOffset');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayerAudioOffset'] = (block, generator) => {
    const _audioOffset = dfv(generator.valueToCode(block, 'audioOffset', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Recording.setPlayerAudioOffset(${_audioOffset});\n`;};


// Blockly function
Blockly.Blocks['Recording_setPlayerTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayerTime')
        // Returns data

        // Params data
        this.appendValueInput('time') 
            .setCheck('Number')
            .appendField('time');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Sets the current playback time in the loaded recording.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayerTime');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayerTime'] = (block, generator) => {
    const _time = dfv(generator.valueToCode(block, 'time', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Recording.setPlayerTime(${_time});\n`;};


// Blockly function
Blockly.Blocks['Recording_setPlayerLoop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayerLoop')
        // Returns data

        // Params data
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Sets whether playback should repeat in a loop.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayerLoop');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayerLoop'] = (block, generator) => {
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Recording.setPlayerLoop(${_loop});\n`;};


// Blockly function
Blockly.Blocks['Recording_setPlayerUseDisplayName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayerUseDisplayName')
        // Returns data

        // Params data
        this.appendValueInput('useDisplayName') 
            .setCheck('Boolean')
            .appendField('useDisplayName');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Sets whether recording playback will use the display name that the recording was made with.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayerUseDisplayName');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayerUseDisplayName'] = (block, generator) => {
    const _useDisplayName = dfv(generator.valueToCode(block, 'useDisplayName', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Recording.setPlayerUseDisplayName(${_useDisplayName});\n`;};


// Blockly function
Blockly.Blocks['Recording_setPlayerUseSkeletonModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayerUseSkeletonModel')
        // Returns data

        // Params data
        this.appendValueInput('useSkeletonModel') 
            .setCheck('Boolean')
            .appendField('useSkeletonModel');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Sets whether recording playback will use the avatar model that the recording was made with.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayerUseSkeletonModel');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayerUseSkeletonModel'] = (block, generator) => {
    const _useSkeletonModel = dfv(generator.valueToCode(block, 'useSkeletonModel', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Recording.setPlayerUseSkeletonModel(${_useSkeletonModel});\n`;};


// Blockly function
Blockly.Blocks['Recording_setPlayFromCurrentLocation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.setPlayFromCurrentLocation')
        // Returns data

        // Params data
        this.appendValueInput('playFromCurrentLocation') 
            .setCheck('Boolean')
            .appendField('playFromCurrentLocation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Sets whether recordings are played at the current avatar location or the recorded location.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.setPlayFromCurrentLocation');
    }
};
javascript.javascriptGenerator.forBlock['Recording_setPlayFromCurrentLocation'] = (block, generator) => {
    const _playFromCurrentLocation = dfv(generator.valueToCode(block, 'playFromCurrentLocation', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Recording.setPlayFromCurrentLocation(${_playFromCurrentLocation});\n`;};


// Blockly function
Blockly.Blocks['Recording_getPlayerUseDisplayName'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.getPlayerUseDisplayName')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets whether recording playback will use the display name that the recording was made with.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.getPlayerUseDisplayName');
    }
};
javascript.javascriptGenerator.forBlock['Recording_getPlayerUseDisplayName'] = (block, generator) => {

return [`Recording.getPlayerUseDisplayName()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_getPlayerUseSkeletonModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.getPlayerUseSkeletonModel')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets whether recording playback will use the avatar model that the recording was made with.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.getPlayerUseSkeletonModel');
    }
};
javascript.javascriptGenerator.forBlock['Recording_getPlayerUseSkeletonModel'] = (block, generator) => {

return [`Recording.getPlayerUseSkeletonModel()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_getPlayFromCurrentLocation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.getPlayFromCurrentLocation')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets whether recordings are played at the current avatar location or the recorded location.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.getPlayFromCurrentLocation');
    }
};
javascript.javascriptGenerator.forBlock['Recording_getPlayFromCurrentLocation'] = (block, generator) => {

return [`Recording.getPlayFromCurrentLocation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_startRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.startRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Starts making a recording.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.startRecording');
    }
};
javascript.javascriptGenerator.forBlock['Recording_startRecording'] = (block, generator) => {


    return `Recording.startRecording();\n`;};


// Blockly function
Blockly.Blocks['Recording_stopRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.stopRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Stops making a recording. The recording may be saved using {@link Recording.saveRecording|saveRecording} or {@link Recording.saveRecordingToAsset|saveRecordingToAsset}, or immediately played back with {@link Recording.loadLastRecording|loadLastRecording}.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.stopRecording');
    }
};
javascript.javascriptGenerator.forBlock['Recording_stopRecording'] = (block, generator) => {


    return `Recording.stopRecording();\n`;};


// Blockly function
Blockly.Blocks['Recording_isRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.isRecording')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets whether a recording is currently being made.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.isRecording');
    }
};
javascript.javascriptGenerator.forBlock['Recording_isRecording'] = (block, generator) => {

return [`Recording.isRecording()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_recorderElapsed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.recorderElapsed')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets the duration of the recording currently being made or recently made, in seconds.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.recorderElapsed');
    }
};
javascript.javascriptGenerator.forBlock['Recording_recorderElapsed'] = (block, generator) => {

return [`Recording.recorderElapsed()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_getDefaultRecordingSaveDirectory'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.getDefaultRecordingSaveDirectory')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#C5564D');
        this.setTooltip('Gets the default directory that recordings are saved in.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.getDefaultRecordingSaveDirectory');
    }
};
javascript.javascriptGenerator.forBlock['Recording_getDefaultRecordingSaveDirectory'] = (block, generator) => {

return [`Recording.getDefaultRecordingSaveDirectory()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_saveRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.saveRecording')
        // Returns data

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Saves the most recently made recording to a file.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.saveRecording');
    }
};
javascript.javascriptGenerator.forBlock['Recording_saveRecording'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Recording.saveRecording(${_filename});\n`;};


// Blockly typedef
Blockly.Blocks['Recording~saveRecordingToAssetCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording~saveRecordingToAssetCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#C5564D');
        this.setTooltip('Called when a {@link Recording.saveRecordingToAsset} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Recording~saveRecordingToAssetCallback');
    }
};
javascript.javascriptGenerator.forBlock['Recording~saveRecordingToAssetCallback'] = (block, generator) => {

    return [`new Recording~saveRecordingToAssetCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Recording_saveRecordingToAsset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.saveRecordingToAsset')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('callback') 
            .setCheck('Recording~saveRecordingToAssetCallback')
            .appendField('callback');

        this.setColour('#C5564D');
        this.setTooltip('Saves the most recently made recording to the domain\'s asset server.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.saveRecordingToAsset');
    }
};
javascript.javascriptGenerator.forBlock['Recording_saveRecordingToAsset'] = (block, generator) => {
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Recording.saveRecordingToAsset(${_callback})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Recording_loadLastRecording'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Recording.loadLastRecording')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C5564D');
        this.setTooltip('Loads the most recently made recording and plays it back on your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Recording.html#.loadLastRecording');
    }
};
javascript.javascriptGenerator.forBlock['Recording_loadLastRecording'] = (block, generator) => {


    return `Recording.loadLastRecording();\n`;};


// Blockly typedef
Blockly.Blocks['AntialiasingMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AntialiasingMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#834AE1');
        this.setTooltip('Antialiasing modes. <table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>0</code></td><td>NONE</td><td>Antialiasing is disabled.</td></tr>    <tr><td><code>1</code></td><td>TAA</td><td>Temporal Antialiasing.</td></tr>    <tr><td><code>2</code></td><td>FXAA</td><td>FXAA.</td></tr>    <tr><td><code>3</code></td><td>MODE_COUNT</td><td>Inducates number of antialiasing modes</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/AntialiasingMode');
    }
};
javascript.javascriptGenerator.forBlock['AntialiasingMode'] = (block, generator) => {

    return [`new AntialiasingMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['SubmeshIntersection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SubmeshIntersection')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('worldIntersectionPoint') 
            .setCheck('Vec3')
            .appendField('worldIntersectionPoint');
        this.appendValueInput('meshIntersectionPoint') 
            .setCheck('Vec3')
            .appendField('meshIntersectionPoint');
        this.appendValueInput('partIndex') 
            .setCheck('Number')
            .appendField('partIndex');
        this.appendValueInput('shapeID') 
            .setCheck('Number')
            .appendField('shapeID');
        this.appendValueInput('subMeshIndex') 
            .setCheck('Number')
            .appendField('subMeshIndex');
        this.appendValueInput('subMeshName') 
            .setCheck('String')
            .appendField('subMeshName');
        this.appendValueInput('subMeshTriangleWorld') 
            .setCheck('Triangle')
            .appendField('subMeshTriangleWorld');
        this.appendValueInput('subMeshNormal') 
            .setCheck('Vec3')
            .appendField('subMeshNormal');
        this.appendValueInput('subMeshTriangle') 
            .setCheck('Triangle')
            .appendField('subMeshTriangle');
        this.setColour('#E2F5D8');
        this.setTooltip('A submesh intersection point.');
        this.setHelpUrl('https://apidocs.overte.org/SubmeshIntersection');
    }
};
javascript.javascriptGenerator.forBlock['SubmeshIntersection'] = (block, generator) => {
    const _worldIntersectionPoint = dfv(generator.valueToCode(block, 'worldIntersectionPoint', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _meshIntersectionPoint = dfv(generator.valueToCode(block, 'meshIntersectionPoint', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _partIndex = dfv(generator.valueToCode(block, 'partIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _shapeID = dfv(generator.valueToCode(block, 'shapeID', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _subMeshIndex = dfv(generator.valueToCode(block, 'subMeshIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _subMeshName = dfv(generator.valueToCode(block, 'subMeshName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _subMeshTriangleWorld = dfv(generator.valueToCode(block, 'subMeshTriangleWorld', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _subMeshNormal = dfv(generator.valueToCode(block, 'subMeshNormal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _subMeshTriangle = dfv(generator.valueToCode(block, 'subMeshTriangle', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new SubmeshIntersection(${_worldIntersectionPoint},${_meshIntersectionPoint},${_partIndex},${_shapeID},${_subMeshIndex},${_subMeshName},${_subMeshTriangleWorld},${_subMeshNormal},${_subMeshTriangle})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_DownloadDataError'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.DownloadDataError')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('errorMessage') 
            .setCheck('String')
            .appendField('errorMessage');
        this.setColour('#9AEDEA');
        this.setTooltip('The success or failure of an {@link Assets.downloadData} call.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.DownloadDataError');
    }
};
javascript.javascriptGenerator.forBlock['Assets_DownloadDataError'] = (block, generator) => {
    const _errorMessage = dfv(generator.valueToCode(block, 'errorMessage', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.DownloadDataError(${_errorMessage})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_GetOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.GetOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('decompress') 
            .setCheck('Boolean')
            .appendField('decompress');
        this.appendValueInput('responseType') 
            .setCheck('Assets.ResponseType')
            .appendField('responseType');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('Source and download options for {@link Assets.getAsset}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.GetOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_GetOptions'] = (block, generator) => {
    const _decompress = dfv(generator.valueToCode(block, 'decompress', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), `"text"`);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.GetOptions(${_decompress},${_responseType},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_GetResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.GetResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('cached') 
            .setCheck('Boolean')
            .appendField('cached');
        this.appendValueInput('contentType') 
            .setCheck('String')
            .appendField('contentType');
        this.appendValueInput('decompressed') 
            .setCheck('Boolean')
            .appendField('decompressed');
        this.appendValueInput('hash') 
            .setCheck('String')
            .appendField('hash');
        this.appendValueInput('hashURL') 
            .setCheck('String')
            .appendField('hashURL');
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('response') 
            .setCheck('String')
            .appendField('response');
        this.appendValueInput('responseType') 
            .setCheck('Assets.ResponseType')
            .appendField('responseType');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('wasRedirected') 
            .setCheck('Boolean')
            .appendField('wasRedirected');
        this.setColour('#9AEDEA');
        this.setTooltip('Result value returned by {@link Assets.getAsset}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.GetResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_GetResult'] = (block, generator) => {
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _cached = dfv(generator.valueToCode(block, 'cached', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _contentType = dfv(generator.valueToCode(block, 'contentType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _decompressed = dfv(generator.valueToCode(block, 'decompressed', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _hash = dfv(generator.valueToCode(block, 'hash', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hashURL = dfv(generator.valueToCode(block, 'hashURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _response = dfv(generator.valueToCode(block, 'response', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _wasRedirected = dfv(generator.valueToCode(block, 'wasRedirected', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Assets.GetResult(${_byteLength},${_cached},${_contentType},${_decompressed},${_hash},${_hashURL},${_path},${_response},${_responseType},${_url},${_wasRedirected})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_ResolveOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.ResolveOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('Source options for {@link Assets.resolveAsset}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.ResolveOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_ResolveOptions'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.ResolveOptions(${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_ResolveResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.ResolveResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('hash') 
            .setCheck('String')
            .appendField('hash');
        this.appendValueInput('hashURL') 
            .setCheck('String')
            .appendField('hashURL');
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('wasRedirected') 
            .setCheck('Boolean')
            .appendField('wasRedirected');
        this.setColour('#9AEDEA');
        this.setTooltip('Result value returned by {@link Assets.resolveAsset}.<p>Note: If resolving a hash, a file of that hash need not be present on the asset server for the hash to resolve.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.ResolveResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_ResolveResult'] = (block, generator) => {
    const _hash = dfv(generator.valueToCode(block, 'hash', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hashURL = dfv(generator.valueToCode(block, 'hashURL', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _wasRedirected = dfv(generator.valueToCode(block, 'wasRedirected', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Assets.ResolveResult(${_hash},${_hashURL},${_path},${_url},${_wasRedirected})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_DecompressOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.DecompressOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('data') 
            .setCheck('Array')
            .appendField('data');
        this.appendValueInput('responseType') 
            .setCheck('Assets.ResponseType')
            .appendField('responseType');
        this.setColour('#9AEDEA');
        this.setTooltip('Content and decompression options for {@link Assets.decompressData}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.DecompressOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_DecompressOptions'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), `text`);

    return [`new Assets.DecompressOptions(${_data},${_responseType})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_DecompressResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.DecompressResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('contentType') 
            .setCheck('String')
            .appendField('contentType');
        this.appendValueInput('decompressed') 
            .setCheck('Boolean')
            .appendField('decompressed');
        this.appendValueInput('response') 
            .setCheck('String')
            .appendField('response');
        this.appendValueInput('responseType') 
            .setCheck('Assets.ResponseType')
            .appendField('responseType');
        this.setColour('#9AEDEA');
        this.setTooltip('Result value returned by {@link Assets.decompressData}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.DecompressResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_DecompressResult'] = (block, generator) => {
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _contentType = dfv(generator.valueToCode(block, 'contentType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _decompressed = dfv(generator.valueToCode(block, 'decompressed', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _response = dfv(generator.valueToCode(block, 'response', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.DecompressResult(${_byteLength},${_contentType},${_decompressed},${_response},${_responseType})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_CompressOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.CompressOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');
        this.appendValueInput('level') 
            .setCheck('Number')
            .appendField('level');
        this.setColour('#9AEDEA');
        this.setTooltip('Content and compression options for {@link Assets.compressData}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.CompressOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_CompressOptions'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _level = dfv(generator.valueToCode(block, 'level', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Assets.CompressOptions(${_data},${_level})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_CompressResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.CompressResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('compressed') 
            .setCheck('Boolean')
            .appendField('compressed');
        this.appendValueInput('contentType') 
            .setCheck('String')
            .appendField('contentType');
        this.appendValueInput('data') 
            .setCheck('Array')
            .appendField('data');
        this.setColour('#9AEDEA');
        this.setTooltip('Result value returned by {@link Assets.compressData}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.CompressResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_CompressResult'] = (block, generator) => {
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _compressed = dfv(generator.valueToCode(block, 'compressed', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _contentType = dfv(generator.valueToCode(block, 'contentType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.CompressResult(${_byteLength},${_compressed},${_contentType},${_data})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_PutOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.PutOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('compress') 
            .setCheck('Boolean')
            .appendField('compress');
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.setColour('#9AEDEA');
        this.setTooltip('Content and upload options for {@link Assets.putAsset}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.PutOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_PutOptions'] = (block, generator) => {
    const _compress = dfv(generator.valueToCode(block, 'compress', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.PutOptions(${_compress},${_data},${_path})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_PutResult'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.PutResult')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('byteLength') 
            .setCheck('Number')
            .appendField('byteLength');
        this.appendValueInput('compressed') 
            .setCheck('Boolean')
            .appendField('compressed');
        this.appendValueInput('contentType') 
            .setCheck('String')
            .appendField('contentType');
        this.appendValueInput('hash') 
            .setCheck('String')
            .appendField('hash');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.setColour('#9AEDEA');
        this.setTooltip('Result value returned by {@link Assets.putAsset}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.PutResult');
    }
};
javascript.javascriptGenerator.forBlock['Assets_PutResult'] = (block, generator) => {
    const _byteLength = dfv(generator.valueToCode(block, 'byteLength', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _compressed = dfv(generator.valueToCode(block, 'compressed', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _contentType = dfv(generator.valueToCode(block, 'contentType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hash = dfv(generator.valueToCode(block, 'hash', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.PutResult(${_byteLength},${_compressed},${_contentType},${_hash},${_url},${_path})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_QueryCacheMetaOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.QueryCacheMetaOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('Source for {@link Assets.queryCacheMeta}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.QueryCacheMetaOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_QueryCacheMetaOptions'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.QueryCacheMetaOptions(${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_LoadFromCacheOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.LoadFromCacheOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('decompress') 
            .setCheck('Boolean')
            .appendField('decompress');
        this.appendValueInput('responseType') 
            .setCheck('Assets.ResponseType')
            .appendField('responseType');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('Source and retrieval options for {@link Assets.loadFromCache}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.LoadFromCacheOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_LoadFromCacheOptions'] = (block, generator) => {
    const _decompress = dfv(generator.valueToCode(block, 'decompress', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), `text`);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.LoadFromCacheOptions(${_decompress},${_responseType},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets_SaveToCacheOptions'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.SaveToCacheOptions')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');
        this.appendValueInput('headers') 
            .setCheck('Assets.SaveToCacheHeaders')
            .appendField('headers');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#9AEDEA');
        this.setTooltip('The data to save to the cache and cache options for {@link Assets.saveToCache}.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.SaveToCacheOptions');
    }
};
javascript.javascriptGenerator.forBlock['Assets_SaveToCacheOptions'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _headers = dfv(generator.valueToCode(block, 'headers', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.SaveToCacheOptions(${_data},${_headers},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets~uploadDataCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~uploadDataCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.uploadData} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~uploadDataCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~uploadDataCallback'] = (block, generator) => {

    return [`new Assets~uploadDataCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_uploadData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.uploadData')
        // Returns data

        // Params data
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');
        this.appendValueInput('callback') 
            .setCheck('Assets~uploadDataCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Uploads content to the asset server, storing it in a SHA256-named file.<p>Note: The asset server destroys any unmapped SHA256-named file at server restart. Use {@link Assets.setMapping} to set a path-to-hash mapping for the new file.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.uploadData');
    }
};
javascript.javascriptGenerator.forBlock['Assets_uploadData'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.uploadData(${_data},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~downloadDataCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~downloadDataCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.downloadData} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~downloadDataCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~downloadDataCallback'] = (block, generator) => {

    return [`new Assets~downloadDataCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_downloadData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.downloadData')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('callback') 
            .setCheck('Assets~downloadDataCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Downloads content from the asset server, from a SHA256-named file.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.downloadData');
    }
};
javascript.javascriptGenerator.forBlock['Assets_downloadData'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.downloadData(${_url},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~setMappingCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~setMappingCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.setMapping} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~setMappingCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~setMappingCallback'] = (block, generator) => {

    return [`new Assets~setMappingCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_setMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.setMapping')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('hash') 
            .setCheck('String')
            .appendField('hash');
        this.appendValueInput('callback') 
            .setCheck('Assets~setMappingCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Sets a path-to-hash mapping within the asset server.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.setMapping');
    }
};
javascript.javascriptGenerator.forBlock['Assets_setMapping'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hash = dfv(generator.valueToCode(block, 'hash', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.setMapping(${_path},${_hash},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~getMappingCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~getMappingCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.getMapping} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~getMappingCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~getMappingCallback'] = (block, generator) => {

    return [`new Assets~getMappingCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_getMapping'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.getMapping')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('callback') 
            .setCheck('Assets~getMappingCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Gets the hash for a path within the asset server. The hash is for the unbaked or baked version of theasset, according to the asset server setting for the particular path.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.getMapping');
    }
};
javascript.javascriptGenerator.forBlock['Assets_getMapping'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.getMapping(${_path},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~setBakingEnabledCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~setBakingEnabledCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.setBakingEnabled} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~setBakingEnabledCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~setBakingEnabledCallback'] = (block, generator) => {

    return [`new Assets~setBakingEnabledCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_setBakingEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.setBakingEnabled')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('enabled') 
            .setCheck('Boolean')
            .appendField('enabled');
        this.appendValueInput('callback') 
            .setCheck('Assets~setBakingEnabledCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Sets whether or not to bake an asset in the asset server.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.setBakingEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Assets_setBakingEnabled'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _enabled = dfv(generator.valueToCode(block, 'enabled', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.setBakingEnabled(${_path},${_enabled},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets_CallbackDetails'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.CallbackDetails')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('scope') 
            .setCheck('object')
            .appendField('scope');
        this.appendValueInput('callback') 
            .setCheck('Assets~compressDataCallback')
            .appendField('callback');
        this.setColour('#9AEDEA');
        this.setTooltip('Details of a callback function.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.CallbackDetails');
    }
};
javascript.javascriptGenerator.forBlock['Assets_CallbackDetails'] = (block, generator) => {
    const _scope = dfv(generator.valueToCode(block, 'scope', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Assets.CallbackDetails(${_scope},${_callback})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Assets~getAssetCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~getAssetCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.getAsset} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~getAssetCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~getAssetCallback'] = (block, generator) => {

    return [`new Assets~getAssetCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_getAsset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.getAsset')
        // Returns data

        // Params data
        this.appendValueInput('source') 
            .setCheck('String')
            .appendField('source');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~getAssetCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Downloads content from the asset server.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.getAsset');
    }
};
javascript.javascriptGenerator.forBlock['Assets_getAsset'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.getAsset(${_source},${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~putAssetCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~putAssetCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.putAsset} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~putAssetCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~putAssetCallback'] = (block, generator) => {

    return [`new Assets~putAssetCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_putAsset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.putAsset')
        // Returns data

        // Params data
        this.appendValueInput('options') 
            .setCheck('String')
            .appendField('options');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~putAssetCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Uploads content to the asset server and sets a path-to-hash mapping.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.putAsset');
    }
};
javascript.javascriptGenerator.forBlock['Assets_putAsset'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.putAsset(${_options},${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~deleteAssetCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~deleteAssetCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.deleteAsset} call is complete.<p class="important">Not implemented: This type is not implemented yet.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Assets~deleteAssetCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~deleteAssetCallback'] = (block, generator) => {

    return [`new Assets~deleteAssetCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_deleteAsset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.deleteAsset')
        // Returns data

        // Params data
        this.appendValueInput('options') 
            .setCheck('Assets.DeleteOptions')
            .appendField('options');
        this.appendValueInput('scope') 
            .setCheck('object')
            .appendField('scope');
        this.appendValueInput('callback') 
            .setCheck('Assets~deleteAssetCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Deletes content from the asset server.<p class="important">Not implemented: This method is not implemented yet.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.deleteAsset');
    }
};
javascript.javascriptGenerator.forBlock['Assets_deleteAsset'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scope = dfv(generator.valueToCode(block, 'scope', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.deleteAsset(${_options},${_scope},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~resolveAssetCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~resolveAssetCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.resolveAsset} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~resolveAssetCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~resolveAssetCallback'] = (block, generator) => {

    return [`new Assets~resolveAssetCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_resolveAsset'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.resolveAsset')
        // Returns data

        // Params data
        this.appendValueInput('source') 
            .setCheck('String')
            .appendField('source');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~resolveAssetCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Resolves and returns information on a hash or a path in the asset server.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.resolveAsset');
    }
};
javascript.javascriptGenerator.forBlock['Assets_resolveAsset'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.resolveAsset(${_source},${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~decompressDataCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~decompressDataCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.decompressData} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~decompressDataCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~decompressDataCallback'] = (block, generator) => {

    return [`new Assets~decompressDataCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_decompressData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.decompressData')
        // Returns data

        // Params data
        this.appendValueInput('source') 
            .setCheck('Assets.DecompressOptions')
            .appendField('source');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~decompressDataCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Decompresses data in memory using gunzip.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.decompressData');
    }
};
javascript.javascriptGenerator.forBlock['Assets_decompressData'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.decompressData(${_source},${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~compressDataCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~compressDataCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.compressData} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~compressDataCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~compressDataCallback'] = (block, generator) => {

    return [`new Assets~compressDataCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_compressData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.compressData')
        // Returns data

        // Params data
        this.appendValueInput('source') 
            .setCheck('String')
            .appendField('source');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~compressDataCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Compresses data in memory using gzip.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.compressData');
    }
};
javascript.javascriptGenerator.forBlock['Assets_compressData'] = (block, generator) => {
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.compressData(${_source},${_scopeOrCallback},${_callback});\n`;};


// Blockly function
Blockly.Blocks['Assets_initializeCache'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.initializeCache')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#9AEDEA');
        this.setTooltip('Initializes the cache if it isn\'t already initialized.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.initializeCache');
    }
};
javascript.javascriptGenerator.forBlock['Assets_initializeCache'] = (block, generator) => {

return [`Assets.initializeCache()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Assets_canWriteCacheValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.canWriteCacheValue')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#9AEDEA');
        this.setTooltip('Checks whether the script can write to the cache.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.canWriteCacheValue');
    }
};
javascript.javascriptGenerator.forBlock['Assets_canWriteCacheValue'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Assets.canWriteCacheValue(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Assets~getCacheStatusCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~getCacheStatusCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when a {@link Assets.getCacheStatus} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~getCacheStatusCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~getCacheStatusCallback'] = (block, generator) => {

    return [`new Assets~getCacheStatusCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_getCacheStatus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.getCacheStatus')
        // Returns data

        // Params data
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~getCacheStatusCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Gets the current cache status.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.getCacheStatus');
    }
};
javascript.javascriptGenerator.forBlock['Assets_getCacheStatus'] = (block, generator) => {
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.getCacheStatus(${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~queryCacheMetaCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~queryCacheMetaCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when {@link Assets.queryCacheMeta} is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~queryCacheMetaCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~queryCacheMetaCallback'] = (block, generator) => {

    return [`new Assets~queryCacheMetaCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_queryCacheMeta'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.queryCacheMeta')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~queryCacheMetaCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Gets information about the status of an asset in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.queryCacheMeta');
    }
};
javascript.javascriptGenerator.forBlock['Assets_queryCacheMeta'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.queryCacheMeta(${_path},${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~loadFromCacheCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~loadFromCacheCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.loadFromCache} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~loadFromCacheCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~loadFromCacheCallback'] = (block, generator) => {

    return [`new Assets~loadFromCacheCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_loadFromCache'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.loadFromCache')
        // Returns data

        // Params data
        this.appendValueInput('options') 
            .setCheck('String')
            .appendField('options');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~loadFromCacheCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Retrieves data from the cache directly, without downloading it.');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.loadFromCache');
    }
};
javascript.javascriptGenerator.forBlock['Assets_loadFromCache'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.loadFromCache(${_options},${_scopeOrCallback},${_callback});\n`;};


// Blockly typedef
Blockly.Blocks['Assets~saveToCacheCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets~saveToCacheCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9AEDEA');
        this.setTooltip('Called when an {@link Assets.saveToCache} call is complete.');
        this.setHelpUrl('https://apidocs.overte.org/Assets~saveToCacheCallback');
    }
};
javascript.javascriptGenerator.forBlock['Assets~saveToCacheCallback'] = (block, generator) => {

    return [`new Assets~saveToCacheCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Assets_saveToCache'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.saveToCache')
        // Returns data

        // Params data
        this.appendValueInput('options') 
            .setCheck('Assets.SaveToCacheOptions')
            .appendField('options');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~saveToCacheCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Saves asset data to the cache directly, without downloading it from a URL.<p>Note: Can only be used in Interface, avatar, and assignment client scripts.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.saveToCache');
    }
};
javascript.javascriptGenerator.forBlock['Assets_saveToCache'] = (block, generator) => {
    const _options = dfv(generator.valueToCode(block, 'options', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.saveToCache(${_options},${_scopeOrCallback},${_callback});\n`;};


// Blockly function
Blockly.Blocks['Assets_saveToCacheurldataheadersscopeOrCallbackcallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Assets.saveToCache')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');
        this.appendValueInput('headers') 
            .setCheck('Assets.SaveToCacheHeaders')
            .appendField('headers');
        this.appendValueInput('scopeOrCallback') 
            .setCheck('object')
            .appendField('scopeOrCallback');
        this.appendValueInput('callback') 
            .setCheck('Assets~saveToCacheCallback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9AEDEA');
        this.setTooltip('Saves asset data to the cache directly, without downloading it from a URL.<p>Note: Can only be used in Interface, avatar, and assignment client scripts.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Assets.html#.saveToCache');
    }
};
javascript.javascriptGenerator.forBlock['Assets_saveToCacheurldataheadersscopeOrCallbackcallback'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _headers = dfv(generator.valueToCode(block, 'headers', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scopeOrCallback = dfv(generator.valueToCode(block, 'scopeOrCallback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = dfv(generator.valueToCode(block, 'callback', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Assets.saveToCache(${_url},${_data},${_headers},${_scopeOrCallback},${_callback});\n`;};


// Blockly function
Blockly.Blocks['console_info'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.info')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs an "INFO" message to the program log and triggers {@link Script.infoMessage}. The message logged is "INFO -" followed by the message values separated by spaces.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.info');
    }
};
javascript.javascriptGenerator.forBlock['console_info'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.info(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_log'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.log')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs a message to the program log and triggers {@link Script.printedMessage}.The message logged is the message values separated by spaces.<p>If a {@link console.group} is in effect, the message is indented by an amount proportional to the group level.</p>');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.log');
    }
};
javascript.javascriptGenerator.forBlock['console_log'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.log(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_debug'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.debug')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs a message to the program log and triggers {@link Script.printedMessage}.The message logged is the message values separated by spaces.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.debug');
    }
};
javascript.javascriptGenerator.forBlock['console_debug'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.debug(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_warn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.warn')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs a "WARNING" message to the program log and triggers {@link Script.warningMessage}.The message logged is "WARNING - " followed by the message values separated by spaces.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.warn');
    }
};
javascript.javascriptGenerator.forBlock['console_warn'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.warn(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_error'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.error')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs an "ERROR" message to the program log and triggers {@link Script.errorMessage}.The message logged is "ERROR - " followed by the message values separated by spaces.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.error');
    }
};
javascript.javascriptGenerator.forBlock['console_error'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.error(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_exception'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.exception')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('A synonym of {@link console.error}.Logs an "ERROR" message to the program log and triggers {@link Script.errorMessage}.The message logged is "ERROR - " followed by the message values separated by spaces.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.exception');
    }
};
javascript.javascriptGenerator.forBlock['console_exception'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.exception(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_assert'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.assert')
        // Returns data

        // Params data
        this.appendValueInput('assertion') 
            .setCheck('Boolean')
            .appendField('assertion');
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs an "ERROR" message to the program log and triggers {@link Script.errorMessage}, if a test condition fails.The message logged is "ERROR - Assertion failed : " followed by the message values separated by spaces.<p>Note: Script execution continues whether or not the test condition fails.</p>');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.assert');
    }
};
javascript.javascriptGenerator.forBlock['console_assert'] = (block, generator) => {
    const _assertion = dfv(generator.valueToCode(block, 'assertion', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.assert(${_assertion},${_message});\n`;};


// Blockly function
Blockly.Blocks['console_group'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.group')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs a message to the program log and triggers {@link Script.printedMessage}, then starts indenting subsequent {@link console.log} messages until a {@link console.groupEnd}. Groups may be nested.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.group');
    }
};
javascript.javascriptGenerator.forBlock['console_group'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.group(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_groupCollapsed'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.groupCollapsed')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Has the same behavior as {@link console.group}.Logs a message to the program log and triggers {@link Script.printedMessage}, then starts indenting subsequent{@link console.log} messages until a {@link console.groupEnd}. Groups may be nested.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.groupCollapsed');
    }
};
javascript.javascriptGenerator.forBlock['console_groupCollapsed'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.groupCollapsed(${_message});\n`;};


// Blockly function
Blockly.Blocks['console_groupEnd'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.groupEnd')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Finishes a group of indented {@link console.log} messages.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.groupEnd');
    }
};
javascript.javascriptGenerator.forBlock['console_groupEnd'] = (block, generator) => {


    return `console.groupEnd();\n`;};


// Blockly function
Blockly.Blocks['console_time'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.time')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Starts a timer, logs a message to the program log, and triggers {@link Script.printedMessage}. The message logged has the timer name and "Timer started".');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.time');
    }
};
javascript.javascriptGenerator.forBlock['console_time'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.time(${_name});\n`;};


// Blockly function
Blockly.Blocks['console_timeEnd'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.timeEnd')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Finishes a timer, logs a message to the program log, and triggers {@link Script.printedMessage}. The message logged has the timer name and the number of milliseconds since the timer was started.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.timeEnd');
    }
};
javascript.javascriptGenerator.forBlock['console_timeEnd'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `console.timeEnd(${_name});\n`;};


// Blockly function
Blockly.Blocks['console_trace'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.trace')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Logs the JavaScript call stack at the point of call to the program log.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.trace');
    }
};
javascript.javascriptGenerator.forBlock['console_trace'] = (block, generator) => {


    return `console.trace();\n`;};


// Blockly function
Blockly.Blocks['console_clear'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('console.clear')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BFAFD8');
        this.setTooltip('Clears the Developer &gt; Scripting &gt; Script Log debug window.');
        this.setHelpUrl('https://apidocs.overte.org/console.html#.clear');
    }
};
javascript.javascriptGenerator.forBlock['console_clear'] = (block, generator) => {


    return `console.clear();\n`;};


// Blockly typedef
Blockly.Blocks['KeyEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('KeyEvent')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('key') 
            .setCheck('Number')
            .appendField('key');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');
        this.appendValueInput('isShifted') 
            .setCheck('Boolean')
            .appendField('isShifted');
        this.appendValueInput('isMeta') 
            .setCheck('Boolean')
            .appendField('isMeta');
        this.appendValueInput('isControl') 
            .setCheck('Boolean')
            .appendField('isControl');
        this.appendValueInput('isAlt') 
            .setCheck('Boolean')
            .appendField('isAlt');
        this.appendValueInput('isKeypad') 
            .setCheck('Boolean')
            .appendField('isKeypad');
        this.appendValueInput('isAutoRepeat') 
            .setCheck('Boolean')
            .appendField('isAutoRepeat');
        this.setColour('#49B99B');
        this.setTooltip('A keyboard key event.');
        this.setHelpUrl('https://apidocs.overte.org/KeyEvent');
    }
};
javascript.javascriptGenerator.forBlock['KeyEvent'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isShifted = dfv(generator.valueToCode(block, 'isShifted', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMeta = dfv(generator.valueToCode(block, 'isMeta', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isControl = dfv(generator.valueToCode(block, 'isControl', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isAlt = dfv(generator.valueToCode(block, 'isAlt', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isKeypad = dfv(generator.valueToCode(block, 'isKeypad', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isAutoRepeat = dfv(generator.valueToCode(block, 'isAutoRepeat', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new KeyEvent(${_key},${_text},${_isShifted},${_isMeta},${_isControl},${_isAlt},${_isKeypad},${_isAutoRepeat})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Mat4_multiply'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.multiply')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('m1') 
            .setCheck('Mat4')
            .appendField('m1');
        this.appendValueInput('m2') 
            .setCheck('Mat4')
            .appendField('m2');

        this.setColour('#80F740');
        this.setTooltip('Multiplies two matrices.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.multiply');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_multiply'] = (block, generator) => {
    const _m1 = dfv(generator.valueToCode(block, 'm1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _m2 = dfv(generator.valueToCode(block, 'm2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.multiply(${_m1},${_m2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_createFromRotAndTrans'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.createFromRotAndTrans')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('rot') 
            .setCheck('Quat')
            .appendField('rot');
        this.appendValueInput('trans') 
            .setCheck('Vec3')
            .appendField('trans');

        this.setColour('#80F740');
        this.setTooltip('Creates a matrix that represents a rotation and translation.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.createFromRotAndTrans');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_createFromRotAndTrans'] = (block, generator) => {
    const _rot = dfv(generator.valueToCode(block, 'rot', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _trans = dfv(generator.valueToCode(block, 'trans', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.createFromRotAndTrans(${_rot},${_trans})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_createFromScaleRotAndTrans'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.createFromScaleRotAndTrans')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('scale') 
            .setCheck('Vec3')
            .appendField('scale');
        this.appendValueInput('rot') 
            .setCheck('Quat')
            .appendField('rot');
        this.appendValueInput('trans') 
            .setCheck('Vec3')
            .appendField('trans');

        this.setColour('#80F740');
        this.setTooltip('Creates a matrix that represents a scale, rotation, and translation.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.createFromScaleRotAndTrans');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_createFromScaleRotAndTrans'] = (block, generator) => {
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rot = dfv(generator.valueToCode(block, 'rot', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _trans = dfv(generator.valueToCode(block, 'trans', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.createFromScaleRotAndTrans(${_scale},${_rot},${_trans})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_createFromColumns'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.createFromColumns')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('col0') 
            .setCheck('Vec4')
            .appendField('col0');
        this.appendValueInput('col1') 
            .setCheck('Vec4')
            .appendField('col1');
        this.appendValueInput('col2') 
            .setCheck('Vec4')
            .appendField('col2');
        this.appendValueInput('col3') 
            .setCheck('Vec4')
            .appendField('col3');

        this.setColour('#80F740');
        this.setTooltip('Creates a matrix from columns of values.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.createFromColumns');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_createFromColumns'] = (block, generator) => {
    const _col0 = dfv(generator.valueToCode(block, 'col0', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _col1 = dfv(generator.valueToCode(block, 'col1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _col2 = dfv(generator.valueToCode(block, 'col2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _col3 = dfv(generator.valueToCode(block, 'col3', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.createFromColumns(${_col0},${_col1},${_col2},${_col3})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_createFromArray'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.createFromArray')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('arr') 
            .setCheck('Array')
            .appendField('arr');

        this.setColour('#80F740');
        this.setTooltip('Creates a matrix from an array of values.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.createFromArray');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_createFromArray'] = (block, generator) => {
    const _arr = dfv(generator.valueToCode(block, 'arr', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.createFromArray(${_arr})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_extractTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.extractTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Extracts the translation from a matrix.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.extractTranslation');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_extractTranslation'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.extractTranslation(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_extractRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.extractRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Extracts the rotation from a matrix.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.extractRotation');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_extractRotation'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.extractRotation(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_extractScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.extractScale')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Extracts the scale from a matrix.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.extractScale');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_extractScale'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.extractScale(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_transformPoint'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.transformPoint')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');
        this.appendValueInput('point') 
            .setCheck('Vec3')
            .appendField('point');

        this.setColour('#80F740');
        this.setTooltip('Transforms a point into a new coordinate system: the point value is scaled, rotated, and translated.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.transformPoint');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_transformPoint'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _point = dfv(generator.valueToCode(block, 'point', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.transformPoint(${_m},${_point})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_transformVector'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.transformVector')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');
        this.appendValueInput('vector') 
            .setCheck('Vec3')
            .appendField('vector');

        this.setColour('#80F740');
        this.setTooltip('Transforms a vector into a new coordinate system: the vector is scaled and rotated.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.transformVector');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_transformVector'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _vector = dfv(generator.valueToCode(block, 'vector', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.transformVector(${_m},${_vector})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_inverse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.inverse')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Calculates the inverse of a matrix.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.inverse');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_inverse'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.inverse(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_getFront'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.getFront')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Gets the "forward" direction that the camera would face if its orientation was set to the rotation contained in a matrix. The High Fidelity camera has axes x = right, y = up, -z = forward. <p>Synonym for {@link Mat4.getForward|getForward}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.getFront');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_getFront'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.getFront(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_getForward'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.getForward')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Gets the "forward" direction that the camera would face if its orientation was set to the rotation contained in amatrix. The High Fidelity camera has axes x = right, y = up, -z = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.getForward');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_getForward'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.getForward(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_getRight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.getRight')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Gets the "right" direction that the camera would have if its orientation was set to the rotation contained in a matrix. The High Fidelity camera has axes x = right, y = up, -z = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.getRight');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_getRight'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.getRight(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_getUp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.getUp')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');

        this.setColour('#80F740');
        this.setTooltip('Gets the "up" direction that the camera would have if its orientation was set to the rotation contained in a matrix. The High Fidelity camera has axes x = right, y = up, -z = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.getUp');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_getUp'] = (block, generator) => {
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Mat4.getUp(${_m})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Mat4_print'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4.print')
        // Returns data

        // Params data
        this.appendValueInput('label') 
            .setCheck('String')
            .appendField('label');
        this.appendValueInput('m') 
            .setCheck('Mat4')
            .appendField('m');
        this.appendValueInput('transpose') 
            .setCheck('Boolean')
            .appendField('transpose');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#80F740');
        this.setTooltip('Prints a matrix to the program log as a label followed by the matrix\'s values.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4.html#.print');
    }
};
javascript.javascriptGenerator.forBlock['Mat4_print'] = (block, generator) => {
    const _label = dfv(generator.valueToCode(block, 'label', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _m = dfv(generator.valueToCode(block, 'm', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _transpose = dfv(generator.valueToCode(block, 'transpose', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Mat4.print(${_label},${_m},${_transpose});\n`;};


// Blockly typedef
Blockly.Blocks['Menu_MenuItemProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Menu.MenuItemProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('menuName') 
            .setCheck('String')
            .appendField('menuName');
        this.appendValueInput('menuItemName') 
            .setCheck('String')
            .appendField('menuItemName');
        this.appendValueInput('isCheckable') 
            .setCheck('Boolean')
            .appendField('isCheckable');
        this.appendValueInput('isChecked') 
            .setCheck('Boolean')
            .appendField('isChecked');
        this.appendValueInput('isSeparator') 
            .setCheck('Boolean')
            .appendField('isSeparator');
        this.appendValueInput('shortcutKey') 
            .setCheck('String')
            .appendField('shortcutKey');
        this.appendValueInput('shortcutKeyEvent') 
            .setCheck('KeyEvent')
            .appendField('shortcutKeyEvent');
        this.appendValueInput('position') 
            .setCheck('Number')
            .appendField('position');
        this.appendValueInput('beforeItem') 
            .setCheck('String')
            .appendField('beforeItem');
        this.appendValueInput('afterItem') 
            .setCheck('String')
            .appendField('afterItem');
        this.appendValueInput('grouping') 
            .setCheck('String')
            .appendField('grouping');
        this.setColour('#B61541');
        this.setTooltip('A set of properties that can be passed to {@link Menu.addMenuItem} to create a new menu item.If none of the properties, <code>position</code>, <code>beforeItem</code>, <code>afterItem</code>, or <code>grouping</code> are specified, the menu item will be placed at the end of the menu.');
        this.setHelpUrl('https://apidocs.overte.org/Menu.html#.MenuItemProperties');
    }
};
javascript.javascriptGenerator.forBlock['Menu_MenuItemProperties'] = (block, generator) => {
    const _menuName = dfv(generator.valueToCode(block, 'menuName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _menuItemName = dfv(generator.valueToCode(block, 'menuItemName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isCheckable = dfv(generator.valueToCode(block, 'isCheckable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isChecked = dfv(generator.valueToCode(block, 'isChecked', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isSeparator = dfv(generator.valueToCode(block, 'isSeparator', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _shortcutKey = dfv(generator.valueToCode(block, 'shortcutKey', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _shortcutKeyEvent = dfv(generator.valueToCode(block, 'shortcutKeyEvent', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _beforeItem = dfv(generator.valueToCode(block, 'beforeItem', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _afterItem = dfv(generator.valueToCode(block, 'afterItem', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _grouping = dfv(generator.valueToCode(block, 'grouping', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Menu.MenuItemProperties(${_menuName},${_menuItemName},${_isCheckable},${_isChecked},${_isSeparator},${_shortcutKey},${_shortcutKeyEvent},${_position},${_beforeItem},${_afterItem},${_grouping})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MouseEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MouseEvent')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('button') 
            .setCheck('String')
            .appendField('button');
        this.appendValueInput('isLeftButton') 
            .setCheck('Boolean')
            .appendField('isLeftButton');
        this.appendValueInput('isMiddleButton') 
            .setCheck('Boolean')
            .appendField('isMiddleButton');
        this.appendValueInput('isRightButton') 
            .setCheck('Boolean')
            .appendField('isRightButton');
        this.appendValueInput('isShifted') 
            .setCheck('Boolean')
            .appendField('isShifted');
        this.appendValueInput('isMeta') 
            .setCheck('Boolean')
            .appendField('isMeta');
        this.appendValueInput('isControl') 
            .setCheck('Boolean')
            .appendField('isControl');
        this.appendValueInput('isAlt') 
            .setCheck('Boolean')
            .appendField('isAlt');
        this.setColour('#F1CA92');
        this.setTooltip('A controller mouse movement or button event.');
        this.setHelpUrl('https://apidocs.overte.org/MouseEvent');
    }
};
javascript.javascriptGenerator.forBlock['MouseEvent'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _button = dfv(generator.valueToCode(block, 'button', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isLeftButton = dfv(generator.valueToCode(block, 'isLeftButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMiddleButton = dfv(generator.valueToCode(block, 'isMiddleButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isRightButton = dfv(generator.valueToCode(block, 'isRightButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isShifted = dfv(generator.valueToCode(block, 'isShifted', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMeta = dfv(generator.valueToCode(block, 'isMeta', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isControl = dfv(generator.valueToCode(block, 'isControl', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isAlt = dfv(generator.valueToCode(block, 'isAlt', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new MouseEvent(${_x},${_y},${_button},${_isLeftButton},${_isMiddleButton},${_isRightButton},${_isShifted},${_isMeta},${_isControl},${_isAlt})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PointerEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PointerEvent')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('String')
            .appendField('type');
        this.appendValueInput('id') 
            .setCheck('Number')
            .appendField('id');
        this.appendValueInput('pos2D') 
            .setCheck('Vec2')
            .appendField('pos2D');
        this.appendValueInput('pos3D') 
            .setCheck('Vec3')
            .appendField('pos3D');
        this.appendValueInput('normal') 
            .setCheck('Vec3')
            .appendField('normal');
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('button') 
            .setCheck('String')
            .appendField('button');
        this.appendValueInput('isPrimaryButton') 
            .setCheck('Boolean')
            .appendField('isPrimaryButton');
        this.appendValueInput('isLeftButton') 
            .setCheck('Boolean')
            .appendField('isLeftButton');
        this.appendValueInput('isSecondaryButton') 
            .setCheck('Boolean')
            .appendField('isSecondaryButton');
        this.appendValueInput('isRightButton') 
            .setCheck('Boolean')
            .appendField('isRightButton');
        this.appendValueInput('isTertiaryButton') 
            .setCheck('Boolean')
            .appendField('isTertiaryButton');
        this.appendValueInput('isMiddleButton') 
            .setCheck('Boolean')
            .appendField('isMiddleButton');
        this.appendValueInput('isPrimaryHeld') 
            .setCheck('Boolean')
            .appendField('isPrimaryHeld');
        this.appendValueInput('isSecondaryHeld') 
            .setCheck('Boolean')
            .appendField('isSecondaryHeld');
        this.appendValueInput('isTertiaryHeld') 
            .setCheck('Boolean')
            .appendField('isTertiaryHeld');
        this.appendValueInput('keyboardModifiers') 
            .setCheck('KeyboardModifiers')
            .appendField('keyboardModifiers');
        this.setColour('#7F899E');
        this.setTooltip('A 2D or 3D mouse or similar pointer event.');
        this.setHelpUrl('https://apidocs.overte.org/PointerEvent');
    }
};
javascript.javascriptGenerator.forBlock['PointerEvent'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _pos2D = dfv(generator.valueToCode(block, 'pos2D', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _pos3D = dfv(generator.valueToCode(block, 'pos3D', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _normal = dfv(generator.valueToCode(block, 'normal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _button = dfv(generator.valueToCode(block, 'button', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isPrimaryButton = dfv(generator.valueToCode(block, 'isPrimaryButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isLeftButton = dfv(generator.valueToCode(block, 'isLeftButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isSecondaryButton = dfv(generator.valueToCode(block, 'isSecondaryButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isRightButton = dfv(generator.valueToCode(block, 'isRightButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isTertiaryButton = dfv(generator.valueToCode(block, 'isTertiaryButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMiddleButton = dfv(generator.valueToCode(block, 'isMiddleButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isPrimaryHeld = dfv(generator.valueToCode(block, 'isPrimaryHeld', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isSecondaryHeld = dfv(generator.valueToCode(block, 'isSecondaryHeld', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isTertiaryHeld = dfv(generator.valueToCode(block, 'isTertiaryHeld', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _keyboardModifiers = dfv(generator.valueToCode(block, 'keyboardModifiers', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PointerEvent(${_type},${_id},${_pos2D},${_pos3D},${_normal},${_direction},${_button},${_isPrimaryButton},${_isLeftButton},${_isSecondaryButton},${_isRightButton},${_isTertiaryButton},${_isMiddleButton},${_isPrimaryHeld},${_isSecondaryHeld},${_isTertiaryHeld},${_keyboardModifiers})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['KeyboardModifiers'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('KeyboardModifiers')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#61033C');
        this.setTooltip('<p>A KeyboardModifiers value is used to specify which modifier keys on the keyboard are pressed. The value is the sum (bitwise OR) of the relevant combination of values from the following table:</p><table>  <thead>    <tr><th>Key</th><th>Hexadecimal value</th><th>Decimal value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td>Shift</td><td><code>0x02000000</code></td><td><code>33554432</code></td>        <td>A Shift key on the keyboard is pressed.</td></tr>    <tr><td>Control</td><td><code>0x04000000</code></td><td><code>67108864</code></td>        <td>A control key on the keyboard is pressed. On Windows the "control" key is the Ctrl key; on OSX it is the Command         key.</td></tr>    <tr><td>Alt</td><td><code>0x08000000</code></td><td><code>134217728</code></td>        <td>An Alt key on the keyboard is pressed.</td></tr>    <tr><td>Meta</td><td><code>0x10000000</code></td><td><code>268435456</code></td>        <td>A meta key on the keyboard is pressed. On Windows the "meta" key is the Windows key; on OSX it is the Control         (Splat) key.</td></tr>    <tr><td>Keypad</td><td><code>0x20000000</code></td><td><code>536870912</code></td>        <td>A keypad button is pressed.</td></tr>    <tr><td>Group</td><td><code>0x40000000</code></td><td><code>1073741824</code></td>        <td>X11 operating system only: An AltGr / Mode_switch key on the keyboard is pressed.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/KeyboardModifiers');
    }
};
javascript.javascriptGenerator.forBlock['KeyboardModifiers'] = (block, generator) => {

    return [`new KeyboardModifiers()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Quat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('z') 
            .setCheck('Number')
            .appendField('z');
        this.appendValueInput('w') 
            .setCheck('Number')
            .appendField('w');
        this.setColour('#28D944');
        this.setTooltip('A quaternion value. See also the {@link Quat|Quat} API.');
        this.setHelpUrl('https://apidocs.overte.org/Quat');
    }
};
javascript.javascriptGenerator.forBlock['Quat'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _z = dfv(generator.valueToCode(block, 'z', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _w = dfv(generator.valueToCode(block, 'w', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Quat(${_x},${_y},${_z},${_w})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Quat_IDENTITY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.IDENTITY')       
        this.setOutput(true, '');
        this.setColour('#28D944');
        this.setTooltip('<code>{ x: 0, y: 0, z: 0, w: 1 }</code> : The identity rotation, i.e., no rotation.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.IDENTITY');
    }
};
javascript.javascriptGenerator.forBlock['Quat_IDENTITY'] = (block, generator) => {
    return [`Quat.IDENTITY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Quat_multiply'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.multiply')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q1') 
            .setCheck('Quat')
            .appendField('q1');
        this.appendValueInput('q2') 
            .setCheck('Quat')
            .appendField('q2');

        this.setColour('#28D944');
        this.setTooltip('Multiplies two quaternions.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.multiply');
    }
};
javascript.javascriptGenerator.forBlock['Quat_multiply'] = (block, generator) => {
    const _q1 = dfv(generator.valueToCode(block, 'q1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q2 = dfv(generator.valueToCode(block, 'q2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.multiply(${_q1},${_q2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_normalize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.normalize')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');

        this.setColour('#28D944');
        this.setTooltip('Normalizes a quaternion.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.normalize');
    }
};
javascript.javascriptGenerator.forBlock['Quat_normalize'] = (block, generator) => {
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.normalize(${_q})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_conjugate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.conjugate')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');

        this.setColour('#28D944');
        this.setTooltip('Calculates the conjugate of a quaternion. For a unit quaternion, its conjugate is the same as its {@link Quat.inverse|Quat.inverse}.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.conjugate');
    }
};
javascript.javascriptGenerator.forBlock['Quat_conjugate'] = (block, generator) => {
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.conjugate(${_q})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_lookAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.lookAt')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('eye') 
            .setCheck('Vec3')
            .appendField('eye');
        this.appendValueInput('target') 
            .setCheck('Vec3')
            .appendField('target');
        this.appendValueInput('up') 
            .setCheck('Vec3')
            .appendField('up');

        this.setColour('#28D944');
        this.setTooltip('Calculates a camera orientation given an eye position, point of interest, and "up" direction. The camera\'s negative z-axis is the forward direction. The result has zero roll about its forward direction with respect to the given "up" direction.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.lookAt');
    }
};
javascript.javascriptGenerator.forBlock['Quat_lookAt'] = (block, generator) => {
    const _eye = dfv(generator.valueToCode(block, 'eye', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _target = dfv(generator.valueToCode(block, 'target', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _up = dfv(generator.valueToCode(block, 'up', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.lookAt(${_eye},${_target},${_up})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_lookAtSimple'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.lookAtSimple')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('eye') 
            .setCheck('Vec3')
            .appendField('eye');
        this.appendValueInput('target') 
            .setCheck('Vec3')
            .appendField('target');

        this.setColour('#28D944');
        this.setTooltip('Calculates a camera orientation given an eye position and point of interest. The camera\'s negative z-axis is the forward direction. The result has zero roll about its forward direction.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.lookAtSimple');
    }
};
javascript.javascriptGenerator.forBlock['Quat_lookAtSimple'] = (block, generator) => {
    const _eye = dfv(generator.valueToCode(block, 'eye', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _target = dfv(generator.valueToCode(block, 'target', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.lookAtSimple(${_eye},${_target})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_rotationBetween'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.rotationBetween')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#28D944');
        this.setTooltip('Calculates the shortest rotation from a first vector onto a second.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.rotationBetween');
    }
};
javascript.javascriptGenerator.forBlock['Quat_rotationBetween'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.rotationBetween(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_fromVec3Degrees'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.fromVec3Degrees')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('vector') 
            .setCheck('Vec3')
            .appendField('vector');

        this.setColour('#28D944');
        this.setTooltip('Generates a quaternion from a {@link Vec3} of Euler angles in degrees.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.fromVec3Degrees');
    }
};
javascript.javascriptGenerator.forBlock['Quat_fromVec3Degrees'] = (block, generator) => {
    const _vector = dfv(generator.valueToCode(block, 'vector', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.fromVec3Degrees(${_vector})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_fromVec3Radians'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.fromVec3Radians')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('vector') 
            .setCheck('Vec3')
            .appendField('vector');

        this.setColour('#28D944');
        this.setTooltip('Generates a quaternion from a {@link Vec3} of Euler angles in radians.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.fromVec3Radians');
    }
};
javascript.javascriptGenerator.forBlock['Quat_fromVec3Radians'] = (block, generator) => {
    const _vector = dfv(generator.valueToCode(block, 'vector', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.fromVec3Radians(${_vector})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_fromPitchYawRollDegrees'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.fromPitchYawRollDegrees')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('pitch') 
            .setCheck('Number')
            .appendField('pitch');
        this.appendValueInput('yaw') 
            .setCheck('Number')
            .appendField('yaw');
        this.appendValueInput('roll') 
            .setCheck('Number')
            .appendField('roll');

        this.setColour('#28D944');
        this.setTooltip('Generates a quaternion from pitch, yaw, and roll values in degrees.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.fromPitchYawRollDegrees');
    }
};
javascript.javascriptGenerator.forBlock['Quat_fromPitchYawRollDegrees'] = (block, generator) => {
    const _pitch = dfv(generator.valueToCode(block, 'pitch', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _yaw = dfv(generator.valueToCode(block, 'yaw', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _roll = dfv(generator.valueToCode(block, 'roll', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Quat.fromPitchYawRollDegrees(${_pitch},${_yaw},${_roll})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_fromPitchYawRollRadians'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.fromPitchYawRollRadians')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('pitch') 
            .setCheck('Number')
            .appendField('pitch');
        this.appendValueInput('yaw') 
            .setCheck('Number')
            .appendField('yaw');
        this.appendValueInput('roll') 
            .setCheck('Number')
            .appendField('roll');

        this.setColour('#28D944');
        this.setTooltip('Generates a quaternion from pitch, yaw, and roll values in radians.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.fromPitchYawRollRadians');
    }
};
javascript.javascriptGenerator.forBlock['Quat_fromPitchYawRollRadians'] = (block, generator) => {
    const _pitch = dfv(generator.valueToCode(block, 'pitch', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _yaw = dfv(generator.valueToCode(block, 'yaw', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _roll = dfv(generator.valueToCode(block, 'roll', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Quat.fromPitchYawRollRadians(${_pitch},${_yaw},${_roll})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_inverse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.inverse')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');

        this.setColour('#28D944');
        this.setTooltip('Calculates the inverse of a quaternion. For a unit quaternion, its inverse is the same as its    {@link Quat.conjugate|Quat.conjugate}.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.inverse');
    }
};
javascript.javascriptGenerator.forBlock['Quat_inverse'] = (block, generator) => {
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.inverse(${_q})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_getFront'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.getFront')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Gets the "front" direction that the camera would face if its orientation was set to the quaternion value.This is a synonym for {@link Quat.getForward|Quat.getForward}.The Overte camera has axes <code>x</code> = right, <code>y</code> = up, <code>-z</code> = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.getFront');
    }
};
javascript.javascriptGenerator.forBlock['Quat_getFront'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.getFront(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_getForward'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.getForward')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Gets the "forward" direction that the camera would face if its orientation was set to the quaternion value.This is a synonym for {@link Quat.getFront|Quat.getFront}.The Overte camera has axes <code>x</code> = right, <code>y</code> = up, <code>-z</code> = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.getForward');
    }
};
javascript.javascriptGenerator.forBlock['Quat_getForward'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.getForward(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_getRight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.getRight')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Gets the "right" direction that the camera would have if its orientation was set to the quaternion value.The Overte camera has axes <code>x</code> = right, <code>y</code> = up, <code>-z</code> = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.getRight');
    }
};
javascript.javascriptGenerator.forBlock['Quat_getRight'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.getRight(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_getUp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.getUp')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Gets the "up" direction that the camera would have if its orientation was set to the quaternion value.The Overte camera has axes <code>x</code> = right, <code>y</code> = up, <code>-z</code> = forward.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.getUp');
    }
};
javascript.javascriptGenerator.forBlock['Quat_getUp'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.getUp(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_safeEulerAngles'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.safeEulerAngles')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Calculates the Euler angles for the quaternion, in degrees. (The "safe" in the name signifies that the angle results will not be garbage even when the rotation is particularly difficult to decompose with pitches around +/-90 degrees.)');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.safeEulerAngles');
    }
};
javascript.javascriptGenerator.forBlock['Quat_safeEulerAngles'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.safeEulerAngles(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_angleAxis'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.angleAxis')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('angle') 
            .setCheck('Number')
            .appendField('angle');
        this.appendValueInput('axis') 
            .setCheck('Vec3')
            .appendField('axis');

        this.setColour('#28D944');
        this.setTooltip('Generates a quaternion given an angle to rotate through and an axis to rotate about.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.angleAxis');
    }
};
javascript.javascriptGenerator.forBlock['Quat_angleAxis'] = (block, generator) => {
    const _angle = dfv(generator.valueToCode(block, 'angle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _axis = dfv(generator.valueToCode(block, 'axis', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.angleAxis(${_angle},${_axis})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_axis'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.axis')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');

        this.setColour('#28D944');
        this.setTooltip('Gets the rotation axis for a quaternion.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.axis');
    }
};
javascript.javascriptGenerator.forBlock['Quat_axis'] = (block, generator) => {
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.axis(${_q})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_angle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.angle')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');

        this.setColour('#28D944');
        this.setTooltip('Gets the rotation angle for a quaternion.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.angle');
    }
};
javascript.javascriptGenerator.forBlock['Quat_angle'] = (block, generator) => {
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.angle(${_q})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_mix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.mix')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q1') 
            .setCheck('Quat')
            .appendField('q1');
        this.appendValueInput('q2') 
            .setCheck('Quat')
            .appendField('q2');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');

        this.setColour('#28D944');
        this.setTooltip('Computes a spherical linear interpolation between two rotations, safely handling two rotations that are very similar.See also, {@link Quat.slerp|Quat.slerp}.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.mix');
    }
};
javascript.javascriptGenerator.forBlock['Quat_mix'] = (block, generator) => {
    const _q1 = dfv(generator.valueToCode(block, 'q1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q2 = dfv(generator.valueToCode(block, 'q2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Quat.mix(${_q1},${_q2},${_alpha})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_slerp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.slerp')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q1') 
            .setCheck('Quat')
            .appendField('q1');
        this.appendValueInput('q2') 
            .setCheck('Quat')
            .appendField('q2');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');

        this.setColour('#28D944');
        this.setTooltip('Computes a spherical linear interpolation between two rotations, for rotations that are not very similar.See also, {@link Quat.mix|Quat.mix}.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.slerp');
    }
};
javascript.javascriptGenerator.forBlock['Quat_slerp'] = (block, generator) => {
    const _q1 = dfv(generator.valueToCode(block, 'q1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q2 = dfv(generator.valueToCode(block, 'q2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Quat.slerp(${_q1},${_q2},${_alpha})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_squad'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.squad')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('q1') 
            .setCheck('Quat')
            .appendField('q1');
        this.appendValueInput('q2') 
            .setCheck('Quat')
            .appendField('q2');
        this.appendValueInput('s1') 
            .setCheck('Quat')
            .appendField('s1');
        this.appendValueInput('s2') 
            .setCheck('Quat')
            .appendField('s2');
        this.appendValueInput('alpha') 
            .setCheck('Number')
            .appendField('alpha');

        this.setColour('#28D944');
        this.setTooltip('Computes a spherical quadrangle interpolation between two rotations along a path oriented toward two other rotations.Equivalent to: <code>Quat.slerp(Quat.slerp(q1, q2, alpha), Quat.slerp(s1, s2, alpha), 2 * alpha * (1.0 - alpha))</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.squad');
    }
};
javascript.javascriptGenerator.forBlock['Quat_squad'] = (block, generator) => {
    const _q1 = dfv(generator.valueToCode(block, 'q1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q2 = dfv(generator.valueToCode(block, 'q2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _s1 = dfv(generator.valueToCode(block, 's1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _s2 = dfv(generator.valueToCode(block, 's2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _alpha = dfv(generator.valueToCode(block, 'alpha', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Quat.squad(${_q1},${_q2},${_s1},${_s2},${_alpha})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_dot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.dot')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('q1') 
            .setCheck('Quat')
            .appendField('q1');
        this.appendValueInput('q2') 
            .setCheck('Quat')
            .appendField('q2');

        this.setColour('#28D944');
        this.setTooltip('Calculates the dot product of two quaternions. The closer the quaternions are to each other the more non-zero the value is (either positive or negative). Identical unit rotations have a dot product of +/-1.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.dot');
    }
};
javascript.javascriptGenerator.forBlock['Quat_dot'] = (block, generator) => {
    const _q1 = dfv(generator.valueToCode(block, 'q1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q2 = dfv(generator.valueToCode(block, 'q2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.dot(${_q1},${_q2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_print'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.print')
        // Returns data

        // Params data
        this.appendValueInput('label') 
            .setCheck('String')
            .appendField('label');
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');
        this.appendValueInput('asDegrees') 
            .setCheck('Boolean')
            .appendField('asDegrees');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#28D944');
        this.setTooltip('Prints to the program log a text label followed by a quaternion\'s pitch, yaw, and roll Euler angles.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.print');
    }
};
javascript.javascriptGenerator.forBlock['Quat_print'] = (block, generator) => {
    const _label = dfv(generator.valueToCode(block, 'label', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _asDegrees = dfv(generator.valueToCode(block, 'asDegrees', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Quat.print(${_label},${_q},${_asDegrees});\n`;};


// Blockly function
Blockly.Blocks['Quat_equal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.equal')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('q1') 
            .setCheck('Quat')
            .appendField('q1');
        this.appendValueInput('q2') 
            .setCheck('Quat')
            .appendField('q2');

        this.setColour('#28D944');
        this.setTooltip('Tests whether two quaternions are equal.<p><strong>Note:</strong> The quaternions must be exactly equal in order for <code>true</code> to be returned; it is often better to use {@link Quat.dot|Quat.dot} and test for closeness to +/-1.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.equal');
    }
};
javascript.javascriptGenerator.forBlock['Quat_equal'] = (block, generator) => {
    const _q1 = dfv(generator.valueToCode(block, 'q1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _q2 = dfv(generator.valueToCode(block, 'q2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.equal(${_q1},${_q2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_cancelOutRollAndPitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.cancelOutRollAndPitch')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Cancels out the roll and pitch component of a quaternion so that its completely horizontal with a yaw pointing in the given quaternion\'s direction.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.cancelOutRollAndPitch');
    }
};
javascript.javascriptGenerator.forBlock['Quat_cancelOutRollAndPitch'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.cancelOutRollAndPitch(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Quat_cancelOutRoll'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Quat.cancelOutRoll')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setColour('#28D944');
        this.setTooltip('Cancels out the roll component of a quaternion so that its horizontal axis is level.');
        this.setHelpUrl('https://apidocs.overte.org/Quat.html#.cancelOutRoll');
    }
};
javascript.javascriptGenerator.forBlock['Quat_cancelOutRoll'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Quat.cancelOutRoll(${_orientation})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly namespace
Blockly.Blocks['Scene_shouldRenderAvatars'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Scene.shouldRenderAvatars')       
        this.setOutput(true, '');
        this.setColour('#9EAD0D');
        this.setTooltip('<code>true</code> if avatars are rendered, <code>false</code> if they aren\'t.');
        this.setHelpUrl('https://apidocs.overte.org/Scene.html#.shouldRenderAvatars');
    }
};
javascript.javascriptGenerator.forBlock['Scene_shouldRenderAvatars'] = (block, generator) => {
    return [`Scene.shouldRenderAvatars`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Scene_shouldRenderEntities'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Scene.shouldRenderEntities')       
        this.setOutput(true, '');
        this.setColour('#9EAD0D');
        this.setTooltip('<code>true</code> if entities (domain, avatar, and local) are rendered,     <code>false</code> if they aren\'t.');
        this.setHelpUrl('https://apidocs.overte.org/Scene.html#.shouldRenderEntities');
    }
};
javascript.javascriptGenerator.forBlock['Scene_shouldRenderEntities'] = (block, generator) => {
    return [`Scene.shouldRenderEntities`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly signal
Blockly.Blocks['Scene_shouldRenderAvatarsChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Scene.shouldRenderAvatarsChanged');

        this.appendDummyInput('shouldRenderAvatars')
            .appendField('shouldRenderAvatars:')
            .appendField(new Blockly.FieldVariable('shouldRenderAvatarsChanged_shouldRenderAvatars'), 'shouldRenderAvatars');

        this.setColour('#9EAD0D');
        this.setTooltip('Triggered when whether or not avatars are rendered changes.');
        this.setHelpUrl('https://apidocs.overte.org/Scene.html#.shouldRenderAvatarsChanged');
    }
};
javascript.javascriptGenerator.forBlock['Scene_shouldRenderAvatarsChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const shouldRenderAvatars = generator.getVariableName(block.getFieldValue('shouldRenderAvatars'));

return `Scene.shouldRenderAvatarsChanged.connect((_shouldRenderAvatars) => { 
  ${shouldRenderAvatars} = _shouldRenderAvatars;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Scene_shouldRenderEntitiesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Scene.shouldRenderEntitiesChanged');

        this.appendDummyInput('shouldRenderEntities')
            .appendField('shouldRenderEntities:')
            .appendField(new Blockly.FieldVariable('shouldRenderEntitiesChanged_shouldRenderEntities'), 'shouldRenderEntities');

        this.setColour('#9EAD0D');
        this.setTooltip('Triggered when whether or not entities are rendered changes.');
        this.setHelpUrl('https://apidocs.overte.org/Scene.html#.shouldRenderEntitiesChanged');
    }
};
javascript.javascriptGenerator.forBlock['Scene_shouldRenderEntitiesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const shouldRenderEntities = generator.getVariableName(block.getFieldValue('shouldRenderEntities'));

return `Scene.shouldRenderEntitiesChanged.connect((_shouldRenderEntities) => { 
  ${shouldRenderEntities} = _shouldRenderEntities;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['ScriptDiscoveryService_PublicScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.PublicScript')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('type') 
            .setCheck('String')
            .appendField('type');
        this.appendValueInput('children') 
            .setCheck('Array')
            .appendField('children');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#DC89A0');
        this.setTooltip('Information on a public script, i.e., a script that\'s included in the Interface installation.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.PublicScript');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_PublicScript'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _children = dfv(generator.valueToCode(block, 'children', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ScriptDiscoveryService.PublicScript(${_name},${_type},${_children},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ScriptDiscoveryService_RunningScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.RunningScript')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('local') 
            .setCheck('Boolean')
            .appendField('local');
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.setColour('#DC89A0');
        this.setTooltip('Information on a running script.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.RunningScript');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_RunningScript'] = (block, generator) => {
    const _local = dfv(generator.valueToCode(block, 'local', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ScriptDiscoveryService.RunningScript(${_local},${_name},${_path},${_url})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['ScriptDiscoveryService_debugScriptUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.debugScriptUrl')       
        this.setOutput(true, '');
        this.setColour('#DC89A0');
        this.setTooltip('The path and name of a script to debug using the "API Debugger" developer tool    (currentAPI.js). If set, the API Debugger dialog displays the objects and values exposed by the script using    {@link Script.registerValue} and similar.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.debugScriptUrl');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_debugScriptUrl'] = (block, generator) => {
    return [`ScriptDiscoveryService.debugScriptUrl`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ScriptDiscoveryService_defaultScriptsPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.defaultScriptsPath')       
        this.setOutput(true, '');
        this.setColour('#DC89A0');
        this.setTooltip('The path where the default scripts are located in the Interface installation.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.defaultScriptsPath');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_defaultScriptsPath'] = (block, generator) => {
    return [`ScriptDiscoveryService.defaultScriptsPath`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ScriptDiscoveryService_scriptsModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.scriptsModel')       
        this.setOutput(true, '');
        this.setColour('#DC89A0');
        this.setTooltip('Information on the scripts that are in the default scripts directory of the    Interface installation.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.scriptsModel');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_scriptsModel'] = (block, generator) => {
    return [`ScriptDiscoveryService.scriptsModel`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['ScriptDiscoveryService_scriptsModelFilter'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.scriptsModelFilter')       
        this.setOutput(true, '');
        this.setColour('#DC89A0');
        this.setTooltip('Sorted and filtered information on the scripts that are in the default    scripts directory of the Interface installation.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.scriptsModelFilter');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_scriptsModelFilter'] = (block, generator) => {
    return [`ScriptDiscoveryService.scriptsModelFilter`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['ScriptDiscoveryService_loadOneScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.loadOneScript')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC89A0');
        this.setTooltip('Starts running an Interface script, if it isn\'t already running. The script is automatically loaded next time Interfacestarts.<p>This is a synonym for calling {@link ScriptDiscoveryService.loadScript|loadScript} with just the script URL.</p><p class="availableIn"><strong>Supported Script Types:</strong> Interface Scripts &bull; Avatar Scripts</p><p>See also, {@link Script.load}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.loadOneScript');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_loadOneScript'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `ScriptDiscoveryService.loadOneScript(${_url});\n`;};


// Blockly function
Blockly.Blocks['ScriptDiscoveryService_loadScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.loadScript')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('isUserLoaded') 
            .setCheck('Boolean')
            .appendField('isUserLoaded');
        this.appendValueInput('loadScriptFromEditor') 
            .setCheck('Boolean')
            .appendField('loadScriptFromEditor');
        this.appendValueInput('activateMainWindow') 
            .setCheck('Boolean')
            .appendField('activateMainWindow');
        this.appendValueInput('reload') 
            .setCheck('Boolean')
            .appendField('reload');
        this.appendValueInput('quitWhenFinished') 
            .setCheck('Boolean')
            .appendField('quitWhenFinished');

        this.setColour('#DC89A0');
        this.setTooltip('Starts running an Interface script, if it isn\'t already running.<p class="availableIn"><strong>Supported Script Types:</strong> Interface Scripts &bull; Avatar Scripts</p><p>See also, {@link Script.load}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.loadScript');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_loadScript'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _isUserLoaded = dfv(generator.valueToCode(block, 'isUserLoaded', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _loadScriptFromEditor = dfv(generator.valueToCode(block, 'loadScriptFromEditor', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _activateMainWindow = dfv(generator.valueToCode(block, 'activateMainWindow', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _reload = dfv(generator.valueToCode(block, 'reload', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _quitWhenFinished = dfv(generator.valueToCode(block, 'quitWhenFinished', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`ScriptDiscoveryService.loadScript(${_url},${_isUserLoaded},${_loadScriptFromEditor},${_activateMainWindow},${_reload},${_quitWhenFinished})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptDiscoveryService_stopScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.stopScript')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('restart') 
            .setCheck('Boolean')
            .appendField('restart');

        this.setColour('#DC89A0');
        this.setTooltip('Stops or restarts an Interface script.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.stopScript');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_stopScript'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _restart = dfv(generator.valueToCode(block, 'restart', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

return [`ScriptDiscoveryService.stopScript(${_url},${_restart})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptDiscoveryService_reloadAllScripts'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.reloadAllScripts')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC89A0');
        this.setTooltip('Restarts all Interface, avatar, and client entity scripts after clearing the scripts cache.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.reloadAllScripts');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_reloadAllScripts'] = (block, generator) => {


    return `ScriptDiscoveryService.reloadAllScripts();\n`;};


// Blockly function
Blockly.Blocks['ScriptDiscoveryService_stopAllScripts'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.stopAllScripts')
        // Returns data

        // Params data
        this.appendValueInput('restart') 
            .setCheck('Boolean')
            .appendField('restart');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC89A0');
        this.setTooltip('Stops or restarts all Interface scripts. The scripts cache is not cleared. If restarting, avatar and client entityscripts are also restarted.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.stopAllScripts');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_stopAllScripts'] = (block, generator) => {
    const _restart = dfv(generator.valueToCode(block, 'restart', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `ScriptDiscoveryService.stopAllScripts(${_restart});\n`;};


// Blockly function
Blockly.Blocks['ScriptDiscoveryService_getRunning'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.getRunning')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC89A0');
        this.setTooltip('Gets a list of all Interface scripts that are currently running.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.getRunning');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_getRunning'] = (block, generator) => {

return [`ScriptDiscoveryService.getRunning()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ScriptDiscoveryService_getPublic'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptDiscoveryService.getPublic')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC89A0');
        this.setTooltip('Gets a list of all script files that are in the default scripts directory of the Interface installation.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.getPublic');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_getPublic'] = (block, generator) => {

return [`ScriptDiscoveryService.getPublic()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_scriptCountChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.scriptCountChanged');


        this.setColour('#DC89A0');
        this.setTooltip('Triggered when the number of Interface scripts running changes.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.scriptCountChanged');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_scriptCountChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ScriptDiscoveryService.scriptCountChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_scriptsReloading'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.scriptsReloading');


        this.setColour('#DC89A0');
        this.setTooltip('Triggered when Interface, avatar, and client entity scripts are restarting as a result of{@link ScriptDiscoveryService.reloadAllScripts|reloadAllScripts} or{@link ScriptDiscoveryService.stopAllScripts|stopAllScripts}.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.scriptsReloading');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_scriptsReloading'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ScriptDiscoveryService.scriptsReloading.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_scriptLoadError'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.scriptLoadError');

        this.appendDummyInput('url')
            .appendField('url:')
            .appendField(new Blockly.FieldVariable('scriptLoadError_url'), 'url');
        this.appendDummyInput('error')
            .appendField('error:')
            .appendField(new Blockly.FieldVariable('scriptLoadError_error'), 'error');

        this.setColour('#DC89A0');
        this.setTooltip('Triggered when a script could not be loaded.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.scriptLoadError');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_scriptLoadError'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const url = generator.getVariableName(block.getFieldValue('url'));
    const error = generator.getVariableName(block.getFieldValue('error'));

return `ScriptDiscoveryService.scriptLoadError.connect((_url,_error) => { 
  ${url} = _url; 
  ${error} = _error;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_printedMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.printedMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('printedMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('printedMessage_scriptName'), 'scriptName');

        this.setColour('#DC89A0');
        this.setTooltip('Triggered when any script prints a message to the program log via {@link  print}, {@link Script.print},{@link console.log}, or {@link console.debug}.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.printedMessage');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_printedMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `ScriptDiscoveryService.printedMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_errorMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.errorMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('errorMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('errorMessage_scriptName'), 'scriptName');

        this.setColour('#DC89A0');
        this.setTooltip('Triggered when any script generates an error or {@link console.error} is called.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.errorMessage');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_errorMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `ScriptDiscoveryService.errorMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_warningMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.warningMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('warningMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('warningMessage_scriptName'), 'scriptName');

        this.setColour('#DC89A0');
        this.setTooltip('Triggered when any script generates a warning or {@link console.warn} is called.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.warningMessage');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_warningMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `ScriptDiscoveryService.warningMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_infoMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.infoMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('infoMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('infoMessage_scriptName'), 'scriptName');

        this.setColour('#DC89A0');
        this.setTooltip('Triggered when any script generates an information message or {@link console.info} is called.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.infoMessage');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_infoMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `ScriptDiscoveryService.infoMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_printedEntityMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.printedEntityMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('printedEntityMessage_message'), 'message');
        this.appendDummyInput('fileName')
            .appendField('fileName:')
            .appendField(new Blockly.FieldVariable('printedEntityMessage_fileName'), 'fileName');
        this.appendDummyInput('lineNumber')
            .appendField('lineNumber:')
            .appendField(new Blockly.FieldVariable('printedEntityMessage_lineNumber'), 'lineNumber');
        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('printedEntityMessage_entityID'), 'entityID');
        this.appendDummyInput('isServerScript')
            .appendField('isServerScript:')
            .appendField(new Blockly.FieldVariable('printedEntityMessage_isServerScript'), 'isServerScript');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when a client side entity script prints a message to the program log via {@link  print}, {@link Script.print},{@link console.log}, {@link console.debug}, {@link console.group}, {@link console.groupEnd}, {@link console.time}, or{@link console.timeEnd}.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.printedEntityMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_printedEntityMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const fileName = generator.getVariableName(block.getFieldValue('fileName'));
    const lineNumber = generator.getVariableName(block.getFieldValue('lineNumber'));
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const isServerScript = generator.getVariableName(block.getFieldValue('isServerScript'));

return `Script.printedEntityMessage.connect((_message,_fileName,_lineNumber,_entityID,_isServerScript) => { 
  ${message} = _message; 
  ${fileName} = _fileName; 
  ${lineNumber} = _lineNumber; 
  ${entityID} = _entityID; 
  ${isServerScript} = _isServerScript;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_errorEntityMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.errorEntityMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('errorEntityMessage_message'), 'message');
        this.appendDummyInput('fileName')
            .appendField('fileName:')
            .appendField(new Blockly.FieldVariable('errorEntityMessage_fileName'), 'fileName');
        this.appendDummyInput('lineNumber')
            .appendField('lineNumber:')
            .appendField(new Blockly.FieldVariable('errorEntityMessage_lineNumber'), 'lineNumber');
        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('errorEntityMessage_entityID'), 'entityID');
        this.appendDummyInput('isServerScript')
            .appendField('isServerScript:')
            .appendField(new Blockly.FieldVariable('errorEntityMessage_isServerScript'), 'isServerScript');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when a client side entity script generates an error, {@link console.error} or {@link console.exception} is called, or{@link console.assert} is called and fails.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.errorEntityMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_errorEntityMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const fileName = generator.getVariableName(block.getFieldValue('fileName'));
    const lineNumber = generator.getVariableName(block.getFieldValue('lineNumber'));
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const isServerScript = generator.getVariableName(block.getFieldValue('isServerScript'));

return `Script.errorEntityMessage.connect((_message,_fileName,_lineNumber,_entityID,_isServerScript) => { 
  ${message} = _message; 
  ${fileName} = _fileName; 
  ${lineNumber} = _lineNumber; 
  ${entityID} = _entityID; 
  ${isServerScript} = _isServerScript;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_warningEntityMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.warningEntityMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('warningEntityMessage_message'), 'message');
        this.appendDummyInput('fileName')
            .appendField('fileName:')
            .appendField(new Blockly.FieldVariable('warningEntityMessage_fileName'), 'fileName');
        this.appendDummyInput('lineNumber')
            .appendField('lineNumber:')
            .appendField(new Blockly.FieldVariable('warningEntityMessage_lineNumber'), 'lineNumber');
        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('warningEntityMessage_entityID'), 'entityID');
        this.appendDummyInput('isServerScript')
            .appendField('isServerScript:')
            .appendField(new Blockly.FieldVariable('warningEntityMessage_isServerScript'), 'isServerScript');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when a client side entity script generates a warning or {@link console.warn} is called.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.warningEntityMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_warningEntityMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const fileName = generator.getVariableName(block.getFieldValue('fileName'));
    const lineNumber = generator.getVariableName(block.getFieldValue('lineNumber'));
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const isServerScript = generator.getVariableName(block.getFieldValue('isServerScript'));

return `Script.warningEntityMessage.connect((_message,_fileName,_lineNumber,_entityID,_isServerScript) => { 
  ${message} = _message; 
  ${fileName} = _fileName; 
  ${lineNumber} = _lineNumber; 
  ${entityID} = _entityID; 
  ${isServerScript} = _isServerScript;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_infoEntityMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.infoEntityMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('infoEntityMessage_message'), 'message');
        this.appendDummyInput('fileName')
            .appendField('fileName:')
            .appendField(new Blockly.FieldVariable('infoEntityMessage_fileName'), 'fileName');
        this.appendDummyInput('lineNumber')
            .appendField('lineNumber:')
            .appendField(new Blockly.FieldVariable('infoEntityMessage_lineNumber'), 'lineNumber');
        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('infoEntityMessage_entityID'), 'entityID');
        this.appendDummyInput('isServerScript')
            .appendField('isServerScript:')
            .appendField(new Blockly.FieldVariable('infoEntityMessage_isServerScript'), 'isServerScript');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when a client side entity script generates an information message or {@link console.info} is called.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.infoEntityMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_infoEntityMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const fileName = generator.getVariableName(block.getFieldValue('fileName'));
    const lineNumber = generator.getVariableName(block.getFieldValue('lineNumber'));
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));
    const isServerScript = generator.getVariableName(block.getFieldValue('isServerScript'));

return `Script.infoEntityMessage.connect((_message,_fileName,_lineNumber,_entityID,_isServerScript) => { 
  ${message} = _message; 
  ${fileName} = _fileName; 
  ${lineNumber} = _lineNumber; 
  ${entityID} = _entityID; 
  ${isServerScript} = _isServerScript;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['ScriptDiscoveryService_clearDebugWindow'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ScriptDiscoveryService.clearDebugWindow');


        this.setColour('#DC89A0');
        this.setTooltip('Triggered when the Debug Window is cleared.');
        this.setHelpUrl('https://apidocs.overte.org/ScriptDiscoveryService.html#.clearDebugWindow');
    }
};
javascript.javascriptGenerator.forBlock['ScriptDiscoveryService_clearDebugWindow'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ScriptDiscoveryService.clearDebugWindow.connect(() => {
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Resource_State'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Resource.State')       
        this.setOutput(true, '');
        this.setColour('#BE8545');
        this.setTooltip('The possible loading states of a resource. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Resource.html#.State');
    }
};
javascript.javascriptGenerator.forBlock['Resource_State'] = (block, generator) => {
    return [`Resource.State`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['print'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('print')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#111111');
        this.setTooltip('Prints a message to the program log and emits {@link Script.printedMessage}.The message logged is the message values separated by spaces.<p>Alternatively, you can use {@link Script.print} or one of the {@link console} API methods.</p>');
        this.setHelpUrl('https://apidocs.overte.org/print');
    }
};
javascript.javascriptGenerator.forBlock['print'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `print(${_message});\n`;};


// Blockly signal
Blockly.Blocks['Entities_unload'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Entities.unload');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('unload_entityID'), 'entityID');

        this.setColour('#EA9958');
        this.setTooltip('Triggered when the script terminates for a user.<p>Note: Can only be connected to via <code>this.unoad = function () { ... }</code> in the entity script.</p><p class="availableIn"><strong>Supported Script Types:</strong> Client Entity Scripts &bull; Server Entity Scripts</p>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.unload');
    }
};
javascript.javascriptGenerator.forBlock['Entities_unload'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Entities.unload.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Script_context'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.context')       
        this.setOutput(true, '');
        this.setColour('#F907E6');
        this.setTooltip('The context that the script is running in:    <ul>      <li><code>"client"</code>: An Interface or avatar script.</li>      <li><code>"entity_client"</code>: A client entity script.</li>      <li><code>"entity_server"</code>: A server entity script.</li>      <li><code>"agent"</code>: An assignment client script.</li>    </ul>    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.context');
    }
};
javascript.javascriptGenerator.forBlock['Script_context'] = (block, generator) => {
    return [`Script.context`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Script_type'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.type')       
        this.setOutput(true, '');
        this.setColour('#F907E6');
        this.setTooltip('The type of script that is running:    <ul>      <li><code>"client"</code>: An Interface script.</li>      <li><code>"entity_client"</code>: A client entity script.</li>      <li><code>"avatar"</code>: An avatar script.</li>      <li><code>"entity_server"</code>: A server entity script.</li>      <li><code>"agent"</code>: An assignment client script.</li>    </ul>    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.type');
    }
};
javascript.javascriptGenerator.forBlock['Script_type'] = (block, generator) => {
    return [`Script.type`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Script_filename'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.filename')       
        this.setOutput(true, '');
        this.setColour('#F907E6');
        this.setTooltip('The filename of the script file.    <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.filename');
    }
};
javascript.javascriptGenerator.forBlock['Script_filename'] = (block, generator) => {
    return [`Script.filename`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Script_ExternalPaths'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.ExternalPaths')       
        this.setOutput(true, '');
        this.setColour('#F907E6');
        this.setTooltip('External resource buckets.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.ExternalPaths');
    }
};
javascript.javascriptGenerator.forBlock['Script_ExternalPaths'] = (block, generator) => {
    return [`Script.ExternalPaths`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Script_stop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.stop')
        // Returns data

        // Params data
        this.appendValueInput('marshal') 
            .setCheck('Boolean')
            .appendField('marshal');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Stops and unloads the current script.<p><strong>Warning:</strong> If an assignment client script, the script gets restarted after stopping.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.stop');
    }
};
javascript.javascriptGenerator.forBlock['Script_stop'] = (block, generator) => {
    const _marshal = dfv(generator.valueToCode(block, 'marshal', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Script.stop(${_marshal});\n`;};


// Blockly function
Blockly.Blocks['Script_getContext'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.getContext')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Gets the context that the script is running in: Interface/avatar, client entity, server entity, or assignment client.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.getContext');
    }
};
javascript.javascriptGenerator.forBlock['Script_getContext'] = (block, generator) => {

return [`Script.getContext()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_isClientScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.isClientScript')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Checks whether the script is running as an Interface or avatar script.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.isClientScript');
    }
};
javascript.javascriptGenerator.forBlock['Script_isClientScript'] = (block, generator) => {

return [`Script.isClientScript()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_isDebugMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.isDebugMode')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Checks whether the application was compiled as a debug build.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.isDebugMode');
    }
};
javascript.javascriptGenerator.forBlock['Script_isDebugMode'] = (block, generator) => {

return [`Script.isDebugMode()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_isEntityClientScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.isEntityClientScript')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Checks whether the script is running as a client entity script.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.isEntityClientScript');
    }
};
javascript.javascriptGenerator.forBlock['Script_isEntityClientScript'] = (block, generator) => {

return [`Script.isEntityClientScript()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_isEntityServerScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.isEntityServerScript')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Checks whether the script is running as a server entity script.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.isEntityServerScript');
    }
};
javascript.javascriptGenerator.forBlock['Script_isEntityServerScript'] = (block, generator) => {

return [`Script.isEntityServerScript()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_isAgentScript'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.isAgentScript')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Checks whether the script is running as an assignment client script.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.isAgentScript');
    }
};
javascript.javascriptGenerator.forBlock['Script_isAgentScript'] = (block, generator) => {

return [`Script.isAgentScript()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_registerValue'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.registerValue')
        // Returns data

        // Params data
        this.appendValueInput('valueName') 
            .setCheck('String')
            .appendField('valueName');
        this.appendValueInput('value') 
            .setCheck('value')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('registers a global object by name.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.registerValue');
    }
};
javascript.javascriptGenerator.forBlock['Script_registerValue'] = (block, generator) => {
    const _valueName = dfv(generator.valueToCode(block, 'valueName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.registerValue(${_valueName},${_value});\n`;};


// Blockly function
Blockly.Blocks['Script_addEventHandler'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.addEventHandler')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('eventName') 
            .setCheck('Script.EntityEvent')
            .appendField('eventName');
        this.appendValueInput('handler') 
            .setCheck('Script~entityEventCallback')
            .appendField('handler');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Adds a function to the list of functions called when a particular event occurs on a particular entity.<p>See also, the {@link Entities} API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.addEventHandler');
    }
};
javascript.javascriptGenerator.forBlock['Script_addEventHandler'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _eventName = dfv(generator.valueToCode(block, 'eventName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _handler = dfv(generator.valueToCode(block, 'handler', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.addEventHandler(${_entityID},${_eventName},${_handler});\n`;};


// Blockly function
Blockly.Blocks['Script_removeEventHandler'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.removeEventHandler')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('eventName') 
            .setCheck('Script.EntityEvent')
            .appendField('eventName');
        this.appendStatementInput('handler')
            .appendField('handler');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Removes a function from the list of functions called when an entity event occurs on a particular entity.<p>See also, the {@link Entities} API.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.removeEventHandler');
    }
};
javascript.javascriptGenerator.forBlock['Script_removeEventHandler'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _eventName = dfv(generator.valueToCode(block, 'eventName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _handler = generator.statementToCode(block, 'handler');


    return `Script.removeEventHandler(${_entityID},${_eventName},() => { \n ${_handler} });\n`;};


// Blockly function
Blockly.Blocks['Script_load'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.load')
        // Returns data

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Starts running another script in Interface, if it isn\'t already running. The script is not automatically loaded nexttime Interface starts.<p class="availableIn"><strong>Supported Script Types:</strong> Interface Scripts &bull; Avatar Scripts</p><p>See also, {@link ScriptDiscoveryService.loadScript}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.load');
    }
};
javascript.javascriptGenerator.forBlock['Script_load'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.load(${_filename});\n`;};


// Blockly function
Blockly.Blocks['Script_include'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.include')
        // Returns data

        // Params data
        this.appendValueInput('filenames') 
            .setCheck('Array')
            .appendField('filenames');
        this.appendStatementInput('callback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Includes JavaScript from other files in the current script. If a callback is specified, the files are loaded andincluded asynchronously, otherwise they are included synchronously (i.e., script execution blocks while the files areincluded).');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.include');
    }
};
javascript.javascriptGenerator.forBlock['Script_include'] = (block, generator) => {
    const _filenames = dfv(generator.valueToCode(block, 'filenames', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = generator.statementToCode(block, 'callback');


    return `Script.include(${_filenames},() => { \n ${_callback} });\n`;};


// Blockly function
Blockly.Blocks['Script_includefilenamecallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.include')
        // Returns data

        // Params data
        this.appendValueInput('filename') 
            .setCheck('String')
            .appendField('filename');
        this.appendStatementInput('callback')
            .appendField('callback');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Includes JavaScript from another file in the current script. If a callback is specified, the file is loaded and includedasynchronously, otherwise it is included synchronously (i.e., script execution blocks while the file is included).');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.include');
    }
};
javascript.javascriptGenerator.forBlock['Script_includefilenamecallback'] = (block, generator) => {
    const _filename = dfv(generator.valueToCode(block, 'filename', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callback = generator.statementToCode(block, 'callback');


    return `Script.include(${_filename},() => { \n ${_callback} });\n`;};


// Blockly function
Blockly.Blocks['Script_require'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.require')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('module') 
            .setCheck('String')
            .appendField('module');

        this.setColour('#F907E6');
        this.setTooltip('Provides access to methods or objects provided in an external JavaScript or JSON file.See {@link https://docs.overte.org/script/js-tips.html} for further details.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.require');
    }
};
javascript.javascriptGenerator.forBlock['Script_require'] = (block, generator) => {
    const _module = dfv(generator.valueToCode(block, 'module', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Script.require(${_module})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_setInterval'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.setInterval')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendStatementInput('function')
            .appendField('function');
        this.appendValueInput('interval') 
            .setCheck('Number')
            .appendField('interval');

        this.setColour('#F907E6');
        this.setTooltip('Calls a function repeatedly, at a set interval.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.setInterval');
    }
};
javascript.javascriptGenerator.forBlock['Script_setInterval'] = (block, generator) => {
    const _function = generator.statementToCode(block, 'function');
    const _interval = dfv(generator.valueToCode(block, 'interval', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Script.setInterval(() => { \n ${_function} },${_interval})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_setTimeout'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.setTimeout')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendStatementInput('function')
            .appendField('function');
        this.appendValueInput('timeout') 
            .setCheck('Number')
            .appendField('timeout');

        this.setColour('#F907E6');
        this.setTooltip('Calls a function once, after a delay.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.setTimeout');
    }
};
javascript.javascriptGenerator.forBlock['Script_setTimeout'] = (block, generator) => {
    const _function = generator.statementToCode(block, 'function');
    const _timeout = dfv(generator.valueToCode(block, 'timeout', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Script.setTimeout(() => { \n ${_function} },${_timeout})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_clearInterval'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.clearInterval')
        // Returns data

        // Params data
        this.appendValueInput('timer') 
            .setCheck('object')
            .appendField('timer');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Stops an interval timer set by {@link Script.setInterval|setInterval}.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.clearInterval');
    }
};
javascript.javascriptGenerator.forBlock['Script_clearInterval'] = (block, generator) => {
    const _timer = dfv(generator.valueToCode(block, 'timer', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.clearInterval(${_timer});\n`;};


// Blockly function
Blockly.Blocks['Script_clearTimeout'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.clearTimeout')
        // Returns data

        // Params data
        this.appendValueInput('timer') 
            .setCheck('object')
            .appendField('timer');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Stops a timeout timer set by {@link Script.setTimeout|setTimeout}.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.clearTimeout');
    }
};
javascript.javascriptGenerator.forBlock['Script_clearTimeout'] = (block, generator) => {
    const _timer = dfv(generator.valueToCode(block, 'timer', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.clearTimeout(${_timer});\n`;};


// Blockly function
Blockly.Blocks['Script_print'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.print')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Prints a message to the program log and emits {@link Script.printedMessage}.<p>Alternatively, you can use {@link print} or one of the {@link console} API methods.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.print');
    }
};
javascript.javascriptGenerator.forBlock['Script_print'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.print(${_message});\n`;};


// Blockly function
Blockly.Blocks['Script_resolvePath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.resolvePath')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setColour('#F907E6');
        this.setTooltip('Resolves a relative path to an absolute path. The relative path is relative to the script\'s location.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.resolvePath');
    }
};
javascript.javascriptGenerator.forBlock['Script_resolvePath'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Script.resolvePath(${_path})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_resourcesPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.resourcesPath')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Gets the path to the resources directory for QML files.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.resourcesPath');
    }
};
javascript.javascriptGenerator.forBlock['Script_resourcesPath'] = (block, generator) => {

return [`Script.resourcesPath()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_beginProfileRange'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.beginProfileRange')
        // Returns data

        // Params data
        this.appendValueInput('label') 
            .setCheck('String')
            .appendField('label');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Starts timing a section of code in order to send usage data about it to Overte. Shouldn\'t be used outside of thestandard scripts.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.beginProfileRange');
    }
};
javascript.javascriptGenerator.forBlock['Script_beginProfileRange'] = (block, generator) => {
    const _label = dfv(generator.valueToCode(block, 'label', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.beginProfileRange(${_label});\n`;};


// Blockly function
Blockly.Blocks['Script_endProfileRange'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.endProfileRange')
        // Returns data

        // Params data
        this.appendValueInput('label') 
            .setCheck('String')
            .appendField('label');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Finishes timing a section of code in order to send usage data about it to Overte. Shouldn\'t be used outside ofthe standard scripts.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.endProfileRange');
    }
};
javascript.javascriptGenerator.forBlock['Script_endProfileRange'] = (block, generator) => {
    const _label = dfv(generator.valueToCode(block, 'label', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.endProfileRange(${_label});\n`;};


// Blockly function
Blockly.Blocks['Script_isEntityScriptRunning'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.isEntityScriptRunning')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setColour('#F907E6');
        this.setTooltip('Checks whether an entity has an entity script running.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.isEntityScriptRunning');
    }
};
javascript.javascriptGenerator.forBlock['Script_isEntityScriptRunning'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Script.isEntityScriptRunning(${_entityID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_requestGarbageCollection'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.requestGarbageCollection')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Manually runs the JavaScript garbage collector which reclaims memory by disposing of objects that are no longerreachable.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.requestGarbageCollection');
    }
};
javascript.javascriptGenerator.forBlock['Script_requestGarbageCollection'] = (block, generator) => {


    return `Script.requestGarbageCollection();\n`;};


// Blockly function
Blockly.Blocks['Script_logBacktrace'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.logBacktrace')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Prints out current backtrace to the log.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.logBacktrace');
    }
};
javascript.javascriptGenerator.forBlock['Script_logBacktrace'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.logBacktrace(${_title});\n`;};


// Blockly function
Blockly.Blocks['Script_callEntityScriptMethod'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.callEntityScriptMethod')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');
        this.appendValueInput('methodName') 
            .setCheck('String')
            .appendField('methodName');
        this.appendValueInput('parameters') 
            .setCheck('Array')
            .appendField('parameters');
        this.appendValueInput('remoteCallerID') 
            .setCheck('Uuid')
            .appendField('remoteCallerID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Calls a method in an entity script.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.callEntityScriptMethod');
    }
};
javascript.javascriptGenerator.forBlock['Script_callEntityScriptMethod'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _methodName = dfv(generator.valueToCode(block, 'methodName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parameters = dfv(generator.valueToCode(block, 'parameters', javascript.javascriptGenerator.ORDER_ATOMIC), `[]`);
    const _remoteCallerID = dfv(generator.valueToCode(block, 'remoteCallerID', javascript.javascriptGenerator.ORDER_ATOMIC), `Uuid.NULL`);


    return `Script.callEntityScriptMethod(${_entityID},${_methodName},${_parameters},${_remoteCallerID});\n`;};


// Blockly function
Blockly.Blocks['Script_getExternalPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.getExternalPath')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('bucket') 
            .setCheck('Script.ResourceBucket')
            .appendField('bucket');
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setColour('#F907E6');
        this.setTooltip('Gets the URL for an asset in an external resource bucket. (The location where the bucket is hosted may change over timebut this method will return the asset\'s current URL.)');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.getExternalPath');
    }
};
javascript.javascriptGenerator.forBlock['Script_getExternalPath'] = (block, generator) => {
    const _bucket = dfv(generator.valueToCode(block, 'bucket', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Script.getExternalPath(${_bucket},${_path})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Script_MemoryUsageData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.MemoryUsageData')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#F907E6');
        this.setTooltip('<p>Object containing memory usage statistics data.</p><table>  <thead>    <tr><th>Name</th><th>Type</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>totalHeapSize</code></td><td>{number}</td><td>Total heap size allocated by scripting engine.</td></tr>    <tr><td><code>usedHeapSize</code></td><td>{number}</td><td></td>Amount of heap memory that is currently in use.</tr>    <tr><td><code>totalAvailableSize</code></td><td>{number}</td><td>Amount of remaining available heap memory</td></tr>    <tr><td><code>totalGlobalHandlesSize</code></td><td>{number}</td><td>V8-specific property</td></tr>    <tr><td><code>usedGlobalHandlesSize</code></td><td>{number}</td><td>V8-specific property</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.MemoryUsageData');
    }
};
javascript.javascriptGenerator.forBlock['Script_MemoryUsageData'] = (block, generator) => {

    return [`new Script.MemoryUsageData()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Script_getMemoryUsageStatistics'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.getMemoryUsageStatistics')
        // Returns data
        this.setOutput(true, '["Script.MemoryUsageData"]');

        // Params data

        this.setColour('#F907E6');
        this.setTooltip('Returns memory usage statistics data.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.getMemoryUsageStatistics');
    }
};
javascript.javascriptGenerator.forBlock['Script_getMemoryUsageStatistics'] = (block, generator) => {

return [`Script.getMemoryUsageStatistics()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_startCollectingObjectStatistics'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.startCollectingObjectStatistics')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Start collecting object statistics that can later be reported with Script.dumpHeapObjectStatistics().');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.startCollectingObjectStatistics');
    }
};
javascript.javascriptGenerator.forBlock['Script_startCollectingObjectStatistics'] = (block, generator) => {


    return `Script.startCollectingObjectStatistics();\n`;};


// Blockly function
Blockly.Blocks['Script_dumpHeapObjectStatistics'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.dumpHeapObjectStatistics')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Prints heap statistics to a file. Collecting needs to first be started with Script.dumpHeapObjectStatistics().');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.dumpHeapObjectStatistics');
    }
};
javascript.javascriptGenerator.forBlock['Script_dumpHeapObjectStatistics'] = (block, generator) => {


    return `Script.dumpHeapObjectStatistics();\n`;};


// Blockly function
Blockly.Blocks['Script_createGarbageCollectorDebuggingObject()'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.createGarbageCollectorDebuggingObject()')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Create test object for garbage collector debugging.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.createGarbageCollectorDebuggingObject()');
    }
};
javascript.javascriptGenerator.forBlock['Script_createGarbageCollectorDebuggingObject()'] = (block, generator) => {


    return `Script.createGarbageCollectorDebuggingObject()();\n`;};


// Blockly function
Blockly.Blocks['Script_startProfiling'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.startProfiling')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Starts collecting profiling data');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.startProfiling');
    }
};
javascript.javascriptGenerator.forBlock['Script_startProfiling'] = (block, generator) => {


    return `Script.startProfiling();\n`;};


// Blockly function
Blockly.Blocks['Script_stopProfilingAndSave'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.stopProfilingAndSave')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Stops collecting profiling data and writes them to a timestamped CSV file in Logs directory.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.stopProfilingAndSave');
    }
};
javascript.javascriptGenerator.forBlock['Script_stopProfilingAndSave'] = (block, generator) => {


    return `Script.stopProfilingAndSave();\n`;};


// Blockly function
Blockly.Blocks['Script_subscribeToServerEntityScriptMessages'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.subscribeToServerEntityScriptMessages')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('After calling this function current script engine will start receiving server-side entity script messagesthrough signals such as errorEntityMessage. This function can be invoked both from client-side entity scriptsand from interface scripts.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.subscribeToServerEntityScriptMessages');
    }
};
javascript.javascriptGenerator.forBlock['Script_subscribeToServerEntityScriptMessages'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.subscribeToServerEntityScriptMessages(${_entityID});\n`;};


// Blockly function
Blockly.Blocks['Script_unsubscribeFromServerEntityScriptMessages'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.unsubscribeFromServerEntityScriptMessages')
        // Returns data

        // Params data
        this.appendValueInput('entityID') 
            .setCheck('Uuid')
            .appendField('entityID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F907E6');
        this.setTooltip('Calling this function signalizes that current script doesn\'t require stop receiving server-side entity script messagesthrough signals such as errorEntityMessage. This function can be invoked both from client-side entity scriptsand from interface scripts.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.unsubscribeFromServerEntityScriptMessages');
    }
};
javascript.javascriptGenerator.forBlock['Script_unsubscribeFromServerEntityScriptMessages'] = (block, generator) => {
    const _entityID = dfv(generator.valueToCode(block, 'entityID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Script.unsubscribeFromServerEntityScriptMessages(${_entityID});\n`;};


// Blockly function
Blockly.Blocks['Script_atob'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.atob')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data
        this.appendValueInput('base64') 
            .setCheck('String')
            .appendField('base64');

        this.setColour('#F907E6');
        this.setTooltip('This decodes Base64 string and returns contents as ArrayBuffer.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.atob');
    }
};
javascript.javascriptGenerator.forBlock['Script_atob'] = (block, generator) => {
    const _base64 = dfv(generator.valueToCode(block, 'base64', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Script.atob(${_base64})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Script_btoa'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Script.btoa')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('binary') 
            .setCheck('Array')
            .appendField('binary');

        this.setColour('#F907E6');
        this.setTooltip('This encodes ArrayBuffer and returns Base64-encoded string.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.btoa');
    }
};
javascript.javascriptGenerator.forBlock['Script_btoa'] = (block, generator) => {
    const _binary = dfv(generator.valueToCode(block, 'binary', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Script.btoa(${_binary})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Script_update'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.update');

        this.appendDummyInput('deltaTime')
            .appendField('deltaTime:')
            .appendField(new Blockly.FieldVariable('update_deltaTime'), 'deltaTime');

        this.setColour('#F907E6');
        this.setTooltip('Triggered frequently at a system-determined interval.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.update');
    }
};
javascript.javascriptGenerator.forBlock['Script_update'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const deltaTime = generator.getVariableName(block.getFieldValue('deltaTime'));

return `Script.update.connect((_deltaTime) => { 
  ${deltaTime} = _deltaTime;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_scriptEnding'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.scriptEnding');


        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script is stopping.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.scriptEnding');
    }
};
javascript.javascriptGenerator.forBlock['Script_scriptEnding'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Script.scriptEnding.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_printedMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.printedMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('printedMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('printedMessage_scriptName'), 'scriptName');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script prints a message to the program log via {@link  print}, {@link Script.print},{@link console.log}, {@link console.debug}, {@link console.group}, {@link console.groupEnd}, {@link console.time}, or{@link console.timeEnd}.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.printedMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_printedMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `Script.printedMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_errorMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.errorMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('errorMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('errorMessage_scriptName'), 'scriptName');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script generates an error, {@link console.error} or {@link console.exception} is called, or{@link console.assert} is called and fails.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.errorMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_errorMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `Script.errorMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_warningMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.warningMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('warningMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('warningMessage_scriptName'), 'scriptName');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script generates a warning or {@link console.warn} is called.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.warningMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_warningMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `Script.warningMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_infoMessage'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.infoMessage');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('infoMessage_message'), 'message');
        this.appendDummyInput('scriptName')
            .appendField('scriptName:')
            .appendField(new Blockly.FieldVariable('infoMessage_scriptName'), 'scriptName');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script generates an information message or {@link console.info} is called.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.infoMessage');
    }
};
javascript.javascriptGenerator.forBlock['Script_infoMessage'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));
    const scriptName = generator.getVariableName(block.getFieldValue('scriptName'));

return `Script.infoMessage.connect((_message,_scriptName) => { 
  ${message} = _message; 
  ${scriptName} = _scriptName;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_runningStateChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.runningStateChanged');


        this.setColour('#F907E6');
        this.setTooltip('Triggered when the running state of the script changes, e.g., from running to stopping.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.runningStateChanged');
    }
};
javascript.javascriptGenerator.forBlock['Script_runningStateChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Script.runningStateChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_doneRunning'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.doneRunning');


        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script has stopped.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.doneRunning');
    }
};
javascript.javascriptGenerator.forBlock['Script_doneRunning'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Script.doneRunning.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_entityScriptPreloadFinished'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.entityScriptPreloadFinished');

        this.appendDummyInput('entityID')
            .appendField('entityID:')
            .appendField(new Blockly.FieldVariable('entityScriptPreloadFinished_entityID'), 'entityID');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when the script starts for the user. See also, {@link Entities.preload}.<p class="availableIn"><strong>Supported Script Types:</strong> Client Entity Scripts &bull; Server Entity Scripts</p>');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.entityScriptPreloadFinished');
    }
};
javascript.javascriptGenerator.forBlock['Script_entityScriptPreloadFinished'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const entityID = generator.getVariableName(block.getFieldValue('entityID'));

return `Script.entityScriptPreloadFinished.connect((_entityID) => { 
  ${entityID} = _entityID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Script_unhandledException'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Script.unhandledException');

        this.appendDummyInput('exception')
            .appendField('exception:')
            .appendField(new Blockly.FieldVariable('unhandledException_exception'), 'exception');

        this.setColour('#F907E6');
        this.setTooltip('Triggered when a script generates an unhandled exception.');
        this.setHelpUrl('https://apidocs.overte.org/Script.html#.unhandledException');
    }
};
javascript.javascriptGenerator.forBlock['Script_unhandledException'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const exception = generator.getVariableName(block.getFieldValue('exception'));

return `Script.unhandledException.connect((_exception) => { 
  ${exception} = _exception;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Uuid_NULL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.NULL')       
        this.setOutput(true, '');
        this.setColour('#755BF0');
        this.setTooltip('The null UUID, <code>"{00000000-0000-0000-0000-000000000000}"</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.NULL');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_NULL'] = (block, generator) => {
    return [`Uuid.NULL`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Uuid_fromString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.fromString')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data
        this.appendValueInput('string') 
            .setCheck('String')
            .appendField('string');

        this.setColour('#755BF0');
        this.setTooltip('Generates a UUID from a string representation of the UUID.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.fromString');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_fromString'] = (block, generator) => {
    const _string = dfv(generator.valueToCode(block, 'string', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Uuid.fromString(${_string})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Uuid_toString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.toString')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#755BF0');
        this.setTooltip('Generates a string representation of a UUID. However, because UUIDs are represented in JavaScript as strings, this is ineffect a no-op.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.toString');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_toString'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Uuid.toString(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Uuid_generate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.generate')
        // Returns data
        this.setOutput(true, '["Uuid"]');

        // Params data

        this.setColour('#755BF0');
        this.setTooltip('Generates a new UUID.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.generate');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_generate'] = (block, generator) => {

return [`Uuid.generate()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Uuid_isEqual'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.isEqual')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('idA') 
            .setCheck('Uuid')
            .appendField('idA');
        this.appendValueInput('idB') 
            .setCheck('Uuid')
            .appendField('idB');

        this.setColour('#755BF0');
        this.setTooltip('Tests whether two UUIDs are equal.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.isEqual');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_isEqual'] = (block, generator) => {
    const _idA = dfv(generator.valueToCode(block, 'idA', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _idB = dfv(generator.valueToCode(block, 'idB', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Uuid.isEqual(${_idA},${_idB})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Uuid_isNull'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.isNull')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setColour('#755BF0');
        this.setTooltip('Tests whether a UUID is null.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.isNull');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_isNull'] = (block, generator) => {
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Uuid.isNull(${_id})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Uuid_print'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid.print')
        // Returns data

        // Params data
        this.appendValueInput('label') 
            .setCheck('String')
            .appendField('label');
        this.appendValueInput('id') 
            .setCheck('Uuid')
            .appendField('id');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#755BF0');
        this.setTooltip('Prints a UUID to the program log, as a text label followed by the UUID value.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid.html#.print');
    }
};
javascript.javascriptGenerator.forBlock['Uuid_print'] = (block, generator) => {
    const _label = dfv(generator.valueToCode(block, 'label', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _id = dfv(generator.valueToCode(block, 'id', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Uuid.print(${_label},${_id});\n`;};


// Blockly typedef
Blockly.Blocks['AACube'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AACube')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('z') 
            .setCheck('Number')
            .appendField('z');
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');
        this.setColour('#0B0314');
        this.setTooltip('An axis-aligned cube, defined as the bottom right near (minimum axes values) corner of the cube plus the dimension of itssides.');
        this.setHelpUrl('https://apidocs.overte.org/AACube');
    }
};
javascript.javascriptGenerator.forBlock['AACube'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _z = dfv(generator.valueToCode(block, 'z', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new AACube(${_x},${_y},${_z},${_scale})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Collision'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Collision')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('type') 
            .setCheck('ContactEventType')
            .appendField('type');
        this.appendValueInput('idA') 
            .setCheck('Uuid')
            .appendField('idA');
        this.appendValueInput('idB') 
            .setCheck('Uuid')
            .appendField('idB');
        this.appendValueInput('penetration') 
            .setCheck('Vec3')
            .appendField('penetration');
        this.appendValueInput('contactPoint') 
            .setCheck('Vec3')
            .appendField('contactPoint');
        this.appendValueInput('velocityChange') 
            .setCheck('Vec3')
            .appendField('velocityChange');
        this.setColour('#15FB6C');
        this.setTooltip('Details of a collision between avatars and entities.');
        this.setHelpUrl('https://apidocs.overte.org/Collision');
    }
};
javascript.javascriptGenerator.forBlock['Collision'] = (block, generator) => {
    const _type = dfv(generator.valueToCode(block, 'type', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _idA = dfv(generator.valueToCode(block, 'idA', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _idB = dfv(generator.valueToCode(block, 'idB', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _penetration = dfv(generator.valueToCode(block, 'penetration', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _contactPoint = dfv(generator.valueToCode(block, 'contactPoint', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _velocityChange = dfv(generator.valueToCode(block, 'velocityChange', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Collision(${_type},${_idA},${_idB},${_penetration},${_contactPoint},${_velocityChange})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Size'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Size')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.setColour('#6F6CB7');
        this.setTooltip('A 2D size value.');
        this.setHelpUrl('https://apidocs.overte.org/Size');
    }
};
javascript.javascriptGenerator.forBlock['Size'] = (block, generator) => {
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Size(${_height},${_width})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Avatar_AnimationDetails'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Avatar.AnimationDetails')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('role') 
            .setCheck('String')
            .appendField('role');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('fps') 
            .setCheck('Number')
            .appendField('fps');
        this.appendValueInput('priority') 
            .setCheck('Number')
            .appendField('priority');
        this.appendValueInput('loop') 
            .setCheck('Boolean')
            .appendField('loop');
        this.appendValueInput('hold') 
            .setCheck('Boolean')
            .appendField('hold');
        this.appendValueInput('firstFrame') 
            .setCheck('Number')
            .appendField('firstFrame');
        this.appendValueInput('lastFrame') 
            .setCheck('Number')
            .appendField('lastFrame');
        this.appendValueInput('running') 
            .setCheck('Boolean')
            .appendField('running');
        this.appendValueInput('currentFrame') 
            .setCheck('Number')
            .appendField('currentFrame');
        this.appendValueInput('startAutomatically') 
            .setCheck('Boolean')
            .appendField('startAutomatically');
        this.appendValueInput('allowTranslation') 
            .setCheck('Boolean')
            .appendField('allowTranslation');
        this.setColour('#320360');
        this.setTooltip('The details of an animation that is playing.');
        this.setHelpUrl('https://apidocs.overte.org/Avatar.html#.AnimationDetails');
    }
};
javascript.javascriptGenerator.forBlock['Avatar_AnimationDetails'] = (block, generator) => {
    const _role = dfv(generator.valueToCode(block, 'role', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fps = dfv(generator.valueToCode(block, 'fps', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _priority = dfv(generator.valueToCode(block, 'priority', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _loop = dfv(generator.valueToCode(block, 'loop', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _hold = dfv(generator.valueToCode(block, 'hold', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _firstFrame = dfv(generator.valueToCode(block, 'firstFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _lastFrame = dfv(generator.valueToCode(block, 'lastFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _running = dfv(generator.valueToCode(block, 'running', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _currentFrame = dfv(generator.valueToCode(block, 'currentFrame', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _startAutomatically = dfv(generator.valueToCode(block, 'startAutomatically', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _allowTranslation = dfv(generator.valueToCode(block, 'allowTranslation', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new Avatar.AnimationDetails(${_role},${_url},${_fps},${_priority},${_loop},${_hold},${_firstFrame},${_lastFrame},${_running},${_currentFrame},${_startAutomatically},${_allowTranslation})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['MeshFace'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MeshFace')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('vertices') 
            .setCheck('Array')
            .appendField('vertices');
        this.setColour('#4DD70A');
        this.setTooltip('A triangle in a mesh.');
        this.setHelpUrl('https://apidocs.overte.org/MeshFace');
    }
};
javascript.javascriptGenerator.forBlock['MeshFace'] = (block, generator) => {
    const _vertices = dfv(generator.valueToCode(block, 'vertices', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new MeshFace(${_vertices})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Mat4'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Mat4')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('r0c0') 
            .setCheck('Number')
            .appendField('r0c0');
        this.appendValueInput('r1c0') 
            .setCheck('Number')
            .appendField('r1c0');
        this.appendValueInput('r2c0') 
            .setCheck('Number')
            .appendField('r2c0');
        this.appendValueInput('r3c0') 
            .setCheck('Number')
            .appendField('r3c0');
        this.appendValueInput('r0c1') 
            .setCheck('Number')
            .appendField('r0c1');
        this.appendValueInput('r1c1') 
            .setCheck('Number')
            .appendField('r1c1');
        this.appendValueInput('r2c1') 
            .setCheck('Number')
            .appendField('r2c1');
        this.appendValueInput('r3c1') 
            .setCheck('Number')
            .appendField('r3c1');
        this.appendValueInput('r0c2') 
            .setCheck('Number')
            .appendField('r0c2');
        this.appendValueInput('r1c2') 
            .setCheck('Number')
            .appendField('r1c2');
        this.appendValueInput('r2c2') 
            .setCheck('Number')
            .appendField('r2c2');
        this.appendValueInput('r3c2') 
            .setCheck('Number')
            .appendField('r3c2');
        this.appendValueInput('r0c3') 
            .setCheck('Number')
            .appendField('r0c3');
        this.appendValueInput('r1c3') 
            .setCheck('Number')
            .appendField('r1c3');
        this.appendValueInput('r2c3') 
            .setCheck('Number')
            .appendField('r2c3');
        this.appendValueInput('r3c3') 
            .setCheck('Number')
            .appendField('r3c3');
        this.setColour('#80F740');
        this.setTooltip('A 4 x 4 matrix, typically containing a scale, rotation, and translation transform. See also the {@link Mat4|Mat4} object.');
        this.setHelpUrl('https://apidocs.overte.org/Mat4');
    }
};
javascript.javascriptGenerator.forBlock['Mat4'] = (block, generator) => {
    const _r0c0 = dfv(generator.valueToCode(block, 'r0c0', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r1c0 = dfv(generator.valueToCode(block, 'r1c0', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r2c0 = dfv(generator.valueToCode(block, 'r2c0', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r3c0 = dfv(generator.valueToCode(block, 'r3c0', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r0c1 = dfv(generator.valueToCode(block, 'r0c1', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r1c1 = dfv(generator.valueToCode(block, 'r1c1', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r2c1 = dfv(generator.valueToCode(block, 'r2c1', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r3c1 = dfv(generator.valueToCode(block, 'r3c1', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r0c2 = dfv(generator.valueToCode(block, 'r0c2', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r1c2 = dfv(generator.valueToCode(block, 'r1c2', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r2c2 = dfv(generator.valueToCode(block, 'r2c2', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r3c2 = dfv(generator.valueToCode(block, 'r3c2', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r0c3 = dfv(generator.valueToCode(block, 'r0c3', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r1c3 = dfv(generator.valueToCode(block, 'r1c3', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r2c3 = dfv(generator.valueToCode(block, 'r2c3', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _r3c3 = dfv(generator.valueToCode(block, 'r3c3', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Mat4(${_r0c0},${_r1c0},${_r2c0},${_r3c0},${_r0c1},${_r1c1},${_r2c1},${_r3c1},${_r0c2},${_r1c2},${_r2c2},${_r3c2},${_r0c3},${_r1c3},${_r2c3},${_r3c3})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Vec2'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec2')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.setColour('#FE9803');
        this.setTooltip('A 2-dimensional vector.');
        this.setHelpUrl('https://apidocs.overte.org/Vec2');
    }
};
javascript.javascriptGenerator.forBlock['Vec2'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Vec2(${_x},${_y})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Vec3'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('z') 
            .setCheck('Number')
            .appendField('z');
        this.setColour('#01B2DC');
        this.setTooltip('A 3-dimensional vector. See also the {@link Vec3|Vec3} object.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3');
    }
};
javascript.javascriptGenerator.forBlock['Vec3'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _z = dfv(generator.valueToCode(block, 'z', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Vec3(${_x},${_y},${_z})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Color'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Color')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('red') 
            .setCheck('Number')
            .appendField('red');
        this.appendValueInput('green') 
            .setCheck('Number')
            .appendField('green');
        this.appendValueInput('blue') 
            .setCheck('Number')
            .appendField('blue');
        this.setColour('#CB5FEB');
        this.setTooltip('A color vector. See also the {@link Vec3|Vec3} object.');
        this.setHelpUrl('https://apidocs.overte.org/Color');
    }
};
javascript.javascriptGenerator.forBlock['Color'] = (block, generator) => {
    const _red = dfv(generator.valueToCode(block, 'red', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _green = dfv(generator.valueToCode(block, 'green', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _blue = dfv(generator.valueToCode(block, 'blue', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Color(${_red},${_green},${_blue})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ColorFloat'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ColorFloat')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('red') 
            .setCheck('Number')
            .appendField('red');
        this.appendValueInput('green') 
            .setCheck('Number')
            .appendField('green');
        this.appendValueInput('blue') 
            .setCheck('Number')
            .appendField('blue');
        this.setColour('#4F823E');
        this.setTooltip('A color vector with real values. Values may also be <code>null</code>. See also the {@link Vec3|Vec3} object.');
        this.setHelpUrl('https://apidocs.overte.org/ColorFloat');
    }
};
javascript.javascriptGenerator.forBlock['ColorFloat'] = (block, generator) => {
    const _red = dfv(generator.valueToCode(block, 'red', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _green = dfv(generator.valueToCode(block, 'green', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _blue = dfv(generator.valueToCode(block, 'blue', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new ColorFloat(${_red},${_green},${_blue})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Vec4'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec4')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('z') 
            .setCheck('Number')
            .appendField('z');
        this.appendValueInput('w') 
            .setCheck('Number')
            .appendField('w');
        this.setColour('#F67402');
        this.setTooltip('A 4-dimensional vector.');
        this.setHelpUrl('https://apidocs.overte.org/Vec4');
    }
};
javascript.javascriptGenerator.forBlock['Vec4'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _z = dfv(generator.valueToCode(block, 'z', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _w = dfv(generator.valueToCode(block, 'w', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Vec4(${_x},${_y},${_z},${_w})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Rect'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Rect')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');
        this.setColour('#69AD58');
        this.setTooltip('Defines a rectangular portion of an image or screen, or similar.');
        this.setHelpUrl('https://apidocs.overte.org/Rect');
    }
};
javascript.javascriptGenerator.forBlock['Rect'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new Rect(${_x},${_y},${_width},${_height})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Uuid'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Uuid')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#755BF0');
        this.setTooltip('UUIDs (Universally Unique IDentifiers) are used to uniquely identify entities, avatars, and the like. They are representedin JavaScript as strings in the format, <code>"{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}"</code>, where the "n"s arehexadecimal digits.');
        this.setHelpUrl('https://apidocs.overte.org/Uuid');
    }
};
javascript.javascriptGenerator.forBlock['Uuid'] = (block, generator) => {

    return [`new Uuid()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['ScriptsModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptsModel')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DB126A');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>Information on the scripts that are in the default scripts directory of the Interface installation. This is provided as a property of {@link ScriptDiscoveryService}.<p>The information provided reflects the subdirectory structure. Methods and signals are per QT\'s <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html">QAbstractItemModel</a> class, with the following details:</p><ul>  <li>A single column of data: <code>columnCount(index)</code> returns <code>1</code>. </li>  <li>Data is provided for the following roles:    <table>      <thead>        <tr><th>Role</th><th>Value</th><th>Description</th></tr>      </thead>      <tbody>        <tr><td>Display</td><td><code>0</code></td><td>The directory or script file name.</td></tr>        <tr><td>Path</td><td><code>256</code></td><td>The path and filename of the data item if it is a script,         <code>undefined</code> if it is a directory.</td></tr>      </tbody>    </table>  </li>  <li>Use <code>null</code> for the root directory\'s index.</li></ul>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptsModel');
    }
};
javascript.javascriptGenerator.forBlock['ScriptsModel'] = (block, generator) => {

    return [`new ScriptsModel()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['ScriptsModelFilter'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ScriptsModelFilter')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#0DF91C');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>Sorted and filtered information on the scripts that are in the default scripts directory of the Interface installation. This is provided as a property of {@link ScriptDiscoveryService}.<p>The information provided reflects the subdirectory structure. Properties, methods, and signals are per QT\'s<a href="https://doc.qt.io/qt-5/qsortfilterproxymodel.html">QSortFilterProxyModel</a> class, with the following details:</p><ul>  <li>The rows are sorted per directory and file names.</li>  <li>A single column of data: <code>columnCount(index)</code> returns <code>1</code>. </li>  <li>Data is provided for the following roles:    <table>      <thead>        <tr><th>Role</th><th>Value</th><th>Description</th></tr>      </thead>      <tbody>        <tr><td>Display</td><td><code>0</code></td><td>The directory or script file name.</td></tr>        <tr><td>Path</td><td><code>256</code></td><td>The path and filename of the data item if it is a script,        <code>undefined</code> if it is a directory.</td></tr>      </tbody>    </table>  </li>  <li>Use <code>null</code> for the root directory\'s index.</li></ul>');
        this.setHelpUrl('https://apidocs.overte.org/ScriptsModelFilter');
    }
};
javascript.javascriptGenerator.forBlock['ScriptsModelFilter'] = (block, generator) => {

    return [`new ScriptsModelFilter()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['TouchEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TouchEvent')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('isPressed') 
            .setCheck('Boolean')
            .appendField('isPressed');
        this.appendValueInput('isMoved') 
            .setCheck('Boolean')
            .appendField('isMoved');
        this.appendValueInput('isStationary') 
            .setCheck('Boolean')
            .appendField('isStationary');
        this.appendValueInput('isReleased') 
            .setCheck('Boolean')
            .appendField('isReleased');
        this.appendValueInput('isShifted') 
            .setCheck('Boolean')
            .appendField('isShifted');
        this.appendValueInput('isMeta') 
            .setCheck('Boolean')
            .appendField('isMeta');
        this.appendValueInput('isControl') 
            .setCheck('Boolean')
            .appendField('isControl');
        this.appendValueInput('isAlt') 
            .setCheck('Boolean')
            .appendField('isAlt');
        this.appendValueInput('touchPoints') 
            .setCheck('Number')
            .appendField('touchPoints');
        this.appendValueInput('points') 
            .setCheck('Array')
            .appendField('points');
        this.appendValueInput('radius') 
            .setCheck('Number')
            .appendField('radius');
        this.appendValueInput('isPinching') 
            .setCheck('Boolean')
            .appendField('isPinching');
        this.appendValueInput('isPinchOpening') 
            .setCheck('Boolean')
            .appendField('isPinchOpening');
        this.appendValueInput('angle') 
            .setCheck('Number')
            .appendField('angle');
        this.appendValueInput('deltaAngle') 
            .setCheck('Number')
            .appendField('deltaAngle');
        this.appendValueInput('angles') 
            .setCheck('Array')
            .appendField('angles');
        this.appendValueInput('isRotating') 
            .setCheck('Boolean')
            .appendField('isRotating');
        this.appendValueInput('rotating') 
            .setCheck('String')
            .appendField('rotating');
        this.setColour('#49CD4F');
        this.setTooltip('A display or device touch event.');
        this.setHelpUrl('https://apidocs.overte.org/TouchEvent');
    }
};
javascript.javascriptGenerator.forBlock['TouchEvent'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _isPressed = dfv(generator.valueToCode(block, 'isPressed', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMoved = dfv(generator.valueToCode(block, 'isMoved', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isStationary = dfv(generator.valueToCode(block, 'isStationary', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isReleased = dfv(generator.valueToCode(block, 'isReleased', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isShifted = dfv(generator.valueToCode(block, 'isShifted', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMeta = dfv(generator.valueToCode(block, 'isMeta', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isControl = dfv(generator.valueToCode(block, 'isControl', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isAlt = dfv(generator.valueToCode(block, 'isAlt', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _touchPoints = dfv(generator.valueToCode(block, 'touchPoints', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _points = dfv(generator.valueToCode(block, 'points', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _radius = dfv(generator.valueToCode(block, 'radius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _isPinching = dfv(generator.valueToCode(block, 'isPinching', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isPinchOpening = dfv(generator.valueToCode(block, 'isPinchOpening', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _angle = dfv(generator.valueToCode(block, 'angle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _deltaAngle = dfv(generator.valueToCode(block, 'deltaAngle', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _angles = dfv(generator.valueToCode(block, 'angles', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isRotating = dfv(generator.valueToCode(block, 'isRotating', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _rotating = dfv(generator.valueToCode(block, 'rotating', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new TouchEvent(${_x},${_y},${_isPressed},${_isMoved},${_isStationary},${_isReleased},${_isShifted},${_isMeta},${_isControl},${_isAlt},${_touchPoints},${_points},${_radius},${_isPinching},${_isPinchOpening},${_angle},${_deltaAngle},${_angles},${_isRotating},${_rotating})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly namespace
Blockly.Blocks['Users_canKick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.canKick')       
        this.setOutput(true, '');
        this.setColour('#F9AAE5');
        this.setTooltip('<code>true</code> if the domain server allows the client to kick (ban) avatars, otherwise     <code>false</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.canKick');
    }
};
javascript.javascriptGenerator.forBlock['Users_canKick'] = (block, generator) => {
    return [`Users.canKick`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Users_requestsDomainListData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.requestsDomainListData')       
        this.setOutput(true, '');
        this.setColour('#F9AAE5');
        this.setTooltip('<code>true</code> if the client requests extra data from the mixers (such as     positional data of an avatar they\'ve ignored). <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.requestsDomainListData');
    }
};
javascript.javascriptGenerator.forBlock['Users_requestsDomainListData'] = (block, generator) => {
    return [`Users.requestsDomainListData`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Users_NO_BAN'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.NO_BAN')       
        this.setOutput(true, '');
        this.setColour('#F9AAE5');
        this.setTooltip('Do not ban user. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.NO_BAN');
    }
};
javascript.javascriptGenerator.forBlock['Users_NO_BAN'] = (block, generator) => {
    return [`Users.NO_BAN`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Users_BAN_BY_USERNAME'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.BAN_BY_USERNAME')       
        this.setOutput(true, '');
        this.setColour('#F9AAE5');
        this.setTooltip('Ban user by username. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.BAN_BY_USERNAME');
    }
};
javascript.javascriptGenerator.forBlock['Users_BAN_BY_USERNAME'] = (block, generator) => {
    return [`Users.BAN_BY_USERNAME`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Users_BAN_BY_FINGERPRINT'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.BAN_BY_FINGERPRINT')       
        this.setOutput(true, '');
        this.setColour('#F9AAE5');
        this.setTooltip('Ban user by fingerprint. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.BAN_BY_FINGERPRINT');
    }
};
javascript.javascriptGenerator.forBlock['Users_BAN_BY_FINGERPRINT'] = (block, generator) => {
    return [`Users.BAN_BY_FINGERPRINT`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Users_BAN_BY_IP'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.BAN_BY_IP')       
        this.setOutput(true, '');
        this.setColour('#F9AAE5');
        this.setTooltip('Ban user by IP address. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.BAN_BY_IP');
    }
};
javascript.javascriptGenerator.forBlock['Users_BAN_BY_IP'] = (block, generator) => {
    return [`Users.BAN_BY_IP`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Users_ignore'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.ignore')
        // Returns data

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');
        this.appendValueInput('enable') 
            .setCheck('Boolean')
            .appendField('enable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Ignores or un-ignores another avatar. Ignoring an avatar makes them disappear for you and you disappear for them.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.ignore');
    }
};
javascript.javascriptGenerator.forBlock['Users_ignore'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _enable = dfv(generator.valueToCode(block, 'enable', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);


    return `Users.ignore(${_sessionID},${_enable});\n`;};


// Blockly function
Blockly.Blocks['Users_getIgnoreStatus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.getIgnoreStatus')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');

        this.setColour('#F9AAE5');
        this.setTooltip('Gets whether or not you have ignored a particular avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.getIgnoreStatus');
    }
};
javascript.javascriptGenerator.forBlock['Users_getIgnoreStatus'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Users.getIgnoreStatus(${_sessionID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Users_personalMute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.personalMute')
        // Returns data

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');
        this.appendValueInput('muteEnabled') 
            .setCheck('Boolean')
            .appendField('muteEnabled');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Mutes or un-mutes another avatar. Muting makes you unable to hear them and them unable to hear you.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.personalMute');
    }
};
javascript.javascriptGenerator.forBlock['Users_personalMute'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _muteEnabled = dfv(generator.valueToCode(block, 'muteEnabled', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);


    return `Users.personalMute(${_sessionID},${_muteEnabled});\n`;};


// Blockly function
Blockly.Blocks['Users_getPersonalMuteStatus'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.getPersonalMuteStatus')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');

        this.setColour('#F9AAE5');
        this.setTooltip('Gets whether or not you have muted a particular avatar.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.getPersonalMuteStatus');
    }
};
javascript.javascriptGenerator.forBlock['Users_getPersonalMuteStatus'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Users.getPersonalMuteStatus(${_sessionID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Users_setAvatarGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.setAvatarGain')
        // Returns data

        // Params data
        this.appendValueInput('nodeID') 
            .setCheck('Uuid')
            .appendField('nodeID');
        this.appendValueInput('gain') 
            .setCheck('Number')
            .appendField('gain');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Sets an avatar\'s gain (volume) for you and you only, or sets the primary gain.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.setAvatarGain');
    }
};
javascript.javascriptGenerator.forBlock['Users_setAvatarGain'] = (block, generator) => {
    const _nodeID = dfv(generator.valueToCode(block, 'nodeID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _gain = dfv(generator.valueToCode(block, 'gain', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Users.setAvatarGain(${_nodeID},${_gain});\n`;};


// Blockly function
Blockly.Blocks['Users_getAvatarGain'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.getAvatarGain')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('nodeID') 
            .setCheck('Uuid')
            .appendField('nodeID');

        this.setColour('#F9AAE5');
        this.setTooltip('Gets an avatar\'s gain (volume) for you and you only, or gets the primary gain.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.getAvatarGain');
    }
};
javascript.javascriptGenerator.forBlock['Users_getAvatarGain'] = (block, generator) => {
    const _nodeID = dfv(generator.valueToCode(block, 'nodeID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Users.getAvatarGain(${_nodeID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Users_kick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.kick')
        // Returns data

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');
        this.appendValueInput('parameter') 
            .setCheck('BanFlags')
            .appendField('parameter');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Kicks and bans a user. This removes them from the server and prevents them from returning. The ban is by user name (if available) and by machine fingerprint. The ban functionality can be controlled with flags.<p>This function only works if you\'re an administrator of the domain you\'re in.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.kick');
    }
};
javascript.javascriptGenerator.forBlock['Users_kick'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _parameter = dfv(generator.valueToCode(block, 'parameter', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Users.kick(${_sessionID},${_parameter});\n`;};


// Blockly function
Blockly.Blocks['Users_mute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.mute')
        // Returns data

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Mutes a user\'s microphone for everyone. The mute is not permanent: the user can unmute themselves. <p>This function only works if you\'re an administrator of the domain you\'re in.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.mute');
    }
};
javascript.javascriptGenerator.forBlock['Users_mute'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Users.mute(${_sessionID});\n`;};


// Blockly function
Blockly.Blocks['Users_requestUsernameFromID'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.requestUsernameFromID')
        // Returns data

        // Params data
        this.appendValueInput('sessionID') 
            .setCheck('Uuid')
            .appendField('sessionID');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Requests the user name and machine fingerprint associated with the given UUID. The user name is returned via a {@link Users.usernameFromIDReply|usernameFromIDReply} signal.<p>This function only works if you\'re an administrator of the domain you\'re in.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.requestUsernameFromID');
    }
};
javascript.javascriptGenerator.forBlock['Users_requestUsernameFromID'] = (block, generator) => {
    const _sessionID = dfv(generator.valueToCode(block, 'sessionID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Users.requestUsernameFromID(${_sessionID});\n`;};


// Blockly function
Blockly.Blocks['Users_getCanKick'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.getCanKick')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F9AAE5');
        this.setTooltip('Gets whether the client can kick and ban users in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.getCanKick');
    }
};
javascript.javascriptGenerator.forBlock['Users_getCanKick'] = (block, generator) => {

return [`Users.getCanKick()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Users_toggleIgnoreRadius'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.toggleIgnoreRadius')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Toggles the state of the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.toggleIgnoreRadius');
    }
};
javascript.javascriptGenerator.forBlock['Users_toggleIgnoreRadius'] = (block, generator) => {


    return `Users.toggleIgnoreRadius();\n`;};


// Blockly function
Blockly.Blocks['Users_enableIgnoreRadius'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.enableIgnoreRadius')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Enables the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.enableIgnoreRadius');
    }
};
javascript.javascriptGenerator.forBlock['Users_enableIgnoreRadius'] = (block, generator) => {


    return `Users.enableIgnoreRadius();\n`;};


// Blockly function
Blockly.Blocks['Users_disableIgnoreRadius'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.disableIgnoreRadius')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#F9AAE5');
        this.setTooltip('Disables the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.disableIgnoreRadius');
    }
};
javascript.javascriptGenerator.forBlock['Users_disableIgnoreRadius'] = (block, generator) => {


    return `Users.disableIgnoreRadius();\n`;};


// Blockly function
Blockly.Blocks['Users_getIgnoreRadiusEnabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Users.getIgnoreRadiusEnabled')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#F9AAE5');
        this.setTooltip('Gets the status of the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.getIgnoreRadiusEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Users_getIgnoreRadiusEnabled'] = (block, generator) => {

return [`Users.getIgnoreRadiusEnabled()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Users_canKickChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Users.canKickChanged');

        this.appendDummyInput('canKick')
            .appendField('canKick:')
            .appendField(new Blockly.FieldVariable('canKickChanged_canKick'), 'canKick');

        this.setColour('#F9AAE5');
        this.setTooltip('Triggered when your ability to kick and ban users changes.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.canKickChanged');
    }
};
javascript.javascriptGenerator.forBlock['Users_canKickChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const canKick = generator.getVariableName(block.getFieldValue('canKick'));

return `Users.canKickChanged.connect((_canKick) => { 
  ${canKick} = _canKick;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Users_ignoreRadiusEnabledChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Users.ignoreRadiusEnabledChanged');

        this.appendDummyInput('isEnabled')
            .appendField('isEnabled:')
            .appendField(new Blockly.FieldVariable('ignoreRadiusEnabledChanged_isEnabled'), 'isEnabled');

        this.setColour('#F9AAE5');
        this.setTooltip('Triggered when the privacy shield status changes.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.ignoreRadiusEnabledChanged');
    }
};
javascript.javascriptGenerator.forBlock['Users_ignoreRadiusEnabledChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isEnabled = generator.getVariableName(block.getFieldValue('isEnabled'));

return `Users.ignoreRadiusEnabledChanged.connect((_isEnabled) => { 
  ${isEnabled} = _isEnabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Users_enteredIgnoreRadius'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Users.enteredIgnoreRadius');


        this.setColour('#F9AAE5');
        this.setTooltip('Triggered when another user enters the privacy shield.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.enteredIgnoreRadius');
    }
};
javascript.javascriptGenerator.forBlock['Users_enteredIgnoreRadius'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Users.enteredIgnoreRadius.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Users_usernameFromIDReply'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Users.usernameFromIDReply');

        this.appendDummyInput('sessionID')
            .appendField('sessionID:')
            .appendField(new Blockly.FieldVariable('usernameFromIDReply_sessionID'), 'sessionID');
        this.appendDummyInput('userName')
            .appendField('userName:')
            .appendField(new Blockly.FieldVariable('usernameFromIDReply_userName'), 'userName');
        this.appendDummyInput('machineFingerprint')
            .appendField('machineFingerprint:')
            .appendField(new Blockly.FieldVariable('usernameFromIDReply_machineFingerprint'), 'machineFingerprint');
        this.appendDummyInput('isAdmin')
            .appendField('isAdmin:')
            .appendField(new Blockly.FieldVariable('usernameFromIDReply_isAdmin'), 'isAdmin');

        this.setColour('#F9AAE5');
        this.setTooltip('Triggered in response to a {@link Users.requestUsernameFromID|requestUsernameFromID} call. Provides the user name and machine fingerprint associated with a UUID.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.usernameFromIDReply');
    }
};
javascript.javascriptGenerator.forBlock['Users_usernameFromIDReply'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sessionID = generator.getVariableName(block.getFieldValue('sessionID'));
    const userName = generator.getVariableName(block.getFieldValue('userName'));
    const machineFingerprint = generator.getVariableName(block.getFieldValue('machineFingerprint'));
    const isAdmin = generator.getVariableName(block.getFieldValue('isAdmin'));

return `Users.usernameFromIDReply.connect((_sessionID,_userName,_machineFingerprint,_isAdmin) => { 
  ${sessionID} = _sessionID; 
  ${userName} = _userName; 
  ${machineFingerprint} = _machineFingerprint; 
  ${isAdmin} = _isAdmin;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Users_avatarDisconnected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Users.avatarDisconnected');

        this.appendDummyInput('sessionID')
            .appendField('sessionID:')
            .appendField(new Blockly.FieldVariable('avatarDisconnected_sessionID'), 'sessionID');

        this.setColour('#F9AAE5');
        this.setTooltip('Triggered when a client has disconnected from the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Users.html#.avatarDisconnected');
    }
};
javascript.javascriptGenerator.forBlock['Users_avatarDisconnected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sessionID = generator.getVariableName(block.getFieldValue('sessionID'));

return `Users.avatarDisconnected.connect((_sessionID) => { 
  ${sessionID} = _sessionID;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Vec3_UNIT_X'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_X')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 1, y: 0, z: 0 }</code> : Unit vector in the x-axis direction. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_X');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_X'] = (block, generator) => {
    return [`Vec3.UNIT_X`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_Y'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_Y')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 1, z: 0 }</code> : Unit vector in the y-axis direction. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_Y');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_Y'] = (block, generator) => {
    return [`Vec3.UNIT_Y`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_Z'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_Z')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 0, z: 1 }</code> : Unit vector in the z-axis direction. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_Z');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_Z'] = (block, generator) => {
    return [`Vec3.UNIT_Z`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_NEG_X'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_NEG_X')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: -1, y: 0, z: 0 }</code> : Unit vector in the negative x-axis direction.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_NEG_X');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_NEG_X'] = (block, generator) => {
    return [`Vec3.UNIT_NEG_X`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_NEG_Y'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_NEG_Y')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: -1, z: 0 }</code> : Unit vector in the negative y-axis direction.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_NEG_Y');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_NEG_Y'] = (block, generator) => {
    return [`Vec3.UNIT_NEG_Y`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_NEG_Z'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_NEG_Z')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 0, z: -1 }</code> : Unit vector in the negative z-axis direction.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_NEG_Z');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_NEG_Z'] = (block, generator) => {
    return [`Vec3.UNIT_NEG_Z`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_XY'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_XY')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0.707107, y: 0.707107, z: 0 }</code> : Unit vector in the direction of the diagonal     between the x and y axes. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_XY');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_XY'] = (block, generator) => {
    return [`Vec3.UNIT_XY`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_XZ'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_XZ')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0.707107, y: 0, z: 0.707107 }</code> : Unit vector in the direction of the diagonal     between the x and z axes. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_XZ');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_XZ'] = (block, generator) => {
    return [`Vec3.UNIT_XZ`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_YZ'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_YZ')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 0.707107, z: 0.707107 }</code> : Unit vector in the direction of the diagonal     between the y and z axes. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_YZ');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_YZ'] = (block, generator) => {
    return [`Vec3.UNIT_YZ`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UNIT_XYZ'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UNIT_XYZ')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0.577350, y: 0.577350, z: 0.577350 }</code> : Unit vector in the direction of the     diagonal between the x, y, and z axes. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UNIT_XYZ');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UNIT_XYZ'] = (block, generator) => {
    return [`Vec3.UNIT_XYZ`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_FLOAT_MAX'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.FLOAT_MAX')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 3.402823e+38, y: 3.402823e+38, z: 3.402823e+38 }</code> : Vector with all axis     values set to the maximum floating point value. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.FLOAT_MAX');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_FLOAT_MAX'] = (block, generator) => {
    return [`Vec3.FLOAT_MAX`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_FLOAT_MIN'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.FLOAT_MIN')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: -3.402823e+38, y: -3.402823e+38, z: -3.402823e+38 }</code> : Vector with all axis     values set to the negative of the maximum floating point value. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.FLOAT_MIN');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_FLOAT_MIN'] = (block, generator) => {
    return [`Vec3.FLOAT_MIN`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_ZERO'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.ZERO')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 0, z: 0 }</code> : Vector with all axis values set to <code>0</code>.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.ZERO');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_ZERO'] = (block, generator) => {
    return [`Vec3.ZERO`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_ONE'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.ONE')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 1, y: 1, z: 1 }</code> : Vector with all axis values set to <code>1</code>.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.ONE');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_ONE'] = (block, generator) => {
    return [`Vec3.ONE`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_TWO'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.TWO')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 2, y: 2, z: 2 }</code> : Vector with all axis values set to <code>2</code>.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.TWO');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_TWO'] = (block, generator) => {
    return [`Vec3.TWO`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_HALF'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.HALF')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0.5, y: 0.5, z: 0.5 }</code> : Vector with all axis values set to <code>0.5</code>.     <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.HALF');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_HALF'] = (block, generator) => {
    return [`Vec3.HALF`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_RIGHT'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.RIGHT')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 1, y: 0, z: 0 }</code> : Unit vector in the "right" direction. Synonym for     <code>UNIT_X</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.RIGHT');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_RIGHT'] = (block, generator) => {
    return [`Vec3.RIGHT`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_UP'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.UP')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 1, z: 0 }</code> : Unit vector in the "up" direction. Synonym for     <code>UNIT_Y</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.UP');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_UP'] = (block, generator) => {
    return [`Vec3.UP`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Vec3_FRONT'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.FRONT')       
        this.setOutput(true, '');
        this.setColour('#01B2DC');
        this.setTooltip('<code>{ x: 0, y: 0, z: -1 }</code> : Unit vector in the "front" direction. Synonym for     <code>UNIT_NEG_Z</code>. <em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.FRONT');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_FRONT'] = (block, generator) => {
    return [`Vec3.FRONT`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Vec3_reflect'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.reflect')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');
        this.appendValueInput('normal') 
            .setCheck('Vec3')
            .appendField('normal');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the reflection of a vector in a plane.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.reflect');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_reflect'] = (block, generator) => {
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _normal = dfv(generator.valueToCode(block, 'normal', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.reflect(${_v},${_normal})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_cross'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.cross')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the cross product of two vectors.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.cross');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_cross'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.cross(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_dot'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.dot')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the dot product of two vectors.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.dot');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_dot'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.dot(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_multiply'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.multiply')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');

        this.setColour('#01B2DC');
        this.setTooltip('Multiplies a vector by a scale factor.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.multiply');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_multiply'] = (block, generator) => {
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Vec3.multiply(${_v},${_scale})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_multiplyscalev'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.multiply')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('scale') 
            .setCheck('Number')
            .appendField('scale');
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');

        this.setColour('#01B2DC');
        this.setTooltip('Multiplies a vector by a scale factor.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.multiply');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_multiplyscalev'] = (block, generator) => {
    const _scale = dfv(generator.valueToCode(block, 'scale', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.multiply(${_scale},${_v})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_multiplyVbyV'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.multiplyVbyV')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Multiplies two vectors.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.multiplyVbyV');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_multiplyVbyV'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.multiplyVbyV(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_multiplyQbyV'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.multiplyQbyV')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('q') 
            .setCheck('Quat')
            .appendField('q');
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');

        this.setColour('#01B2DC');
        this.setTooltip('Rotates a vector.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.multiplyQbyV');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_multiplyQbyV'] = (block, generator) => {
    const _q = dfv(generator.valueToCode(block, 'q', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.multiplyQbyV(${_q},${_v})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_sum'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.sum')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the sum of two vectors.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.sum');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_sum'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.sum(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_subtract'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.subtract')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates one vector subtracted from another.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.subtract');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_subtract'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.subtract(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_length'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.length')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the length of a vector');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.length');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_length'] = (block, generator) => {
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.length(${_v})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_distance'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.distance')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('p1') 
            .setCheck('Vec3')
            .appendField('p1');
        this.appendValueInput('p2') 
            .setCheck('Vec3')
            .appendField('p2');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the distance between two points.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.distance');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_distance'] = (block, generator) => {
    const _p1 = dfv(generator.valueToCode(block, 'p1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _p2 = dfv(generator.valueToCode(block, 'p2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.distance(${_p1},${_p2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_orientedAngle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.orientedAngle')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');
        this.appendValueInput('ref') 
            .setCheck('Vec3')
            .appendField('ref');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the angle of rotation from one vector onto another, with the sign depending on a reference vector.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.orientedAngle');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_orientedAngle'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _ref = dfv(generator.valueToCode(block, 'ref', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.orientedAngle(${_v1},${_v2},${_ref})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_normalize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.normalize')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');

        this.setColour('#01B2DC');
        this.setTooltip('Normalizes a vector so that its length is <code>1</code>.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.normalize');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_normalize'] = (block, generator) => {
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.normalize(${_v})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_mix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.mix')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');
        this.appendValueInput('factor') 
            .setCheck('Number')
            .appendField('factor');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates a linear interpolation between two vectors.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.mix');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_mix'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _factor = dfv(generator.valueToCode(block, 'factor', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Vec3.mix(${_v1},${_v2},${_factor})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_print'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.print')
        // Returns data

        // Params data
        this.appendValueInput('label') 
            .setCheck('String')
            .appendField('label');
        this.appendValueInput('v') 
            .setCheck('Vec3')
            .appendField('v');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#01B2DC');
        this.setTooltip('Prints the vector to the program log, as a text label followed by the vector value.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.print');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_print'] = (block, generator) => {
    const _label = dfv(generator.valueToCode(block, 'label', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v = dfv(generator.valueToCode(block, 'v', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Vec3.print(${_label},${_v});\n`;};


// Blockly function
Blockly.Blocks['Vec3_equal'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.equal')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Tests whether two vectors are equal.<p><strong>Note:</strong> The vectors must be exactly equal in order for <code>true</code> to be returned; it is often better to use {@link Vec3.withinEpsilon|withinEpsilon}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.equal');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_equal'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.equal(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_withinEpsilon'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.withinEpsilon')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');
        this.appendValueInput('epsilon') 
            .setCheck('Number')
            .appendField('epsilon');

        this.setColour('#01B2DC');
        this.setTooltip('Tests whether two vectors are equal within a tolerance.<p><strong>Note:</strong> It is often better to use this function than {@link Vec3.equal|equal}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.withinEpsilon');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_withinEpsilon'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _epsilon = dfv(generator.valueToCode(block, 'epsilon', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Vec3.withinEpsilon(${_v1},${_v2},${_epsilon})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_toPolar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.toPolar')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('p') 
            .setCheck('Vec3')
            .appendField('p');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates polar coordinates (elevation, azimuth, radius) that transform the unit z-axis vector onto a point.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.toPolar');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_toPolar'] = (block, generator) => {
    const _p = dfv(generator.valueToCode(block, 'p', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.toPolar(${_p})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_fromPolar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.fromPolar')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('polar') 
            .setCheck('Vec3')
            .appendField('polar');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the coordinates of a point from polar coordinate transformation of the unit z-axis vector.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.fromPolar');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_fromPolar'] = (block, generator) => {
    const _polar = dfv(generator.valueToCode(block, 'polar', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.fromPolar(${_polar})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_fromPolarelevationazimuth'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.fromPolar')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('elevation') 
            .setCheck('Number')
            .appendField('elevation');
        this.appendValueInput('azimuth') 
            .setCheck('Number')
            .appendField('azimuth');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the unit vector corresponding to polar coordinates elevation and azimuth transformation of the unit z-axis vector.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.fromPolar');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_fromPolarelevationazimuth'] = (block, generator) => {
    const _elevation = dfv(generator.valueToCode(block, 'elevation', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _azimuth = dfv(generator.valueToCode(block, 'azimuth', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Vec3.fromPolar(${_elevation},${_azimuth})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Vec3_getAngle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Vec3.getAngle')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');

        this.setColour('#01B2DC');
        this.setTooltip('Calculates the angle between two vectors.');
        this.setHelpUrl('https://apidocs.overte.org/Vec3.html#.getAngle');
    }
};
javascript.javascriptGenerator.forBlock['Vec3_getAngle'] = (block, generator) => {
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Vec3.getAngle(${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['WebSocket~onCloseCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket~onCloseCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('Called when the connection closes.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket~onCloseCallback');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket~onCloseCallback'] = (block, generator) => {

    return [`new WebSocket~onCloseCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket_CloseData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.CloseData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('code') 
            .setCheck('WebSocket.CloseCode')
            .appendField('code');
        this.appendValueInput('reason') 
            .setCheck('String')
            .appendField('reason');
        this.appendValueInput('wasClean') 
            .setCheck('Boolean')
            .appendField('wasClean');
        this.setColour('#45EDC1');
        this.setTooltip('Information on a connection being closed.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.CloseData');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_CloseData'] = (block, generator) => {
    const _code = dfv(generator.valueToCode(block, 'code', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _reason = dfv(generator.valueToCode(block, 'reason', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _wasClean = dfv(generator.valueToCode(block, 'wasClean', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new WebSocket.CloseData(${_code},${_reason},${_wasClean})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket~onErrorCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket~onErrorCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('Called when an error occurs.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket~onErrorCallback');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket~onErrorCallback'] = (block, generator) => {

    return [`new WebSocket~onErrorCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket_SocketError'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.SocketError')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('<p>The type of socket error.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>ConnectionRefusedError</td><td>The connection was refused or timed out.</td></tr>    <tr><td><code>1</code></td><td>RemoteHostClosedError</td><td>The remote host closed the connection.</td></tr>    <tr><td><code>2</code></td><td>HostNotFoundError</td><td>The host address was not found.</td></tr>    <tr><td><code>3</code></td><td>SocketAccessError</td><td>The socket operation failed because the application doesn\'t have      the necessary privileges.</td></tr>    <tr><td><code>4</code></td><td>SocketResourceError</td><td>The local system ran out of resources (e.g., too many       sockets).</td></tr>    <tr><td><code>5</code></td><td>SocketTimeoutError</td><td>The socket operation timed out.</td></tr>    <tr><td><code>6</code></td><td>DatagramTooLargeError</td><td>The datagram was larger than the OS\'s limit.</td></tr>    <tr><td><code>7</code></td><td>NetworkError</td><td>An error occurred with the network.</td></tr>    <tr><td><code>8</code></td><td>AddressInUseError</td><td>The is already in use and cannot be reused.</td></tr>    <tr><td><code>9</code></td><td>SocketAddressNotAvailableError</td><td>The address specified does not belong to the       host.</td></tr>    <tr><td><code>10</code></td><td>UnsupportedSocketOperationError</td><td>The requested socket operation is not supported      by the local OS.</td></tr>    <tr><td><code>11</code></td><td>ProxyAuthenticationRequiredError</td><td>The socket is using a proxy and requires       authentication.</td></tr>    <tr><td><code>12</code></td><td>SslHandshakeFailedError</td><td>The SSL/TLS handshake failed.</td></tr>    <tr><td><code>13</code></td><td>UnfinishedSocketOperationError</td><td>The last operation has not finished yet.</td></tr>    <tr><td><code>14</code></td><td>ProxyConnectionRefusedError</td><td>Could not contact the proxy server because connection       was denied.</td></tr>    <tr><td><code>15</code></td><td>ProxyConnectionClosedError</td><td>The connection to the proxy server was unexpectedly       closed.</td></tr>    <tr><td><code>16</code></td><td>ProxyConnectionTimeoutError</td><td>The connection to the proxy server timed      out.</td></tr>    <tr><td><code>17</code></td><td>ProxyNotFoundError</td><td>The proxy address was not found.</td></tr>    <tr><td><code>18</code></td><td>ProxyProtocolError</td><td>Connection to the proxy server failed because the server       response could not be understood.</td></tr>    <tr><td><code>19</code></td><td>OperationError</td><td>An operation failed because the socket state did not permit       it.</td></tr>    <tr><td><code>20</code></td><td>SslInternalError</td><td>Internal error in the SSL library being used.</td></tr>    <tr><td><code>21</code></td><td>SslInvalidUserDataError</td><td>Error in the SSL library because of invalid       data.</td></tr>    <tr><td><code>22</code></td><td>TemporaryError</td><td>A temporary error occurred.</td></tr>    <tr><td><code>-1</code></td><td>UnknownSocketError</td><td>An unknown error occurred.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.SocketError');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_SocketError'] = (block, generator) => {

    return [`new WebSocket.SocketError()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket~onMessageCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket~onMessageCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('Called when a message is received.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket~onMessageCallback');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket~onMessageCallback'] = (block, generator) => {

    return [`new WebSocket~onMessageCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket_MessageData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.MessageData')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('data') 
            .setCheck('String')
            .appendField('data');
        this.setColour('#45EDC1');
        this.setTooltip('A message received on a WebSocket connection.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.MessageData');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_MessageData'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new WebSocket.MessageData(${_data})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket~onOpenCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket~onOpenCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('Called when the connection opens.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket~onOpenCallback');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket~onOpenCallback'] = (block, generator) => {

    return [`new WebSocket~onOpenCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['WebSocket'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('binaryType') 
            .setCheck('String')
            .appendField('binaryType');
        this.appendValueInput('bufferedAmount') 
            .setCheck('Number')
            .appendField('bufferedAmount');
        this.appendValueInput('extensions') 
            .setCheck('String')
            .appendField('extensions');
        this.appendValueInput('onopen') 
            .setCheck('WebSocket~onOpenCallback')
            .appendField('onopen');
        this.appendValueInput('onmessage') 
            .setCheck('WebSocket~onMessageCallback')
            .appendField('onmessage');
        this.appendValueInput('onerror') 
            .setCheck('WebSocket~onErrorCallback')
            .appendField('onerror');
        this.appendValueInput('onclose') 
            .setCheck('WebSocket~onCloseCallback')
            .appendField('onclose');
        this.appendValueInput('protocol') 
            .setCheck('String')
            .appendField('protocol');
        this.appendValueInput('readyState') 
            .setCheck('WebSocket.ReadyState')
            .appendField('readyState');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('CONNECTING') 
            .setCheck('WebSocket.ReadyState')
            .appendField('CONNECTING');
        this.appendValueInput('OPEN') 
            .setCheck('WebSocket.ReadyState')
            .appendField('OPEN');
        this.appendValueInput('CLOSING') 
            .setCheck('WebSocket.ReadyState')
            .appendField('CLOSING');
        this.appendValueInput('CLOSED') 
            .setCheck('WebSocket.ReadyState')
            .appendField('CLOSED');
        this.setColour('#45EDC1');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Provides a bi-directional, event-driven communication session between the script and another WebSocket connection. It is a near-complete implementation of the WebSocket API described in the Mozilla docs: <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a>.<p>Create using <code>new WebSocket(...)</code> in Interface, client entity, avatar, and server entity scripts, or the {@link WebSocketServer} class in server entity and assignment client scripts.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket'] = (block, generator) => {
    const _binaryType = dfv(generator.valueToCode(block, 'binaryType', javascript.javascriptGenerator.ORDER_ATOMIC), `"blob"`);
    const _bufferedAmount = dfv(generator.valueToCode(block, 'bufferedAmount', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _extensions = dfv(generator.valueToCode(block, 'extensions', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _onopen = dfv(generator.valueToCode(block, 'onopen', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _onmessage = dfv(generator.valueToCode(block, 'onmessage', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _onerror = dfv(generator.valueToCode(block, 'onerror', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _onclose = dfv(generator.valueToCode(block, 'onclose', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _protocol = dfv(generator.valueToCode(block, 'protocol', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _readyState = dfv(generator.valueToCode(block, 'readyState', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _CONNECTING = dfv(generator.valueToCode(block, 'CONNECTING', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _OPEN = dfv(generator.valueToCode(block, 'OPEN', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _CLOSING = dfv(generator.valueToCode(block, 'CLOSING', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _CLOSED = dfv(generator.valueToCode(block, 'CLOSED', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new WebSocket(${_binaryType},${_bufferedAmount},${_extensions},${_onopen},${_onmessage},${_onerror},${_onclose},${_protocol},${_readyState},${_url},${_CONNECTING},${_OPEN},${_CLOSING},${_CLOSED})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebSocket_ReadyState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.ReadyState')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('The state of a WebSocket connection.<table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>CONNECTING</td><td>The connection is opening.</td></tr>    <tr><td><code>1</code></td><td>OPEN</td><td>The connection is open.</td></tr>    <tr><td><code>2</code></td><td>CLOSING</td><td>The connection is closing.</td></tr>    <tr><td><code>3</code></td><td>CLOSED</td><td>The connection is closed.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.ReadyState');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_ReadyState'] = (block, generator) => {

    return [`new WebSocket.ReadyState()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['WebSocket_send'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.send')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#45EDC1');
        this.setTooltip('Sends a message on the connection.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.send');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_send'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `WebSocket.send(${_message});\n`;};


// Blockly function
Blockly.Blocks['WebSocket_close'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.close')
        // Returns data

        // Params data
        this.appendValueInput('closeCode') 
            .setCheck('WebSocket.CloseCode')
            .appendField('closeCode');
        this.appendValueInput('reason') 
            .setCheck('String')
            .appendField('reason');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#45EDC1');
        this.setTooltip('Closes the connection.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.close');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_close'] = (block, generator) => {
    const _closeCode = dfv(generator.valueToCode(block, 'closeCode', javascript.javascriptGenerator.ORDER_ATOMIC), `1000`);
    const _reason = dfv(generator.valueToCode(block, 'reason', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `WebSocket.close(${_closeCode},${_reason});\n`;};


// Blockly typedef
Blockly.Blocks['WebSocket_CloseCode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocket.CloseCode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#45EDC1');
        this.setTooltip('The reason why the connection was closed.<table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>1000</code></td><td>Normal</td><td>Normal closure.</td></tr>    <tr><td><code>1001</code></td><td>GoingAway</td><td>Going away.</td></tr>    <tr><td><code>1002</code></td><td>ProtocolError</td><td>Protocol error.</td></tr>    <tr><td><code>1003</code></td><td>DatatypeNotSupported</td><td>Unsupported data.</td></tr>    <tr><td><code>1004</code></td><td>Reserved1004</td><td>Reserved.</td></tr>    <tr><td><code>1005</code></td><td>MissingStatusCode</td><td>No status received.</td></tr>    <tr><td><code>1006</code></td><td>AbnormalDisconnection</td><td>abnormal closure.</td></tr>    <tr><td><code>1007</code></td><td>WrongDatatype</td><td>Invalid frame payload data.</td></tr>    <tr><td><code>1008</code></td><td>PolicyViolated</td><td>Policy violation.</td></tr>    <tr><td><code>1009</code></td><td>TooMuchData</td><td>Message too big.</td></tr>    <tr><td><code>1010</code></td><td>MissingExtension</td><td>Mandatory extension missing.</td></tr>    <tr><td><code>1011</code></td><td>BadOperation</td><td>Internal server error.</td></tr>    <tr><td><code>1015</code></td><td>TlsHandshakeFailed</td><td>TLS handshake failed.</td></tr>  </tbody><table>');
        this.setHelpUrl('https://apidocs.overte.org/WebSocket.html#.CloseCode');
    }
};
javascript.javascriptGenerator.forBlock['WebSocket_CloseCode'] = (block, generator) => {

    return [`new WebSocket.CloseCode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['WebSocketServer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocketServer')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('port') 
            .setCheck('Number')
            .appendField('port');
        this.appendValueInput('listening') 
            .setCheck('Boolean')
            .appendField('listening');
        this.setColour('#9C9A02');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Server Entity Scripts &bull; Assignment Client Scripts</p>Manages {@link WebSocket}s in server entity and assignment client scripts.<p>Create using <code>new WebSocketServer(...)</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/WebSocketServer');
    }
};
javascript.javascriptGenerator.forBlock['WebSocketServer'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _port = dfv(generator.valueToCode(block, 'port', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _listening = dfv(generator.valueToCode(block, 'listening', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new WebSocketServer(${_url},${_port},${_listening})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['WebSocketServer_close'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebSocketServer.close')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#9C9A02');
        this.setTooltip('Closes all connections and closes the WebSocketServer.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocketServer.html#.close');
    }
};
javascript.javascriptGenerator.forBlock['WebSocketServer_close'] = (block, generator) => {


    return `WebSocketServer.close();\n`;};


// Blockly signal
Blockly.Blocks['WebSocketServer_newConnection'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('WebSocketServer.newConnection');

        this.appendDummyInput('webSocket')
            .appendField('webSocket:')
            .appendField(new Blockly.FieldVariable('newConnection_webSocket'), 'webSocket');

        this.setColour('#9C9A02');
        this.setTooltip('Triggered when there is a new connection.');
        this.setHelpUrl('https://apidocs.overte.org/WebSocketServer.html#.newConnection');
    }
};
javascript.javascriptGenerator.forBlock['WebSocketServer_newConnection'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const webSocket = generator.getVariableName(block.getFieldValue('webSocket'));

return `WebSocketServer.newConnection.connect((_webSocket) => { 
  ${webSocket} = _webSocket;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['WheelEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WheelEvent')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');
        this.appendValueInput('delta') 
            .setCheck('Number')
            .appendField('delta');
        this.appendValueInput('orientation') 
            .setCheck('String')
            .appendField('orientation');
        this.appendValueInput('isLeftButton') 
            .setCheck('Boolean')
            .appendField('isLeftButton');
        this.appendValueInput('isMiddleButton') 
            .setCheck('Boolean')
            .appendField('isMiddleButton');
        this.appendValueInput('isRightButton') 
            .setCheck('Boolean')
            .appendField('isRightButton');
        this.appendValueInput('isShifted') 
            .setCheck('Boolean')
            .appendField('isShifted');
        this.appendValueInput('isMeta') 
            .setCheck('Boolean')
            .appendField('isMeta');
        this.appendValueInput('isControl') 
            .setCheck('Boolean')
            .appendField('isControl');
        this.appendValueInput('isAlt') 
            .setCheck('Boolean')
            .appendField('isAlt');
        this.setColour('#79A9E7');
        this.setTooltip('A mouse wheel event.');
        this.setHelpUrl('https://apidocs.overte.org/WheelEvent');
    }
};
javascript.javascriptGenerator.forBlock['WheelEvent'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _delta = dfv(generator.valueToCode(block, 'delta', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _isLeftButton = dfv(generator.valueToCode(block, 'isLeftButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMiddleButton = dfv(generator.valueToCode(block, 'isMiddleButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isRightButton = dfv(generator.valueToCode(block, 'isRightButton', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isShifted = dfv(generator.valueToCode(block, 'isShifted', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isMeta = dfv(generator.valueToCode(block, 'isMeta', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isControl = dfv(generator.valueToCode(block, 'isControl', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isAlt = dfv(generator.valueToCode(block, 'isAlt', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new WheelEvent(${_x},${_y},${_delta},${_orientation},${_isLeftButton},${_isMiddleButton},${_isRightButton},${_isShifted},${_isMeta},${_isControl},${_isAlt})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['XMLHttpRequest~onReadyStateChangeCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest~onReadyStateChangeCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#6253F5');
        this.setTooltip('Called when the request\'s ready state changes.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest~onReadyStateChangeCallback');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest~onReadyStateChangeCallback'] = (block, generator) => {

    return [`new XMLHttpRequest~onReadyStateChangeCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['XMLHttpRequest~onTimeoutCallback'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest~onTimeoutCallback')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#6253F5');
        this.setTooltip('Called when the request times out.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest~onTimeoutCallback');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest~onTimeoutCallback'] = (block, generator) => {

    return [`new XMLHttpRequest~onTimeoutCallback()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['XMLHttpRequest'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('response') 
            .appendField('response');
        this.appendValueInput('responseText') 
            .setCheck('String')
            .appendField('responseText');
        this.appendValueInput('responseType') 
            .setCheck('String')
            .appendField('responseType');
        this.appendValueInput('status') 
            .setCheck('Number')
            .appendField('status');
        this.appendValueInput('statusText') 
            .setCheck('String')
            .appendField('statusText');
        this.appendValueInput('readyState') 
            .setCheck('XMLHttpRequest.ReadyState')
            .appendField('readyState');
        this.appendValueInput('errorCode') 
            .setCheck('XMLHttpRequest.NetworkError')
            .appendField('errorCode');
        this.appendValueInput('timeout') 
            .setCheck('Number')
            .appendField('timeout');
        this.appendValueInput('UNSENT') 
            .setCheck('XMLHttpRequest.ReadyState')
            .appendField('UNSENT');
        this.appendValueInput('OPENED') 
            .setCheck('XMLHttpRequest.ReadyState')
            .appendField('OPENED');
        this.appendValueInput('HEADERSRECEIVED') 
            .setCheck('XMLHttpRequest.ReadyState')
            .appendField('HEADERSRECEIVED');
        this.appendValueInput('LOADING') 
            .setCheck('XMLHttpRequest.ReadyState')
            .appendField('LOADING');
        this.appendValueInput('DONE') 
            .setCheck('XMLHttpRequest.ReadyState')
            .appendField('DONE');
        this.appendValueInput('ontimeout') 
            .setCheck('XMLHttpRequest~onTimeoutCallback')
            .appendField('ontimeout');
        this.appendValueInput('onreadystatechange') 
            .setCheck('XMLHttpRequest~onReadyStateChangeCallback')
            .appendField('onreadystatechange');
        this.setColour('#6253F5');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts &bull; Server Entity Scripts &bull; Assignment Client Scripts</p>Provides a means to interact with web servers. It is a near-complete implementation of the XMLHttpRequest API described in the Mozilla docs:<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest</a>.<p>Create using <code>new XMLHttpRequest(...)</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest'] = (block, generator) => {
    const _response = dfv(generator.valueToCode(block, 'response', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _responseText = dfv(generator.valueToCode(block, 'responseText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _responseType = dfv(generator.valueToCode(block, 'responseType', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _status = dfv(generator.valueToCode(block, 'status', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _statusText = dfv(generator.valueToCode(block, 'statusText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _readyState = dfv(generator.valueToCode(block, 'readyState', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _errorCode = dfv(generator.valueToCode(block, 'errorCode', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _timeout = dfv(generator.valueToCode(block, 'timeout', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _UNSENT = dfv(generator.valueToCode(block, 'UNSENT', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _OPENED = dfv(generator.valueToCode(block, 'OPENED', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _HEADERSRECEIVED = dfv(generator.valueToCode(block, 'HEADERSRECEIVED', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _LOADING = dfv(generator.valueToCode(block, 'LOADING', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _DONE = dfv(generator.valueToCode(block, 'DONE', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _ontimeout = dfv(generator.valueToCode(block, 'ontimeout', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _onreadystatechange = dfv(generator.valueToCode(block, 'onreadystatechange', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new XMLHttpRequest(${_response},${_responseText},${_responseType},${_status},${_statusText},${_readyState},${_errorCode},${_timeout},${_UNSENT},${_OPENED},${_HEADERSRECEIVED},${_LOADING},${_DONE},${_ontimeout},${_onreadystatechange})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['XMLHttpRequest_ReadyState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.ReadyState')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#6253F5');
        this.setTooltip('<p>The state of an XMLHttpRequest.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>UNSENT</td><td>Request has been created; {@link XMLHttpRequest.open} not called       yet.</td></tr>    <tr><td><code>1</code></td><td>OPENED</td><td>{@link XMLHttpRequest.open} has been called.</td></tr>    <tr><td><code>2</code></td><td>HEADERS_RECEIVED</td><td>{@link XMLHttpRequest.send} has been called; headers and       status are available.</td></tr>    <tr><td><code>3</code></td><td>LOADING</td><td>Downloading; {@link XMLHttpRequest|XMLHttpRequest.responseText} has       partial data.</td></tr>    <tr><td><code>4</code></td><td>DONE</td><td>Operation complete.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.ReadyState');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_ReadyState'] = (block, generator) => {

    return [`new XMLHttpRequest.ReadyState()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['XMLHttpRequest_abort'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.abort')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6253F5');
        this.setTooltip('Aborts the request.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.abort');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_abort'] = (block, generator) => {


    return `XMLHttpRequest.abort();\n`;};


// Blockly function
Blockly.Blocks['XMLHttpRequest_setRequestHeader'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.setRequestHeader')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('String')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6253F5');
        this.setTooltip('Sets the value of an HTTP request header. Must be called after {@link XMLHttpRequest.open} but before {@link XMLHttpRequest.send};');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.setRequestHeader');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_setRequestHeader'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `XMLHttpRequest.setRequestHeader(${_name},${_value});\n`;};


// Blockly function
Blockly.Blocks['XMLHttpRequest_open'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.open')
        // Returns data

        // Params data
        this.appendValueInput('method') 
            .setCheck('String')
            .appendField('method');
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('async') 
            .setCheck('Boolean')
            .appendField('async');
        this.appendValueInput('username') 
            .setCheck('String')
            .appendField('username');
        this.appendValueInput('password') 
            .setCheck('String')
            .appendField('password');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6253F5');
        this.setTooltip('Initializes a request.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.open');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_open'] = (block, generator) => {
    const _method = dfv(generator.valueToCode(block, 'method', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _async = dfv(generator.valueToCode(block, 'async', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _username = dfv(generator.valueToCode(block, 'username', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _password = dfv(generator.valueToCode(block, 'password', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `XMLHttpRequest.open(${_method},${_url},${_async},${_username},${_password});\n`;};


// Blockly function
Blockly.Blocks['XMLHttpRequest_send'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.send')
        // Returns data

        // Params data
        this.appendValueInput('data') 
            .appendField('data');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#6253F5');
        this.setTooltip('Sends the request to the server.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.send');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_send'] = (block, generator) => {
    const _data = dfv(generator.valueToCode(block, 'data', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `XMLHttpRequest.send(${_data});\n`;};


// Blockly function
Blockly.Blocks['XMLHttpRequest_getAllResponseHeaders'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.getAllResponseHeaders')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#6253F5');
        this.setTooltip('Gets the response headers.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.getAllResponseHeaders');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_getAllResponseHeaders'] = (block, generator) => {

return [`XMLHttpRequest.getAllResponseHeaders()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['XMLHttpRequest_getResponseHeader'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.getResponseHeader')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#6253F5');
        this.setTooltip('Gets a response header.');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.getResponseHeader');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_getResponseHeader'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`XMLHttpRequest.getResponseHeader(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['XMLHttpRequest_requestComplete'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('XMLHttpRequest.requestComplete');


        this.setColour('#6253F5');
        this.setTooltip('Triggered when the request is complete &mdash; with or without error (incl. timeout).');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.requestComplete');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_requestComplete'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `XMLHttpRequest.requestComplete.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['XMLHttpRequest_NetworkError'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('XMLHttpRequest.NetworkError')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#6253F5');
        this.setTooltip('<p>The type of network error.</p><table>  <thead>    <tr><th>Value</th><th>Name</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>NoError</td><td>No error.</td></tr>    <tr><td><code>1</code></td><td>ConnectionRefusedError</td><td>The server refused the connection.</td></tr>    <tr><td><code>2</code></td><td>RemoteHostClosedError</td><td>The server closed the connection.</td></tr>    <tr><td><code>3</code></td><td>HostNotFoundError</td><td>Host name not found.</td></tr>    <tr><td><code>4</code></td><td>TimeoutError</td><td>Connection timed out</td></tr>    <tr><td><code>5</code></td><td>OperationCanceledError</td><td>Operation canceled by       {@link XMLHttpRequest.abort}.</td></tr>    <tr><td><code>6</code></td><td>SslHandshakeFailedError</td><td>SSL/TLS handshake failed.</td></tr>    <tr><td><code>7</code></td><td>TemporaryNetworkFailureError</td><td>Temporarily disconnected from the       network.</td></tr>    <tr><td><code>8</code></td><td>NetworkSessionFailedError</td><td>Disconnection from the network.</td></tr>    <tr><td><code>9</code></td><td>BackgroundRequestNotAllowedError</td><td>Background request not allowed.</td></tr>    <tr><td><code>10</code></td><td>TooManyRedirectsError</td><td>Too many redirects.</td></tr>    <tr><td><code>11</code></td><td>InsecureRedirectError</td><td>Redirect from secure to insecure protocol.</td></tr>    <tr><td><code>101</code></td><td>ProxyConnectionRefusedError</td><td>Connection to proxy server refused.</td></tr>    <tr><td><code>102</code></td><td>ProxyConnectionClosedError</td><td>Proxy server closed the connection.</td></tr>    <tr><td><code>103</code></td><td>ProxyNotFoundError</td><td>Proxy host name not found.</td></tr>    <tr><td><code>104</code></td><td>ProxyTimeoutError</td><td>Proxy connection timed out.</td></tr>    <tr><td><code>105</code></td><td>ProxyAuthenticationRequiredError</td><td>Proxy requires authentication.</td></tr>    <tr><td><code>201</code></td><td>ContentAccessDenied</td><td>Access denied.</td></tr>    <tr><td><code>202</code></td><td>ContentOperationNotPermittedError</td><td>Operation not permitted.</td></tr>    <tr><td><code>203</code></td><td>ContentNotFoundError</td><td>Content not found.</td></tr>    <tr><td><code>204</code></td><td>AuthenticationRequiredError</td><td>Authentication required.</td></tr>    <tr><td><code>205</code></td><td>ContentReSendError</td><td>Resend failed.</td></tr>    <tr><td><code>206</code></td><td>ContentConflictError</td><td>Resource state conflict.</td></tr>    <tr><td><code>207</code></td><td>ContentGoneError</td><td>Resource no longer available.</td></tr>    <tr><td><code>401</code></td><td>InternalServerError</td><td>Internal server error.</td></tr>    <tr><td><code>402</code></td><td>OperationNotImplementedError</td><td>Operation not supported.</td></tr>    <tr><td><code>403</code></td><td>ServiceUnavailableError</td><td>Request not able to be handled at this       time.</td></tr>    <tr><td><code>301</code></td><td>ProtocolUnknownError</td><td>Protocol unknown.</td></tr>    <tr><td><code>302</code></td><td>ProtocolInvalidOperationError</td><td>Operation invalid fro protocol.</td></tr>    <tr><td><code>99</code></td><td>UnknownNetworkError</td><td>Unknown network-related error.</td></tr>    <tr><td><code>199</code></td><td>UnknownProxyError</td><td>Unknown proxy-related error.</td></tr>    <tr><td><code>299</code></td><td>UnknownContentError</td><td>Unknown content-related error.</td></tr>    <tr><td><code>399</code></td><td>ProtocolFailure</td><td>Protocol error.</td></tr>    <tr><td><code>499</code></td><td>UnknownServerError</td><td>Unknown server response error.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/XMLHttpRequest.html#.NetworkError');
    }
};
javascript.javascriptGenerator.forBlock['XMLHttpRequest_NetworkError'] = (block, generator) => {

    return [`new XMLHttpRequest.NetworkError()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['BillboardMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('BillboardMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#5D65E3');
        this.setTooltip('<p>How an entity is billboarded.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"none"</code></td><td>The entity will not be billboarded.</td></tr>    <tr><td><code>"yaw"</code></td><td>The entity will yaw, but not pitch, to face the camera. Its actual rotation will be       ignored.</td></tr>    <tr><td><code>"full"</code></td><td>The entity will yaw and pitch to face the camera. Its actual rotation will be       ignored.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/BillboardMode');
    }
};
javascript.javascriptGenerator.forBlock['BillboardMode'] = (block, generator) => {

    return [`new BillboardMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['BoxFace'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('BoxFace')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9F6517');
        this.setTooltip('<p>A <code>BoxFace</code> specifies the face of an axis-aligned (AA) box.<table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"MIN_X_FACE"</code></td><td>The minimum x-axis face.</td></tr>    <tr><td><code>"MAX_X_FACE"</code></td><td>The maximum x-axis face.</td></tr>    <tr><td><code>"MIN_Y_FACE"</code></td><td>The minimum y-axis face.</td></tr>    <tr><td><code>"MAX_Y_FACE"</code></td><td>The maximum y-axis face.</td></tr>    <tr><td><code>"MIN_Z_FACE"</code></td><td>The minimum z-axis face.</td></tr>    <tr><td><code>"MAX_Z_FACE"</code></td><td>The maximum z-axis face.</td></tr>    <tr><td><code>"UNKNOWN_FACE"</code></td><td>Unknown value.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/BoxFace');
    }
};
javascript.javascriptGenerator.forBlock['BoxFace'] = (block, generator) => {

    return [`new BoxFace()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_ComponentMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.ComponentMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>How an effect is applied in a {@link Entities.EntityProperties-Zone|Zone} entity.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"inherit"</code></td><td>The effect from any enclosing zone continues into this zone.</td></tr>    <tr><td><code>"disabled"</code></td><td>The effect &mdash; from any enclosing zone and this zone &mdash; is disabled in       this zone.</td></tr>    <tr><td><code>"enabled"</code></td><td>The effect from this zone is enabled, overriding the effect from any enclosing       zone.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.ComponentMode');
    }
};
javascript.javascriptGenerator.forBlock['Entities_ComponentMode'] = (block, generator) => {

    return [`new Entities.ComponentMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_AvatarPriorityMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.AvatarPriorityMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>The priority of updates from avatars in a zone to other clients.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"inherit"</code></td><td>The update priority from any enclosing zone continues into this zone.</td></tr>    <tr><td><code>"crowd"</code></td><td>The update priority in this zone is the normal priority.</td></tr>    <tr><td><code>"hero"</code></td><td>Avatars in this zone have an increased update priority.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.AvatarPriorityMode');
    }
};
javascript.javascriptGenerator.forBlock['Entities_AvatarPriorityMode'] = (block, generator) => {

    return [`new Entities.AvatarPriorityMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['DebugDraw_drawRay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DebugDraw.drawRay')
        // Returns data

        // Params data
        this.appendValueInput('start') 
            .setCheck('Vec3')
            .appendField('start');
        this.appendValueInput('end') 
            .setCheck('Vec3')
            .appendField('end');
        this.appendValueInput('color') 
            .setCheck('Vec4')
            .appendField('color');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D2614');
        this.setTooltip('Draws a line in world space, visible for a single frame. To make the line visually persist, you need to repeatedly draw it.');
        this.setHelpUrl('https://apidocs.overte.org/DebugDraw.html#.drawRay');
    }
};
javascript.javascriptGenerator.forBlock['DebugDraw_drawRay'] = (block, generator) => {
    const _start = dfv(generator.valueToCode(block, 'start', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _end = dfv(generator.valueToCode(block, 'end', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `DebugDraw.drawRay(${_start},${_end},${_color});\n`;};


// Blockly function
Blockly.Blocks['DebugDraw_drawRays'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DebugDraw.drawRays')
        // Returns data

        // Params data
        this.appendValueInput('lines') 
            .setCheck('Array')
            .appendField('lines');
        this.appendValueInput('color') 
            .setCheck('Vec4')
            .appendField('color');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D2614');
        this.setTooltip('Draws lines in world space, visible for a single frame. To make the lines visually persist, you need to repeatedly draw them.<p><strong>Note:</strong> Currently doesn\'t work.');
        this.setHelpUrl('https://apidocs.overte.org/DebugDraw.html#.drawRays');
    }
};
javascript.javascriptGenerator.forBlock['DebugDraw_drawRays'] = (block, generator) => {
    const _lines = dfv(generator.valueToCode(block, 'lines', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), `0,0,0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), `Quat.IDENTITY`);


    return `DebugDraw.drawRays(${_lines},${_color},${_translation},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['DebugDraw_addMarker'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DebugDraw.addMarker')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('color') 
            .setCheck('Vec4')
            .appendField('color');
        this.appendValueInput('size') 
            .setCheck('Number')
            .appendField('size');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D2614');
        this.setTooltip('Adds or updates a debug marker in world coordinates. This marker is drawn every frame until it is removed using  {@link DebugDraw.removeMarker|removeMarker}. If a world coordinates debug marker of the specified <code>name</code> already exists, its parameters are updated.');
        this.setHelpUrl('https://apidocs.overte.org/DebugDraw.html#.addMarker');
    }
};
javascript.javascriptGenerator.forBlock['DebugDraw_addMarker'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `DebugDraw.addMarker(${_key},${_rotation},${_position},${_color},${_size});\n`;};


// Blockly function
Blockly.Blocks['DebugDraw_removeMarker'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DebugDraw.removeMarker')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D2614');
        this.setTooltip('Removes a debug marker that was added in world coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/DebugDraw.html#.removeMarker');
    }
};
javascript.javascriptGenerator.forBlock['DebugDraw_removeMarker'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `DebugDraw.removeMarker(${_key});\n`;};


// Blockly function
Blockly.Blocks['DebugDraw_addMyAvatarMarker'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DebugDraw.addMyAvatarMarker')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('color') 
            .setCheck('Vec4')
            .appendField('color');
        this.appendValueInput('size') 
            .setCheck('Number')
            .appendField('size');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D2614');
        this.setTooltip('Adds or updates a debug marker to the world in avatar coordinates. This marker is drawn every frame until it is removed using {@link DebugDraw.removeMyAvatarMarker|removeMyAvatarMarker}. If an avatar coordinates debug marker of the specified <code>name</code> already exists, its parameters are updated. The debug marker moves with your avatar.');
        this.setHelpUrl('https://apidocs.overte.org/DebugDraw.html#.addMyAvatarMarker');
    }
};
javascript.javascriptGenerator.forBlock['DebugDraw_addMyAvatarMarker'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _color = dfv(generator.valueToCode(block, 'color', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `DebugDraw.addMyAvatarMarker(${_key},${_rotation},${_position},${_color},${_size});\n`;};


// Blockly function
Blockly.Blocks['DebugDraw_removeMyAvatarMarker'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('DebugDraw.removeMyAvatarMarker')
        // Returns data

        // Params data
        this.appendValueInput('key') 
            .setCheck('String')
            .appendField('key');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D2614');
        this.setTooltip('Removes a debug marker that was added in avatar coordinates.');
        this.setHelpUrl('https://apidocs.overte.org/DebugDraw.html#.removeMyAvatarMarker');
    }
};
javascript.javascriptGenerator.forBlock['DebugDraw_removeMyAvatarMarker'] = (block, generator) => {
    const _key = dfv(generator.valueToCode(block, 'key', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `DebugDraw.removeMyAvatarMarker(${_key});\n`;};


// Blockly typedef
Blockly.Blocks['Triangle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Triangle')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('v0') 
            .setCheck('Vec3')
            .appendField('v0');
        this.appendValueInput('v1') 
            .setCheck('Vec3')
            .appendField('v1');
        this.appendValueInput('v2') 
            .setCheck('Vec3')
            .appendField('v2');
        this.setColour('#5E5500');
        this.setTooltip('A triangle in a mesh.');
        this.setHelpUrl('https://apidocs.overte.org/Triangle');
    }
};
javascript.javascriptGenerator.forBlock['Triangle'] = (block, generator) => {
    const _v0 = dfv(generator.valueToCode(block, 'v0', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v1 = dfv(generator.valueToCode(block, 'v1', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _v2 = dfv(generator.valueToCode(block, 'v2', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Triangle(${_v0},${_v1},${_v2})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_GizmoType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.GizmoType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>A {@link Entities.EntityProperties-Gizmo|Gizmo} entity may be one of the following types:</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"ring"</code></td><td>A ring gizmo.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.GizmoType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_GizmoType'] = (block, generator) => {

    return [`new Entities.GizmoType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['BanFlags'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('BanFlags')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#AB02A4');
        this.setTooltip('<p>A set of flags for moderation ban actions. The value is constructed by using the <code>|</code> (bitwise OR) operator on the individual flag values.</p><table>  <thead>    <tr><th>Flag Name</th><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td>NO_BAN</td><td><code>0</code></td><td>Don\'t ban user when kicking. <em>This does not currently have an effect.</em></td></tr>    <tr><td>BAN_BY_USERNAME</td><td><code>1</code></td><td>Ban the person by their username.</td></tr>    <tr><td>BAN_BY_FINGERPRINT</td><td><code>2</code></td><td>Ban the person by their machine fingerprint.</td></tr>    <tr><td>BAN_BY_IP</td><td><code>4</code></td><td>Ban the person by their IP address.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/BanFlags');
    }
};
javascript.javascriptGenerator.forBlock['BanFlags'] = (block, generator) => {

    return [`new BanFlags()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['CollisionMask'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('CollisionMask')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#60CE01');
        this.setTooltip('<p>A collision may occur with the following types of items:</p><table>  <thead>    <tr><th>Value</th><th>Description</th>  </thead>  <tbody>    <tr><td><code>1</code></td><td>Static entities &mdash; non-dynamic entities with no velocity.</td></tr>    <tr><td><code>2</code></td><td>Dynamic entities &mdash; entities that have their <code>dynamic</code> property set to        <code>true</code>.</td></tr>    <tr><td><code>4</code></td><td>Kinematic entities &mdash; non-dynamic entities with velocity.</td></tr>    <tr><td><code>8</code></td><td>My avatar.</td></tr>    <tr><td><code>16</code></td><td>Other avatars.</td></tr>  </tbody></table><p>The values for the collision types that are enabled are added together to give the CollisionMask value. For example, avalue of <code>31</code> means that an entity will collide with all item types.</p>');
        this.setHelpUrl('https://apidocs.overte.org/CollisionMask');
    }
};
javascript.javascriptGenerator.forBlock['CollisionMask'] = (block, generator) => {

    return [`new CollisionMask()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['FilterFlags'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('FilterFlags')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#37A0C9');
        this.setTooltip('<p>A set of flags for a pick filter. The value is constructed by using the <code>|</code> (bitwise OR) operator on the individual flag values.</p><table>  <thead>    <tr><th>Flag Name</th><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td>PICK_DOMAIN_ENTITIES</td><td><code>1</code></td><td>Include domain entities when intersecting.</td></tr>    <tr><td>PICK_AVATAR_ENTITIES</td><td><code>2</code></td><td>Include avatar entities when intersecting.</td></tr>    <tr><td>PICK_LOCAL_ENTITIES</td><td><code>4</code></td><td>Include local entities when intersecting.</td></tr>    <tr><td>PICK_AVATATRS</td><td><code>8</code></td><td>Include avatars when intersecting.</td></tr>    <tr><td>PICK_HUD</td><td><code>16</code></td><td>Include the HUD surface when intersecting in HMD mode.</td></tr>    <tr><td>PICK_INCLUDE_VISIBLE</td><td><code>32</code></td><td>Include visible objects when intersecting.</td></tr>    <tr><td>PICK_INCLUDE_INVISIBLE</td><td><code>64</code></td><td>Include invisible objects when intersecting.</td></tr>    <tr><td>PICK_INCLUDE_COLLIDABLE</td><td><code>128</code></td><td>Include collidable objects when       intersecting.</td></tr>    <tr><td>PICK_INCLUDE_NONCOLLIDABLE</td><td><code>256</code></td><td>Include non-collidable objects when       intersecting.</td></tr>    <tr><td>PICK_PRECISE</td><td><code>512</code></td><td>Pick against exact meshes.</td></tr>    <tr><td>PICK_COARSE</td><td><code>1024</code></td><td>Pick against coarse meshes.</td></tr>    <tr><td>PICK_ALL_INTERSECTIONS</td><td><code>2048</code></td><td>Return all intersections instead of just the       closest.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/FilterFlags');
    }
};
javascript.javascriptGenerator.forBlock['FilterFlags'] = (block, generator) => {

    return [`new FilterFlags()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_PrimitiveMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.PrimitiveMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>How the geometry of an entity is rendered.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"solid"</code></td><td>The entity is drawn as a solid shape.</td></tr>    <tr><td><code>"lines"</code></td><td>The entity is drawn as wireframe.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.PrimitiveMode');
    }
};
javascript.javascriptGenerator.forBlock['Entities_PrimitiveMode'] = (block, generator) => {

    return [`new Entities.PrimitiveMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_PulseMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.PulseMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>Pulse modes for color and alpha pulsing.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"none"</code></td><td>No pulsing.</td></tr>    <tr><td><code>"in"</code></td><td>Pulse in phase with the pulse period.</td></tr>    <tr><td><code>"out"</code></td><td>Pulse out of phase with the pulse period.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.PulseMode');
    }
};
javascript.javascriptGenerator.forBlock['Entities_PulseMode'] = (block, generator) => {

    return [`new Entities.PulseMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PickRay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickRay')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');
        this.appendValueInput('direction') 
            .setCheck('Vec3')
            .appendField('direction');
        this.appendValueInput('unmodifiedDirection') 
            .setCheck('Vec3')
            .appendField('unmodifiedDirection');
        this.setColour('#9AC924');
        this.setTooltip('A vector with a starting point. It is used, for example, when finding entities or avatars that lie under a mouse click or intersect a laser beam.');
        this.setHelpUrl('https://apidocs.overte.org/PickRay');
    }
};
javascript.javascriptGenerator.forBlock['PickRay'] = (block, generator) => {
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _direction = dfv(generator.valueToCode(block, 'direction', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _unmodifiedDirection = dfv(generator.valueToCode(block, 'unmodifiedDirection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PickRay(${_origin},${_direction},${_unmodifiedDirection})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['StylusTip'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('StylusTip')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('side') 
            .setCheck('Number')
            .appendField('side');
        this.appendValueInput('tipOffset') 
            .setCheck('Vec3')
            .appendField('tipOffset');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('velocity') 
            .setCheck('Vec3')
            .appendField('velocity');
        this.setColour('#5F493F');
        this.setTooltip('The tip of a stylus.');
        this.setHelpUrl('https://apidocs.overte.org/StylusTip');
    }
};
javascript.javascriptGenerator.forBlock['StylusTip'] = (block, generator) => {
    const _side = dfv(generator.valueToCode(block, 'side', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _tipOffset = dfv(generator.valueToCode(block, 'tipOffset', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new StylusTip(${_side},${_tipOffset},${_position},${_orientation},${_velocity})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['PickParabola'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('PickParabola')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('origin') 
            .setCheck('Vec3')
            .appendField('origin');
        this.appendValueInput('velocity') 
            .setCheck('Vec3')
            .appendField('velocity');
        this.appendValueInput('acceleration') 
            .setCheck('Vec3')
            .appendField('acceleration');
        this.setColour('#231216');
        this.setTooltip('A parabola defined by a starting point, initial velocity, and acceleration. It is used, for example, when finding entities oravatars that intersect a parabolic beam.');
        this.setHelpUrl('https://apidocs.overte.org/PickParabola');
    }
};
javascript.javascriptGenerator.forBlock['PickParabola'] = (block, generator) => {
    const _origin = dfv(generator.valueToCode(block, 'origin', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _velocity = dfv(generator.valueToCode(block, 'velocity', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _acceleration = dfv(generator.valueToCode(block, 'acceleration', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new PickParabola(${_origin},${_velocity},${_acceleration})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['CollisionRegion'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('CollisionRegion')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('shape') 
            .setCheck('Shape')
            .appendField('shape');
        this.appendValueInput('loaded') 
            .setCheck('Boolean')
            .appendField('loaded');
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('threshold') 
            .setCheck('Number')
            .appendField('threshold');
        this.appendValueInput('collisionGroup') 
            .setCheck('CollisionMask')
            .appendField('collisionGroup');
        this.setColour('#44DC34');
        this.setTooltip('A volume for checking collisions in the physics simulation.');
        this.setHelpUrl('https://apidocs.overte.org/CollisionRegion');
    }
};
javascript.javascriptGenerator.forBlock['CollisionRegion'] = (block, generator) => {
    const _shape = dfv(generator.valueToCode(block, 'shape', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _loaded = dfv(generator.valueToCode(block, 'loaded', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _threshold = dfv(generator.valueToCode(block, 'threshold', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _collisionGroup = dfv(generator.valueToCode(block, 'collisionGroup', javascript.javascriptGenerator.ORDER_ATOMIC), `8`);

    return [`new CollisionRegion(${_shape},${_loaded},${_position},${_orientation},${_threshold},${_collisionGroup})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Shape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Shape')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('shapeType') 
            .setCheck('ShapeType')
            .appendField('shapeType');
        this.appendValueInput('modelUrl') 
            .setCheck('String')
            .appendField('modelUrl');
        this.appendValueInput('dimensions') 
            .setCheck('Vec3')
            .appendField('dimensions');
        this.setColour('#880C12');
        this.setTooltip('A physical volume.');
        this.setHelpUrl('https://apidocs.overte.org/Shape');
    }
};
javascript.javascriptGenerator.forBlock['Shape'] = (block, generator) => {
    const _shapeType = dfv(generator.valueToCode(block, 'shapeType', javascript.javascriptGenerator.ORDER_ATOMIC), `"none"`);
    const _modelUrl = dfv(generator.valueToCode(block, 'modelUrl', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _dimensions = dfv(generator.valueToCode(block, 'dimensions', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new Shape(${_shapeType},${_modelUrl},${_dimensions})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ContactEventType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ContactEventType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#DFAA92');
        this.setTooltip('<p>The type of a collision contact event.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>Start of the collision.</td></tr>    <tr><td><code>1</code></td><td>Continuation of the collision.</td></tr>    <tr><td><code>2</code></td><td>End of the collision.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/ContactEventType');
    }
};
javascript.javascriptGenerator.forBlock['ContactEventType'] = (block, generator) => {

    return [`new ContactEventType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['MeshProxy#getNumVertices'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MeshProxy#getNumVertices')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#D11F9F');
        this.setTooltip('Gets the number of vertices in the mesh.');
        this.setHelpUrl('https://apidocs.overte.org/MeshProxy#getNumVertices');
    }
};
javascript.javascriptGenerator.forBlock['MeshProxy#getNumVertices'] = (block, generator) => {

return [`MeshProxy#getNumVertices()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MeshProxy#getPos'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MeshProxy#getPos')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#D11F9F');
        this.setTooltip('Gets the position of a vertex in the mesh.');
        this.setHelpUrl('https://apidocs.overte.org/MeshProxy#getPos');
    }
};
javascript.javascriptGenerator.forBlock['MeshProxy#getPos'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MeshProxy#getPos(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly typedef
Blockly.Blocks['Entities_RenderLayer'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.RenderLayer')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>A layer in which an entity may be rendered.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"world"</code></td><td>The entity is drawn in the world with everything else.</td></tr>    <tr><td><code>"front"</code></td><td>The entity is drawn on top of the world layer but behind the HUD surface.</td></tr>    <tr><td><code>"hud"</code></td><td>The entity is drawn on top of other layers and the HUD surface.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.RenderLayer');
    }
};
javascript.javascriptGenerator.forBlock['Entities_RenderLayer'] = (block, generator) => {

    return [`new Entities.RenderLayer()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ResourceRequestObserver_ResourceRequest'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ResourceRequestObserver.ResourceRequest')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('callerId') 
            .setCheck('Number')
            .appendField('callerId');
        this.appendValueInput('extra') 
            .setCheck('String')
            .appendField('extra');
        this.setColour('#4AA160');
        this.setTooltip('Information about a resource request.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceRequestObserver.html#.ResourceRequest');
    }
};
javascript.javascriptGenerator.forBlock['ResourceRequestObserver_ResourceRequest'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _callerId = dfv(generator.valueToCode(block, 'callerId', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _extra = dfv(generator.valueToCode(block, 'extra', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ResourceRequestObserver.ResourceRequest(${_url},${_callerId},${_extra})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly signal
Blockly.Blocks['ResourceRequestObserver_resourceRequestEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ResourceRequestObserver.resourceRequestEvent');

        this.appendDummyInput('request')
            .appendField('request:')
            .appendField(new Blockly.FieldVariable('resourceRequestEvent_request'), 'request');

        this.setColour('#4AA160');
        this.setTooltip('Triggered when an observable resource request is made.');
        this.setHelpUrl('https://apidocs.overte.org/ResourceRequestObserver.html#.resourceRequestEvent');
    }
};
javascript.javascriptGenerator.forBlock['ResourceRequestObserver_resourceRequestEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const request = generator.getVariableName(block.getFieldValue('request'));

return `ResourceRequestObserver.resourceRequestEvent.connect((_request) => { 
  ${request} = _request;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['ShapeType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ShapeType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#8F0C2F');
        this.setTooltip('<p>Defines the shape used for collisions or zones.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"none"</code></td><td>No shape.</td></tr>    <tr><td><code>"box"</code></td><td>A cube.</td></tr>    <tr><td><code>"sphere"</code></td><td>A sphere.</td></tr>    <tr><td><code>"capsule-x"</code></td><td>A capsule (cylinder with spherical ends) oriented on the x-axis.</td></tr>    <tr><td><code>"capsule-y"</code></td><td>A capsule (cylinder with spherical ends) oriented on the y-axis.</td></tr>    <tr><td><code>"capsule-z"</code></td><td>A capsule (cylinder with spherical ends) oriented on the z-axis.</td></tr>    <tr><td><code>"cylinder-x"</code></td><td>A cylinder oriented on the x-axis.</td></tr>    <tr><td><code>"cylinder-y"</code></td><td>A cylinder oriented on the y-axis.</td></tr>    <tr><td><code>"cylinder-z"</code></td><td>A cylinder oriented on the z-axis.</td></tr>    <tr><td><code>"hull"</code></td><td><em>Not used.</em></td></tr>    <tr><td><code>"compound"</code></td><td>A compound convex hull specified in an OBJ file.</td></tr>    <tr><td><code>"simple-hull"</code></td><td>A convex hull automatically generated from the model.</td></tr>    <tr><td><code>"simple-compound"</code></td><td>A compound convex hull automatically generated from the model, using         sub-meshes.</td></tr>    <tr><td><code>"static-mesh"</code></td><td>The exact shape of the model.</td></tr>    <tr><td><code>"plane"</code></td><td>A plane.</td></tr>    <tr><td><code>"ellipsoid"</code></td><td>An ellipsoid.</td></tr>    <tr><td><code>"circle"</code></td><td>A circle.</td></tr>    <tr><td><code>"multisphere"</code></td><td>A convex hull generated from a set of spheres.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/ShapeType');
    }
};
javascript.javascriptGenerator.forBlock['ShapeType'] = (block, generator) => {

    return [`new ShapeType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_NestableType'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.NestableType')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>An in-world item may be one of the following types:</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"entity"</code></td><td>The item is an entity.</td></tr>    <tr><td><code>"avatar"</code></td><td>The item is an avatar.</td></tr>    <tr><td><code>"unknown"</code></td><td>The item cannot be found.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.NestableType');
    }
};
javascript.javascriptGenerator.forBlock['Entities_NestableType'] = (block, generator) => {

    return [`new Entities.NestableType()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_TextAlignment'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.TextAlignment')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>A {@link Entities.EntityProperties-Text|Text} entity may use one of the following alignments:</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"left"</code></td><td>Text is aligned to the left side.</td></tr>    <tr><td><code>"center"</code></td><td>Text is centered.</td></tr>    <tr><td><code>"right"</code></td><td>Text is aligned to the right side.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.TextAlignment');
    }
};
javascript.javascriptGenerator.forBlock['Entities_TextAlignment'] = (block, generator) => {

    return [`new Entities.TextAlignment()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Entities_TextEffect'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Entities.TextEffect')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#EA9958');
        this.setTooltip('<p>A {@link Entities.EntityProperties-Text|Text} entity may use one of the following effects:</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"none"</code></td><td>No effect.</td></tr>    <tr><td><code>"outline"</code></td><td>An outline effect.</td></tr>    <tr><td><code>"outline fill"</code></td><td>An outline effect, with fill.</td></tr>    <tr><td><code>"shadow"</code></td><td>A shadow effect.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Entities.html#.TextEffect');
    }
};
javascript.javascriptGenerator.forBlock['Entities_TextEffect'] = (block, generator) => {

    return [`new Entities.TextEffect()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['WebInputMode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('WebInputMode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#3CF583');
        this.setTooltip('<p>Specifies how a web surface processes events.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>"touch"</code></td><td>Events are processed as touch events.</td></tr>    <tr><td><code>"mouse"</code></td><td>Events are processed as mouse events.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/WebInputMode');
    }
};
javascript.javascriptGenerator.forBlock['WebInputMode'] = (block, generator) => {

    return [`new WebInputMode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Camera_Mode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.Mode')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#967D35');
        this.setTooltip('<p>Camera modes affect the position of the camera and the controls for camera movement. The camera can be in one of thefollowing modes:</p><table>  <thead>    <tr>      <th>Mode</th>      <th>String</th>      <th>Description</th>    </tr>  </thead>  <tbody>    <tr>      <td><strong>First&nbsp;Person</strong></td>      <td><code>"first&nbsp;person"</code></td>      <td><p>The camera is positioned such that you have the same view as your avatar. The camera moves and rotates with      your avatar.</p>      <p><em>Legacy first person camera mode.</em></p></td>    </tr>    <tr>      <td><strong>First&nbsp;Person&nbsp;Look&nbsp;At</strong></td>      <td><code>"first&nbsp;person&nbsp;look&nbsp;at"</code></td>      <td><p>The camera is positioned such that you have the same view as your avatar. The camera moves and rotates with       your avatar\'s head.</p>      <p><em>Default first person camera mode.</em></p></td>    </tr>    <tr>      <td><strong>Third&nbsp;Person</strong></td>      <td><code>"third&nbsp;person"</code></td>      <td><p>The camera is positioned such that you have a view from just behind your avatar. The camera moves and rotates       with your avatar.</p>        <p><em>Legacy third person camera camera mode.</em></p>       <pre class="prettyprint"><code>Camera.mode = "third person";</code></pre></td>    </tr>    <tr>      <td><strong>Look&nbsp;At</strong></td>      <td><code>"look&nbsp;at"</code></td>      <td><p>The camera is positioned behind your avatar. The camera moves and rotates independently from your avatar. The      avatar\'s head always faces the camera look at point.</p>      <p><em>Default third person camera mode.</em></td>    </tr>    <tr>      <td><strong>Selfie</strong></td>      <td><code>"selfie"</code></td>      <td><p>The camera is positioned in front of your avatar. The camera moves and rotates independently from your avatar.      Your avatar\'s head is always facing the camera.</p>      <p><em>Default "look at myself" camera mode.</em></p></td>    </tr>    <tr>      <td><strong>Mirror</strong></td>      <td><code>"mirror"</code></td>      <td><p>The camera is positioned such that you are looking directly at your avatar. The camera is fixed and does not       move with your avatar.</p>       <p><em>Legacy "look at myself" behavior.</em></p>      <pre class="prettyprint"><code>Camera.mode = "mirror";</code></pre></td>    </tr>    <tr>      <td><strong>Independent</strong></td>      <td><code>"independent"</code></td>      <td>The camera\'s position and orientation don\'t change with your avatar movement. Instead, they can be set via       scripting.</td>    </tr>    <tr>      <td><strong>Entity</strong></td>      <td><code>"entity"</code></td>      <td>The camera\'s position and orientation are set to be the same as a specified entity\'s, and move with the entity as      it moves.    </tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.Mode');
    }
};
javascript.javascriptGenerator.forBlock['Camera_Mode'] = (block, generator) => {

    return [`new Camera.Mode()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['ViewFrustum'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ViewFrustum')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');
        this.appendValueInput('centerRadius') 
            .setCheck('Number')
            .appendField('centerRadius');
        this.appendValueInput('fieldOfView') 
            .setCheck('Number')
            .appendField('fieldOfView');
        this.appendValueInput('aspectRatio') 
            .setCheck('Number')
            .appendField('aspectRatio');
        this.appendValueInput('projection') 
            .setCheck('Mat4')
            .appendField('projection');
        this.setColour('#6BDF9D');
        this.setTooltip('A ViewFrustum has a "keyhole" shape: a regular frustum for stuff that is visible plus a central sphere for stuff that isnearby (for physics simulation).');
        this.setHelpUrl('https://apidocs.overte.org/ViewFrustum');
    }
};
javascript.javascriptGenerator.forBlock['ViewFrustum'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _centerRadius = dfv(generator.valueToCode(block, 'centerRadius', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _fieldOfView = dfv(generator.valueToCode(block, 'fieldOfView', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _aspectRatio = dfv(generator.valueToCode(block, 'aspectRatio', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _projection = dfv(generator.valueToCode(block, 'projection', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new ViewFrustum(${_position},${_orientation},${_centerRadius},${_fieldOfView},${_aspectRatio},${_projection})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Camera_getModeString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getModeString')
        // Returns data
        this.setOutput(true, '["Camera.Mode"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the current camera mode. You can also get the mode using the {@link Camera|Camera.mode} property.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getModeString');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getModeString'] = (block, generator) => {

return [`Camera.getModeString()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setModeString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setModeString')
        // Returns data

        // Params data
        this.appendValueInput('mode') 
            .setCheck('Camera.Mode')
            .appendField('mode');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the camera mode. You can also set the mode using the {@link Camera|Camera.mode} property.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setModeString');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setModeString'] = (block, generator) => {
    const _mode = dfv(generator.valueToCode(block, 'mode', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Camera.setModeString(${_mode});\n`;};


// Blockly function
Blockly.Blocks['Camera_getPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getPosition')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the current camera position. You can also get the position using the {@link Camera|Camera.position} property.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getPosition');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getPosition'] = (block, generator) => {

return [`Camera.getPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the camera position. You can also set the position using the {@link Camera|Camera.position} property. Only works if the camera is in independent mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setPosition'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Camera.setPosition(${_position});\n`;};


// Blockly function
Blockly.Blocks['Camera_getOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getOrientation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the current camera orientation. You can also get the orientation using the {@link Camera|Camera.orientation} property.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getOrientation');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getOrientation'] = (block, generator) => {

return [`Camera.getOrientation()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setOrientation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setOrientation')
        // Returns data

        // Params data
        this.appendValueInput('orientation') 
            .setCheck('Quat')
            .appendField('orientation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the camera orientation. You can also set the orientation using the {@link Camera|Camera.orientation} property. Onlyworks if the camera is in independent mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setOrientation');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setOrientation'] = (block, generator) => {
    const _orientation = dfv(generator.valueToCode(block, 'orientation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Camera.setOrientation(${_orientation});\n`;};


// Blockly function
Blockly.Blocks['Camera_getCaptureMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getCaptureMouse')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the current mouse capture state.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getCaptureMouse');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getCaptureMouse'] = (block, generator) => {

return [`Camera.getCaptureMouse()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setCaptureMouse'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setCaptureMouse')
        // Returns data

        // Params data
        this.appendValueInput('captureMouse') 
            .setCheck('Boolean')
            .appendField('captureMouse');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the mouse capture state.  When <code>true</code>, the mouse is invisible and cannot leave the bounds ofInterface, as long as Interface is the active window and no menu item is selected.  When <code>false</code>, the mousebehaves normally.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setCaptureMouse');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setCaptureMouse'] = (block, generator) => {
    const _captureMouse = dfv(generator.valueToCode(block, 'captureMouse', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Camera.setCaptureMouse(${_captureMouse});\n`;};


// Blockly function
Blockly.Blocks['Camera_getMouseLook'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getMouseLook')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the current mouse look setting state.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getMouseLook');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getMouseLook'] = (block, generator) => {

return [`Camera.getMouseLook()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setMouseLook'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setMouseLook')
        // Returns data

        // Params data
        this.appendValueInput('mouseLook') 
            .setCheck('Boolean')
            .appendField('mouseLook');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the mouse look setting state.  When <code>true</code>, the mouse look setting is enabled (mouse look can be toggledwith M key in this mode).  When <code>false</code>, the mouse behaves normally.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setMouseLook');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setMouseLook'] = (block, generator) => {
    const _mouseLook = dfv(generator.valueToCode(block, 'mouseLook', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `Camera.setMouseLook(${_mouseLook});\n`;};


// Blockly function
Blockly.Blocks['Camera_getSensitivity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.getSensitivity')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#967D35');
        this.setTooltip('Gets the current camera sensitivity.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.getSensitivity');
    }
};
javascript.javascriptGenerator.forBlock['Camera_getSensitivity'] = (block, generator) => {

return [`Camera.getSensitivity()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_setSensitivity'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.setSensitivity')
        // Returns data

        // Params data
        this.appendValueInput('sensitivity') 
            .setCheck('Number')
            .appendField('sensitivity');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the camera sensitivity.  Higher values mean that the camera will be more sensitive to mouse movements.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.setSensitivity');
    }
};
javascript.javascriptGenerator.forBlock['Camera_setSensitivity'] = (block, generator) => {
    const _sensitivity = dfv(generator.valueToCode(block, 'sensitivity', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `Camera.setSensitivity(${_sensitivity});\n`;};


// Blockly function
Blockly.Blocks['Camera_computePickRay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.computePickRay')
        // Returns data
        this.setOutput(true, '["PickRay"]');

        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');

        this.setColour('#967D35');
        this.setTooltip('Computes a {@link PickRay} based on the current camera configuration and the specified <code>x, y</code> position on the screen. The {@link PickRay} can be used in functions such as {@link Entities.findRayIntersection} and {@link Overlays.findRayIntersection}.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.computePickRay');
    }
};
javascript.javascriptGenerator.forBlock['Camera_computePickRay'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Camera.computePickRay(${_x},${_y})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Camera_lookAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.lookAt')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Rotates the camera to look at the specified <code>position</code>. Only works if the camera is in independent mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.lookAt');
    }
};
javascript.javascriptGenerator.forBlock['Camera_lookAt'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Camera.lookAt(${_position});\n`;};


// Blockly function
Blockly.Blocks['Camera_keepLookingAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.keepLookingAt')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec3')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Sets the camera to continue looking at the specified <code>position</code> even while the camera moves. Only works if the camera is in independent mode.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.keepLookingAt');
    }
};
javascript.javascriptGenerator.forBlock['Camera_keepLookingAt'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Camera.keepLookingAt(${_position});\n`;};


// Blockly function
Blockly.Blocks['Camera_stopLookingAt'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Camera.stopLookingAt')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#967D35');
        this.setTooltip('Stops the camera from continually looking at the position that was set with {@link Camera.keepLookingAt}.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.stopLookingAt');
    }
};
javascript.javascriptGenerator.forBlock['Camera_stopLookingAt'] = (block, generator) => {


    return `Camera.stopLookingAt();\n`;};


// Blockly signal
Blockly.Blocks['Camera_modeUpdated'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Camera.modeUpdated');

        this.appendDummyInput('newMode')
            .appendField('newMode:')
            .appendField(new Blockly.FieldVariable('modeUpdated_newMode'), 'newMode');

        this.setColour('#967D35');
        this.setTooltip('Triggered when the camera mode changes.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.modeUpdated');
    }
};
javascript.javascriptGenerator.forBlock['Camera_modeUpdated'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const newMode = generator.getVariableName(block.getFieldValue('newMode'));

return `Camera.modeUpdated.connect((_newMode) => { 
  ${newMode} = _newMode;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Camera_captureMouseChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Camera.captureMouseChanged');

        this.appendDummyInput('newCaptureMouse')
            .appendField('newCaptureMouse:')
            .appendField(new Blockly.FieldVariable('captureMouseChanged_newCaptureMouse'), 'newCaptureMouse');

        this.setColour('#967D35');
        this.setTooltip('Triggered when the camera mouse capture state changes.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.captureMouseChanged');
    }
};
javascript.javascriptGenerator.forBlock['Camera_captureMouseChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const newCaptureMouse = generator.getVariableName(block.getFieldValue('newCaptureMouse'));

return `Camera.captureMouseChanged.connect((_newCaptureMouse) => { 
  ${newCaptureMouse} = _newCaptureMouse;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Camera_mouseLookChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Camera.mouseLookChanged');

        this.appendDummyInput('mouseLookChanged')
            .appendField('mouseLookChanged:')
            .appendField(new Blockly.FieldVariable('mouseLookChanged_mouseLookChanged'), 'mouseLookChanged');

        this.setColour('#967D35');
        this.setTooltip('Triggered when mouse look setting changes.');
        this.setHelpUrl('https://apidocs.overte.org/Camera.html#.mouseLookChanged');
    }
};
javascript.javascriptGenerator.forBlock['Camera_mouseLookChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const mouseLookChanged = generator.getVariableName(block.getFieldValue('mouseLookChanged'));

return `Camera.mouseLookChanged.connect((_mouseLookChanged) => { 
  ${mouseLookChanged} = _mouseLookChanged;
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['Workload_cpuRunTime'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.cpuRunTime')       
        this.setOutput(true, '');
        this.setColour('#68EAAB');
        this.setTooltip('<em>Read-only.</em>');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.cpuRunTime');
    }
};
javascript.javascriptGenerator.forBlock['Workload_cpuRunTime'] = (block, generator) => {
    return [`Workload.cpuRunTime`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Workload_enabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.enabled')       
        this.setOutput(true, '');
        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.enabled');
    }
};
javascript.javascriptGenerator.forBlock['Workload_enabled'] = (block, generator) => {
    return [`Workload.enabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['Workload_branch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.branch')       
        this.setOutput(true, '');
        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.branch');
    }
};
javascript.javascriptGenerator.forBlock['Workload_branch'] = (block, generator) => {
    return [`Workload.branch`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly function
Blockly.Blocks['Workload_toJSON'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.toJSON')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.toJSON');
    }
};
javascript.javascriptGenerator.forBlock['Workload_toJSON'] = (block, generator) => {

return [`Workload.toJSON()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_load'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.load')
        // Returns data

        // Params data
        this.appendValueInput('map') 
            .setCheck('object')
            .appendField('map');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.load');
    }
};
javascript.javascriptGenerator.forBlock['Workload_load'] = (block, generator) => {
    const _map = dfv(generator.valueToCode(block, 'map', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Workload.load(${_map});\n`;};


// Blockly function
Blockly.Blocks['Workload_getConfig'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.getConfig')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.getConfig');
    }
};
javascript.javascriptGenerator.forBlock['Workload_getConfig'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Workload.getConfig(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_isTask'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.isTask')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.isTask');
    }
};
javascript.javascriptGenerator.forBlock['Workload_isTask'] = (block, generator) => {

return [`Workload.isTask()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_isSwitch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.isSwitch')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.isSwitch');
    }
};
javascript.javascriptGenerator.forBlock['Workload_isSwitch'] = (block, generator) => {

return [`Workload.isSwitch()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_getSubConfigs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.getSubConfigs')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.getSubConfigs');
    }
};
javascript.javascriptGenerator.forBlock['Workload_getSubConfigs'] = (block, generator) => {

return [`Workload.getSubConfigs()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_getNumSubs'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.getNumSubs')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.getNumSubs');
    }
};
javascript.javascriptGenerator.forBlock['Workload_getNumSubs'] = (block, generator) => {

return [`Workload.getNumSubs()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_getSubConfig'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.getSubConfig')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.getSubConfig');
    }
};
javascript.javascriptGenerator.forBlock['Workload_getSubConfig'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`Workload.getSubConfig(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Workload_loadjson'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.load')
        // Returns data

        // Params data
        this.appendValueInput('json') 
            .setCheck('object')
            .appendField('json');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.load');
    }
};
javascript.javascriptGenerator.forBlock['Workload_loadjson'] = (block, generator) => {
    const _json = dfv(generator.valueToCode(block, 'json', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Workload.load(${_json});\n`;};


// Blockly function
Blockly.Blocks['Workload_refresh'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Workload.refresh')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.refresh');
    }
};
javascript.javascriptGenerator.forBlock['Workload_refresh'] = (block, generator) => {


    return `Workload.refresh();\n`;};


// Blockly signal
Blockly.Blocks['Workload_loaded'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Workload.loaded');


        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.loaded');
    }
};
javascript.javascriptGenerator.forBlock['Workload_loaded'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Workload.loaded.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Workload_newStats'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Workload.newStats');


        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.newStats');
    }
};
javascript.javascriptGenerator.forBlock['Workload_newStats'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Workload.newStats.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Workload_dirtyEnabled'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Workload.dirtyEnabled');


        this.setColour('#68EAAB');
        this.setTooltip('');
        this.setHelpUrl('https://apidocs.overte.org/Workload.html#.dirtyEnabled');
    }
};
javascript.javascriptGenerator.forBlock['Workload_dirtyEnabled'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Workload.dirtyEnabled.connect(() => {
${innerCode}
});\n`;};

// Blockly namespace
Blockly.Blocks['OffscreenFlags_navigationFocused'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OffscreenFlags.navigationFocused')       
        this.setOutput(true, '');
        this.setColour('#8CA622');
        this.setTooltip('<code>true</code> if UI has joystick navigation focus, <code>false</code> if it    doesn\'t.');
        this.setHelpUrl('https://apidocs.overte.org/OffscreenFlags.html#.navigationFocused');
    }
};
javascript.javascriptGenerator.forBlock['OffscreenFlags_navigationFocused'] = (block, generator) => {
    return [`OffscreenFlags.navigationFocused`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly namespace
Blockly.Blocks['OffscreenFlags_navigationFocusDisabled'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OffscreenFlags.navigationFocusDisabled')       
        this.setOutput(true, '');
        this.setColour('#8CA622');
        this.setTooltip('<code>true</code> if UI joystick navigation focus is disabled,    <code>false</code> if it isn\'t.');
        this.setHelpUrl('https://apidocs.overte.org/OffscreenFlags.html#.navigationFocusDisabled');
    }
};
javascript.javascriptGenerator.forBlock['OffscreenFlags_navigationFocusDisabled'] = (block, generator) => {
    return [`OffscreenFlags.navigationFocusDisabled`, javascript.javascriptGenerator.ORDER_NONE];
};
// Blockly signal
Blockly.Blocks['OffscreenFlags_navigationFocusedChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OffscreenFlags.navigationFocusedChanged');


        this.setColour('#8CA622');
        this.setTooltip('Triggered when the value of the <code>navigationFocused</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/OffscreenFlags.html#.navigationFocusedChanged');
    }
};
javascript.javascriptGenerator.forBlock['OffscreenFlags_navigationFocusedChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OffscreenFlags.navigationFocusedChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OffscreenFlags_navigationFocusDisabledChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OffscreenFlags.navigationFocusDisabledChanged');


        this.setColour('#8CA622');
        this.setTooltip('Triggered when the value of the <code>navigationFocusDisabled</code> property changes.');
        this.setHelpUrl('https://apidocs.overte.org/OffscreenFlags.html#.navigationFocusDisabledChanged');
    }
};
javascript.javascriptGenerator.forBlock['OffscreenFlags_navigationFocusDisabledChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OffscreenFlags.navigationFocusDisabledChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['QmlFragmentClass#addButton'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('QmlFragmentClass#addButton')
        // Returns data
        this.setOutput(true, '["TabletButtonProxy"]');

        // Params data
        this.appendValueInput('properties') 
            .setCheck('object')
            .appendField('properties');

        this.setColour('#AE9BD6');
        this.setTooltip('Creates a new button, adds it to this and returns it.');
        this.setHelpUrl('https://apidocs.overte.org/QmlFragmentClass#addButton');
    }
};
javascript.javascriptGenerator.forBlock['QmlFragmentClass#addButton'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`QmlFragmentClass#addButton(${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly class
Blockly.Blocks['OverlayWebWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');
        this.appendValueInput('size') 
            .setCheck('Vec2')
            .appendField('size');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.setColour('#C738B3');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>A <code>OverlayWebWindow</code> displays an HTML window inside Interface.<p>Create using <code>new OverlayWebWindow(...)</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new OverlayWebWindow(${_url},${_position},${_size},${_visible})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['OverlayWebWindow_emitScriptEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.emitScriptEvent')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Sends a message to the HTML page. To receive the message, the HTML page\'s script must connect to the <code>EventBridge</code>that is automatically provided for the script:<pre class="prettyprint"><code>EventBridge.scriptEventReceived.connect(function(message) {    ...});</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.emitScriptEvent');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_emitScriptEvent'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWebWindow.emitScriptEvent(${_message});\n`;};


// Blockly signal
Blockly.Blocks['OverlayWebWindow_webEventReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.webEventReceived');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('webEventReceived_message'), 'message');

        this.setColour('#C738B3');
        this.setTooltip('Triggered when a message from the HTML page is received. The HTML page can send a message by calling:<pre class="prettyprint"><code>EventBridge.emitWebEvent(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.webEventReceived');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_webEventReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `OverlayWebWindow.webEventReceived.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['OverlayWebWindow_getURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.getURL')
        // Returns data
        this.setOutput(true, '["String"]');

        // Params data

        this.setColour('#C738B3');
        this.setTooltip('Gets the URL of the HTML displayed.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.getURL');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_getURL'] = (block, generator) => {

return [`OverlayWebWindow.getURL()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setURL')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Loads HTML into the window, replacing current window content.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setURL');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setURL'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWebWindow.setURL(${_url});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setScriptURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setScriptURL')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Injects a script into the HTML page, replacing any currently injected script.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setScriptURL');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setScriptURL'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWebWindow.setScriptURL(${_url});\n`;};


// Blockly signal
Blockly.Blocks['OverlayWebWindow_urlChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.urlChanged');


        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window\'s URL changes.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.urlChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_urlChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWebWindow.urlChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['OverlayWindow_Properties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.Properties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');
        this.appendValueInput('source') 
            .setCheck('String')
            .appendField('source');
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.setColour('#8DB05D');
        this.setTooltip('Properties used to initialize an {@link OverlayWindow} or {@link OverlayWebWindow}.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.Properties');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_Properties'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), `"WebWindow`);
    const _source = dfv(generator.valueToCode(block, 'source', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);

    return [`new OverlayWindow.Properties(${_title},${_source},${_width},${_height},${_visible})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['OverlayWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');
        this.appendValueInput('size') 
            .setCheck('Vec2')
            .appendField('size');
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');
        this.setColour('#8DB05D');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>A <code>OverlayWindow</code> displays a QML window inside Interface.<p>The QML can optionally include a <code>WebView</code> control that embeds an HTML-based windows. (The <code>WebView</code> control is defined by a "WebView.qml" file included in the Interface install.) Alternatively, an {@link OverlayWebWindow} can be used for HTML-based windows.</p><p>Create using <code>new OverlayWindow(...)</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);

    return [`new OverlayWindow(${_position},${_size},${_visible})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['OverlayWindow_isVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.isVisible')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#8DB05D');
        this.setTooltip('Gets whether the window is shown or hidden.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.isVisible');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_isVisible'] = (block, generator) => {

return [`OverlayWindow.isVisible()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWindow_setVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.setVisible')
        // Returns data

        // Params data
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Shows or hides the window.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.setVisible');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_setVisible'] = (block, generator) => {
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `OverlayWindow.setVisible(${_visible});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_getPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.getPosition')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#8DB05D');
        this.setTooltip('Gets the position of the window.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.getPosition');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_getPosition'] = (block, generator) => {

return [`OverlayWindow.getPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWindow_setPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sets the position of the window, from a {@link Vec2}.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_setPosition'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWindow.setPosition(${_position});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_setPositionxy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sets the position of the window, from a pair of numbers.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_setPositionxy'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `OverlayWindow.setPosition(${_x},${_y});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_getSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.getSize')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#8DB05D');
        this.setTooltip('Gets the size of the window interior.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.getSize');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_getSize'] = (block, generator) => {

return [`OverlayWindow.getSize()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWindow_setSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.setSize')
        // Returns data

        // Params data
        this.appendValueInput('size') 
            .setCheck('Vec2')
            .appendField('size');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sets the size of the window interior, from a {@link Vec2}.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.setSize');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_setSize'] = (block, generator) => {
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWindow.setSize(${_size});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_setSizewidthheight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.setSize')
        // Returns data

        // Params data
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sets the size of the window interior, from a pair of numbers.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.setSize');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_setSizewidthheight'] = (block, generator) => {
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `OverlayWindow.setSize(${_width},${_height});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_setTitle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.setTitle')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sets the window title.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.setTitle');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_setTitle'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWindow.setTitle(${_title});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_raise'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.raise')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Raises the window to the top.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.raise');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_raise'] = (block, generator) => {


    return `OverlayWindow.raise();\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_close'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.close')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Closes the window.<p>Note: The window also closes when the script ends.</p>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.close');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_close'] = (block, generator) => {


    return `OverlayWindow.close();\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_sendToQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.sendToQml')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sends a message to the QML. To receive the message, the QML must implement a function:<pre class="prettyprint"><code>function fromScript(message) {  ...}</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.sendToQml');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_sendToQml'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWindow.sendToQml(${_message});\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_clearDebugWindow'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.clearDebugWindow')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Calls a <code>clearWindow()</code> function if present in the QML.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.clearDebugWindow');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_clearDebugWindow'] = (block, generator) => {


    return `OverlayWindow.clearDebugWindow();\n`;};


// Blockly function
Blockly.Blocks['OverlayWindow_emitScriptEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWindow.emitScriptEvent')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#8DB05D');
        this.setTooltip('Sends a message to an embedded HTML web page. To receive the message, the HTML page\'s script must connect to the<code>EventBridge</code> that is automatically provided for the script:<pre class="prettyprint"><code>EventBridge.scriptEventReceived.connect(function(message) {    ...});</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.emitScriptEvent');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_emitScriptEvent'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWindow.emitScriptEvent(${_message});\n`;};


// Blockly signal
Blockly.Blocks['OverlayWindow_visibleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.visibleChanged');


        this.setColour('#8DB05D');
        this.setTooltip('Triggered when the window is hidden or shown.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.visibleChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_visibleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWindow.visibleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_positionChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.positionChanged');


        this.setColour('#8DB05D');
        this.setTooltip('Triggered when the window changes position.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.positionChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_positionChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWindow.positionChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_sizeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.sizeChanged');


        this.setColour('#8DB05D');
        this.setTooltip('Triggered when the window changes size.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.sizeChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_sizeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWindow.sizeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_moved'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.moved');

        this.appendDummyInput('position')
            .appendField('position:')
            .appendField(new Blockly.FieldVariable('moved_position'), 'position');

        this.setColour('#8DB05D');
        this.setTooltip('Triggered when the window changes position.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.moved');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_moved'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const position = generator.getVariableName(block.getFieldValue('position'));

return `OverlayWindow.moved.connect((_position) => { 
  ${position} = _position;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_resized'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.resized');

        this.appendDummyInput('size')
            .appendField('size:')
            .appendField(new Blockly.FieldVariable('resized_size'), 'size');

        this.setColour('#8DB05D');
        this.setTooltip('Triggered when the window changes size.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.resized');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_resized'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const size = generator.getVariableName(block.getFieldValue('size'));

return `OverlayWindow.resized.connect((_size) => { 
  ${size} = _size;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_closed'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.closed');


        this.setColour('#8DB05D');
        this.setTooltip('Triggered when the window is closed.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.closed');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_closed'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWindow.closed.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_fromQml'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.fromQml');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('fromQml_message'), 'message');

        this.setColour('#8DB05D');
        this.setTooltip('Triggered when a message from the QML page is received. The QML page can send a message (string or object) by calling:<pre class="prettyprint"><code>sendToScript(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.fromQml');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_fromQml'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `OverlayWindow.fromQml.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWindow_webEventReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWindow.webEventReceived');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('webEventReceived_message'), 'message');

        this.setColour('#8DB05D');
        this.setTooltip('Triggered when a message from an embedded HTML page is received. The HTML page can send a message by calling:<pre class="prettyprint"><code>EventBridge.emitWebEvent(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWindow.html#.webEventReceived');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWindow_webEventReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `OverlayWindow.webEventReceived.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['TabletButtonProxy_ButtonProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletButtonProxy.ButtonProperties')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('uuid') 
            .setCheck('Uuid')
            .appendField('uuid');
        this.appendValueInput('objectName') 
            .setCheck('Uuid')
            .appendField('objectName');
        this.appendValueInput('stableOrder') 
            .setCheck('Number')
            .appendField('stableOrder');
        this.appendValueInput('icon') 
            .setCheck('String')
            .appendField('icon');
        this.appendValueInput('hoverIcon') 
            .setCheck('String')
            .appendField('hoverIcon');
        this.appendValueInput('activeIcon') 
            .setCheck('String')
            .appendField('activeIcon');
        this.appendValueInput('activeHoverIcon') 
            .setCheck('String')
            .appendField('activeHoverIcon');
        this.appendValueInput('text') 
            .setCheck('String')
            .appendField('text');
        this.appendValueInput('hoverText') 
            .setCheck('String')
            .appendField('hoverText');
        this.appendValueInput('activeText') 
            .setCheck('String')
            .appendField('activeText');
        this.appendValueInput('activeHoverText') 
            .setCheck('String')
            .appendField('activeHoverText');
        this.appendValueInput('captionColor') 
            .setCheck('String')
            .appendField('captionColor');
        this.appendValueInput('isActive') 
            .setCheck('Boolean')
            .appendField('isActive');
        this.appendValueInput('isEntered') 
            .setCheck('Boolean')
            .appendField('isEntered');
        this.appendValueInput('buttonEnabled') 
            .setCheck('Boolean')
            .appendField('buttonEnabled');
        this.appendValueInput('sortOrder') 
            .setCheck('Number')
            .appendField('sortOrder');
        this.appendValueInput('inDebugMode') 
            .setCheck('Boolean')
            .appendField('inDebugMode');
        this.appendValueInput('flickable') 
            .setCheck('object')
            .appendField('flickable');
        this.appendValueInput('gridView') 
            .setCheck('object')
            .appendField('gridView');
        this.appendValueInput('buttonIndex') 
            .setCheck('Number')
            .appendField('buttonIndex');
        this.setColour('#2225E0');
        this.setTooltip('Properties of a tablet button.');
        this.setHelpUrl('https://apidocs.overte.org/TabletButtonProxy.html#.ButtonProperties');
    }
};
javascript.javascriptGenerator.forBlock['TabletButtonProxy_ButtonProperties'] = (block, generator) => {
    const _uuid = dfv(generator.valueToCode(block, 'uuid', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _objectName = dfv(generator.valueToCode(block, 'objectName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _stableOrder = dfv(generator.valueToCode(block, 'stableOrder', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _icon = dfv(generator.valueToCode(block, 'icon', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hoverIcon = dfv(generator.valueToCode(block, 'hoverIcon', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _activeIcon = dfv(generator.valueToCode(block, 'activeIcon', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _activeHoverIcon = dfv(generator.valueToCode(block, 'activeHoverIcon', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _text = dfv(generator.valueToCode(block, 'text', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _hoverText = dfv(generator.valueToCode(block, 'hoverText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _activeText = dfv(generator.valueToCode(block, 'activeText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _activeHoverText = dfv(generator.valueToCode(block, 'activeHoverText', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _captionColor = dfv(generator.valueToCode(block, 'captionColor', javascript.javascriptGenerator.ORDER_ATOMIC), `"#ffffff"`);
    const _isActive = dfv(generator.valueToCode(block, 'isActive', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _isEntered = dfv(generator.valueToCode(block, 'isEntered', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _buttonEnabled = dfv(generator.valueToCode(block, 'buttonEnabled', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);
    const _sortOrder = dfv(generator.valueToCode(block, 'sortOrder', javascript.javascriptGenerator.ORDER_ATOMIC), `100`);
    const _inDebugMode = dfv(generator.valueToCode(block, 'inDebugMode', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _flickable = dfv(generator.valueToCode(block, 'flickable', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _gridView = dfv(generator.valueToCode(block, 'gridView', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _buttonIndex = dfv(generator.valueToCode(block, 'buttonIndex', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

    return [`new TabletButtonProxy.ButtonProperties(${_uuid},${_objectName},${_stableOrder},${_icon},${_hoverIcon},${_activeIcon},${_activeHoverIcon},${_text},${_hoverText},${_activeText},${_activeHoverText},${_captionColor},${_isActive},${_isEntered},${_buttonEnabled},${_sortOrder},${_inDebugMode},${_flickable},${_gridView},${_buttonIndex})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Tablet_AudioEvents'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Tablet.AudioEvents')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#36384A');
        this.setTooltip('<p>Standard tablet sounds.</p><table>  <thead>    <tr><th>Value</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td><code>0</code></td><td>Button click.</td></tr>    <tr><td><code>1</code></td><td>Button hover.</td></tr>    <tr><td><code>2</code></td><td>Tablet open.</td></tr>    <tr><td><code>3</code></td><td>Tablet hands in.</td></tr>    <tr><td><code>4</code></td><td>Tablet hands out.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Tablet.html#.AudioEvents');
    }
};
javascript.javascriptGenerator.forBlock['Tablet_AudioEvents'] = (block, generator) => {

    return [`new Tablet.AudioEvents()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['Tablet_getTablet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Tablet.getTablet')
        // Returns data
        this.setOutput(true, '["TabletProxy"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#36384A');
        this.setTooltip('Gets an instance of a tablet. A new tablet is created if one with the specified name doesn\'t already exist.');
        this.setHelpUrl('https://apidocs.overte.org/Tablet.html#.getTablet');
    }
};
javascript.javascriptGenerator.forBlock['Tablet_getTablet'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Tablet.getTablet(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Tablet_playSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Tablet.playSound')
        // Returns data

        // Params data
        this.appendValueInput('sound') 
            .setCheck('Tablet.AudioEvents')
            .appendField('sound');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#36384A');
        this.setTooltip('Plays a standard tablet sound. The sound is played locally (only the user running the script hears it) without a position.');
        this.setHelpUrl('https://apidocs.overte.org/Tablet.html#.playSound');
    }
};
javascript.javascriptGenerator.forBlock['Tablet_playSound'] = (block, generator) => {
    const _sound = dfv(generator.valueToCode(block, 'sound', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `Tablet.playSound(${_sound});\n`;};


// Blockly signal
Blockly.Blocks['Tablet_tabletNotification'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Tablet.tabletNotification');


        this.setColour('#36384A');
        this.setTooltip('Triggered when a tablet message or dialog is displayed on the tablet that needs the user\'s attention.<p><strong>Note:</strong> Only triggered if the script is running in the same script engine as the script that created the tablet. By default, this means in scripts included as part of the default scripts.</p>');
        this.setHelpUrl('https://apidocs.overte.org/Tablet.html#.tabletNotification');
    }
};
javascript.javascriptGenerator.forBlock['Tablet_tabletNotification'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Tablet.tabletNotification.connect(() => {
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['TabletProxy_TabletButtonListModel'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy.TabletButtonListModel')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#969104');
        this.setTooltip('Information on the buttons in the tablet main menu (toolbar in toolbar mode) for use in QML. Has properties and functions per <a href="http://doc.qt.io/qt-5/qabstractlistmodel.html">http://doc.qt.io/qt-5/qabstractlistmodel.html</a>.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy.html#.TabletButtonListModel');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy_TabletButtonListModel'] = (block, generator) => {

    return [`new TabletProxy.TabletButtonListModel()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly class
Blockly.Blocks['TabletProxy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('toolbarMode') 
            .setCheck('Boolean')
            .appendField('toolbarMode');
        this.appendValueInput('landscape') 
            .setCheck('Boolean')
            .appendField('landscape');
        this.appendValueInput('tabletShown') 
            .setCheck('Boolean')
            .appendField('tabletShown');
        this.appendValueInput('buttons') 
            .setCheck('TabletProxy.TabletButtonListModel')
            .appendField('buttons');
        this.setColour('#969104');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>An instance of a tablet. In toolbar mode (see Developer &gt; UI options), the tablet\'s menu buttons are displayed in a toolbar and other tablet content is displayed in a dialog.<p>Retrieve an existing tablet or create a new tablet using {@link Tablet.getTablet}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _toolbarMode = dfv(generator.valueToCode(block, 'toolbarMode', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _landscape = dfv(generator.valueToCode(block, 'landscape', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _tabletShown = dfv(generator.valueToCode(block, 'tabletShown', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);
    const _buttons = dfv(generator.valueToCode(block, 'buttons', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new TabletProxy(${_name},${_toolbarMode},${_landscape},${_tabletShown},${_buttons})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['TabletProxy#gotoMenuScreen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#gotoMenuScreen')
        // Returns data

        // Params data
        this.appendValueInput('submenu') 
            .setCheck('String')
            .appendField('submenu');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Displays the tablet menu. The tablet is opened if it isn\'t already open.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#gotoMenuScreen');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#gotoMenuScreen'] = (block, generator) => {
    const _submenu = dfv(generator.valueToCode(block, 'submenu', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `TabletProxy#gotoMenuScreen(${_submenu});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#gotoHomeScreen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#gotoHomeScreen')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Displays the tablet home screen, if the tablet is open.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#gotoHomeScreen');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#gotoHomeScreen'] = (block, generator) => {


    return `TabletProxy#gotoHomeScreen();\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#gotoWebScreen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#gotoWebScreen')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');
        this.appendValueInput('injectedJavaScriptUrl') 
            .setCheck('String')
            .appendField('injectedJavaScriptUrl');
        this.appendValueInput('loadOtherBase') 
            .setCheck('Boolean')
            .appendField('loadOtherBase');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Opens a web app or page in addition to any current app. In tablet mode, the app or page is displayed over the top of thecurrent app; in toolbar mode, the app is opened in a new window that replaces any current window open. If in tabletmode, the app or page can be closed using {@link TabletProxy#returnToPreviousApp}.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#gotoWebScreen');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#gotoWebScreen'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _injectedJavaScriptUrl = dfv(generator.valueToCode(block, 'injectedJavaScriptUrl', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _loadOtherBase = dfv(generator.valueToCode(block, 'loadOtherBase', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `TabletProxy#gotoWebScreen(${_url},${_injectedJavaScriptUrl},${_loadOtherBase});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#loadQMLSource'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#loadQMLSource')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('resizable') 
            .setCheck('Boolean')
            .appendField('resizable');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Opens a QML app or dialog on the tablet.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#loadQMLSource');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#loadQMLSource'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _resizable = dfv(generator.valueToCode(block, 'resizable', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `TabletProxy#loadQMLSource(${_path},${_resizable});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#pushOntoStack'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#pushOntoStack')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setColour('#969104');
        this.setTooltip('Displays a QML dialog over the top of the current dialog, without closing the current dialog. Use {@link TabletProxy#popFromStack|popFromStack} to close the dialog.<p>If the current dialog or its ancestors contain a QML <code>StackView</code> with <code>objectName: "stack"</code> and function <code>pushSource(path)</code>, that function is called; otherwise, {@link TabletProxy#loadQMLSource|loadQMLSource} is called. The Create app provides an example of using a QML <code>StackView</code>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#pushOntoStack');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#pushOntoStack'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`TabletProxy#pushOntoStack(${_path})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TabletProxy#popFromStack'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#popFromStack')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Closes a QML dialog that was displayed using {@link Tablet#pushOntoStack|pushOntoStack} with a dialog implementing a QML <code>StackView</code>; otherwise, no action is taken.<p>If using a QML <code>StackView</code>, its <code>popSource()</code> function is called.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#popFromStack');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#popFromStack'] = (block, generator) => {


    return `TabletProxy#popFromStack();\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#loadQMLOnTop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#loadQMLOnTop')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Opens a QML app or dialog in addition to any current app. In tablet mode, the app or dialog is displayed over the top of the current app; in toolbar mode, the app or dialog is opened in a new window. If in tablet mode, the app can be closed using {@link TabletProxy#returnToPreviousApp}.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#loadQMLOnTop');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#loadQMLOnTop'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `TabletProxy#loadQMLOnTop(${_path});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#loadWebScreenOnTop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#loadWebScreenOnTop')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('injectedJavaScriptURL') 
            .setCheck('String')
            .appendField('injectedJavaScriptURL');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Opens a web app or page in addition to any current app. In tablet mode, the app or page is displayed over the top of thecurrent app; in toolbar mode, the app is opened in a new window that replaces any current window open. If in tablet mode, the app or page can be closed using {@link TabletProxy#returnToPreviousApp}.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#loadWebScreenOnTop');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#loadWebScreenOnTop'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _injectedJavaScriptURL = dfv(generator.valueToCode(block, 'injectedJavaScriptURL', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);


    return `TabletProxy#loadWebScreenOnTop(${_path},${_injectedJavaScriptURL});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#returnToPreviousApp'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#returnToPreviousApp')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Closes the current app and returns to the previous app, if in tablet mode and the current app was loaded using {@link TabletProxy#loadQMLOnTop|loadQMLOnTop} or {@link TabletProxy#loadWebScreenOnTop|loadWebScreenOnTop}.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#returnToPreviousApp');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#returnToPreviousApp'] = (block, generator) => {


    return `TabletProxy#returnToPreviousApp();\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#isMessageDialogOpen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#isMessageDialogOpen')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#969104');
        this.setTooltip('Checks if the tablet has a modal, non-modal, or message dialog open.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#isMessageDialogOpen');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#isMessageDialogOpen'] = (block, generator) => {

return [`TabletProxy#isMessageDialogOpen()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TabletProxy#closeDialog'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#closeDialog')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Closes any open modal, non-modal, or message dialog, opened by {@link Window.prompt}, {@link Window.promptAsync}, {@link Window.openMessageBox}, or similar.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#closeDialog');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#closeDialog'] = (block, generator) => {


    return `TabletProxy#closeDialog();\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#addButton'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#addButton')
        // Returns data
        this.setOutput(true, '["TabletButtonProxy"]');

        // Params data
        this.appendValueInput('properties') 
            .setCheck('TabletButtonProxy.ButtonProperties')
            .appendField('properties');

        this.setColour('#969104');
        this.setTooltip('Adds a new button to the tablet menu.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#addButton');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#addButton'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`TabletProxy#addButton(${_properties})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TabletProxy#removeButton'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#removeButton')
        // Returns data

        // Params data
        this.appendValueInput('button') 
            .setCheck('TabletButtonProxy')
            .appendField('button');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Removes a button from the tablet menu.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#removeButton');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#removeButton'] = (block, generator) => {
    const _button = dfv(generator.valueToCode(block, 'button', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `TabletProxy#removeButton(${_button});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#emitScriptEvent'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#emitScriptEvent')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Sends a message to the current web page. To receive the message, the web page\'s script must connect to the<code>EventBridge</code> that is automatically provided to the script:<pre class="prettyprint"><code>EventBridge.scriptEventReceived.connect(function(message) {    ...});</code></pre><p><strong>Warning:</strong> The <code>EventBridge</code> object is not necessarily set up immediately ready for the web page\'s script to use. A simple workaround that normally works is to add a delay before calling <code>EventBridge.scriptEventReceived.connect(...)</code>. A better solution is to periodically call <code>EventBridge.scriptEventReceived.connect(...)</code> and then <code>EventBridge.emitWebEvent(...)</code> to send a message to the Interface script, and have that send a message back using <code>emitScriptEvent(...)</code>; when the return message is received, the <codE>EventBridge</code> is ready for use.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#emitScriptEvent');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#emitScriptEvent'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `TabletProxy#emitScriptEvent(${_message});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#sendToQml'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#sendToQml')
        // Returns data

        // Params data
        this.appendValueInput('message') 
            .setCheck('String')
            .appendField('message');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Sends a message to the current QML page. To receive the message, the QML page must implement a function:<pre class="prettyprint"><code>function fromScript(message) {  ...}</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#sendToQml');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#sendToQml'] = (block, generator) => {
    const _message = dfv(generator.valueToCode(block, 'message', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `TabletProxy#sendToQml(${_message});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#onHomeScreen'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#onHomeScreen')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#969104');
        this.setTooltip('Checks if the tablet is on the home screen.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#onHomeScreen');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#onHomeScreen'] = (block, generator) => {

return [`TabletProxy#onHomeScreen()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TabletProxy#setLandscape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#setLandscape')
        // Returns data

        // Params data
        this.appendValueInput('landscape') 
            .setCheck('Boolean')
            .appendField('landscape');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#969104');
        this.setTooltip('Sets whether the tablet is displayed in landscape or portrait mode.<p>Note: The setting isn\'t used in toolbar mode.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#setLandscape');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#setLandscape'] = (block, generator) => {
    const _landscape = dfv(generator.valueToCode(block, 'landscape', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `TabletProxy#setLandscape(${_landscape});\n`;};


// Blockly function
Blockly.Blocks['TabletProxy#getLandscape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#getLandscape')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#969104');
        this.setTooltip('Gets whether the tablet is displayed in landscape or portrait mode.<p>Note: The setting isn\'t used in toolbar mode.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#getLandscape');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#getLandscape'] = (block, generator) => {

return [`TabletProxy#getLandscape()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TabletProxy#isPathLoaded'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletProxy#isPathLoaded')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');

        this.setColour('#969104');
        this.setTooltip('Checks if a path is the current app or dialog displayed.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#isPathLoaded');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#isPathLoaded'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`TabletProxy#isPathLoaded(${_path})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['TabletProxy#webEventReceived'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletProxy#webEventReceived');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('webEventReceived_message'), 'message');

        this.setColour('#969104');
        this.setTooltip('Triggered when a message from the current HTML web page displayed on the tablet is received. The HTML web page can send a message by calling:<pre class="prettyprint"><code>EventBridge.emitWebEvent(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#webEventReceived');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#webEventReceived'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `TabletProxy#webEventReceived.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['TabletProxy#fromQml'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletProxy#fromQml');

        this.appendDummyInput('message')
            .appendField('message:')
            .appendField(new Blockly.FieldVariable('fromQml_message'), 'message');

        this.setColour('#969104');
        this.setTooltip('Triggered when a message from the current QML page displayed on the tablet is received. The QML page can send a message (string or object) by calling: <pre class="prettyprint"><code>sendToScript(message);</code></pre>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#fromQml');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#fromQml'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const message = generator.getVariableName(block.getFieldValue('message'));

return `TabletProxy#fromQml.connect((_message) => { 
  ${message} = _message;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['TabletProxy#screenChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletProxy#screenChanged');

        this.appendDummyInput('type')
            .appendField('type:')
            .appendField(new Blockly.FieldVariable('screenChanged_type'), 'type');
        this.appendDummyInput('url')
            .appendField('url:')
            .appendField(new Blockly.FieldVariable('screenChanged_url'), 'url');

        this.setColour('#969104');
        this.setTooltip('Triggered when the tablet\'s screen changes.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#screenChanged');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#screenChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const type = generator.getVariableName(block.getFieldValue('type'));
    const url = generator.getVariableName(block.getFieldValue('url'));

return `TabletProxy#screenChanged.connect((_type,_url) => { 
  ${type} = _type; 
  ${url} = _url;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['TabletProxy#tabletShownChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletProxy#tabletShownChanged');


        this.setColour('#969104');
        this.setTooltip('Triggered when the tablet is opened or closed.<p>Note: Doesn\'t apply in toolbar mode.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#tabletShownChanged');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#tabletShownChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `TabletProxy#tabletShownChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['TabletProxy#toolbarModeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletProxy#toolbarModeChanged');


        this.setColour('#969104');
        this.setTooltip('Triggered when the tablet\'s toolbar mode changes.');
        this.setHelpUrl('https://apidocs.overte.org/TabletProxy#toolbarModeChanged');
    }
};
javascript.javascriptGenerator.forBlock['TabletProxy#toolbarModeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `TabletProxy#toolbarModeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly class
Blockly.Blocks['TabletButtonProxy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletButtonProxy')       
        this.setOutput(true, '');
        // Params data
        this.appendValueInput('uuid') 
            .setCheck('Uuid')
            .appendField('uuid');
        this.appendValueInput('properties') 
            .setCheck('TabletButtonProxy.ButtonProperties')
            .appendField('properties');
        this.setColour('#2225E0');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>A tablet button. In toolbar mode (Developer &gt; UI &gt; Tablet Becomes Toolbar), the tablet button is displayed on the toolbar.<p>Create a new button using {@link TabletProxy#addButton}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/TabletButtonProxy');
    }
};
javascript.javascriptGenerator.forBlock['TabletButtonProxy'] = (block, generator) => {
    const _uuid = dfv(generator.valueToCode(block, 'uuid', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

    return [`new TabletButtonProxy(${_uuid},${_properties})`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['TabletButtonProxy#getProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletButtonProxy#getProperties')
        // Returns data
        this.setOutput(true, '["TabletButtonProxy.ButtonProperties"]');

        // Params data

        this.setColour('#2225E0');
        this.setTooltip('Gets the current values of the button\'s properties. Only properties that have been set during button creation or subsequently edited are returned.');
        this.setHelpUrl('https://apidocs.overte.org/TabletButtonProxy#getProperties');
    }
};
javascript.javascriptGenerator.forBlock['TabletButtonProxy#getProperties'] = (block, generator) => {

return [`TabletButtonProxy#getProperties()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TabletButtonProxy#editProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TabletButtonProxy#editProperties')
        // Returns data

        // Params data
        this.appendValueInput('properties') 
            .setCheck('TabletButtonProxy.ButtonProperties')
            .appendField('properties');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#2225E0');
        this.setTooltip('Changes the values of the button\'s properties.');
        this.setHelpUrl('https://apidocs.overte.org/TabletButtonProxy#editProperties');
    }
};
javascript.javascriptGenerator.forBlock['TabletButtonProxy#editProperties'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `TabletButtonProxy#editProperties(${_properties});\n`;};


// Blockly signal
Blockly.Blocks['TabletButtonProxy#clicked'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletButtonProxy#clicked');


        this.setColour('#2225E0');
        this.setTooltip('Triggered when the button is clicked.');
        this.setHelpUrl('https://apidocs.overte.org/TabletButtonProxy#clicked');
    }
};
javascript.javascriptGenerator.forBlock['TabletButtonProxy#clicked'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `TabletButtonProxy#clicked.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['TabletButtonProxy#propertiesChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TabletButtonProxy#propertiesChanged');


        this.setColour('#2225E0');
        this.setTooltip('Triggered when a button\'s properties are changed.');
        this.setHelpUrl('https://apidocs.overte.org/TabletButtonProxy#propertiesChanged');
    }
};
javascript.javascriptGenerator.forBlock['TabletButtonProxy#propertiesChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `TabletButtonProxy#propertiesChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly class
Blockly.Blocks['ToolbarProxy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ToolbarProxy')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#83F6CE');
        this.setTooltip('<p class=\'availableIn\'><b>Supported Script Types:</b> Interface Scripts &bull; Client Entity Scripts &bull; Avatar Scripts</p>An instance of a toolbar.<p>Retrieve an existing toolbar or create a new toolbar using {@link Toolbars.getToolbar}.</p>');
        this.setHelpUrl('https://apidocs.overte.org/ToolbarProxy');
    }
};
javascript.javascriptGenerator.forBlock['ToolbarProxy'] = (block, generator) => {

    return [`new ToolbarProxy()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['ToolbarProxy#writeProperty'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ToolbarProxy#writeProperty')
        // Returns data

        // Params data
        this.appendValueInput('propertyValue') 
            .setCheck('object')
            .appendField('propertyValue');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#83F6CE');
        this.setTooltip('Sets the value of a toolbar property. A property is added to the toolbar if the named property doesn\'t already exist.');
        this.setHelpUrl('https://apidocs.overte.org/ToolbarProxy#writeProperty');
    }
};
javascript.javascriptGenerator.forBlock['ToolbarProxy#writeProperty'] = (block, generator) => {
    const _propertyValue = dfv(generator.valueToCode(block, 'propertyValue', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `ToolbarProxy#writeProperty(${_propertyValue});\n`;};


// Blockly function
Blockly.Blocks['ToolbarProxy#writeProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ToolbarProxy#writeProperties')
        // Returns data

        // Params data
        this.appendValueInput('properties') 
            .setCheck('object')
            .appendField('properties');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#83F6CE');
        this.setTooltip('Sets the values of toolbar properties. A property is added to the toolbar if a named property doesn\'t alreadyexist.');
        this.setHelpUrl('https://apidocs.overte.org/ToolbarProxy#writeProperties');
    }
};
javascript.javascriptGenerator.forBlock['ToolbarProxy#writeProperties'] = (block, generator) => {
    const _properties = dfv(generator.valueToCode(block, 'properties', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `ToolbarProxy#writeProperties(${_properties});\n`;};


// Blockly function
Blockly.Blocks['ToolbarProxy#readProperty'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ToolbarProxy#readProperty')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('propertyName') 
            .setCheck('String')
            .appendField('propertyName');

        this.setColour('#83F6CE');
        this.setTooltip('Gets the value of a toolbar property.');
        this.setHelpUrl('https://apidocs.overte.org/ToolbarProxy#readProperty');
    }
};
javascript.javascriptGenerator.forBlock['ToolbarProxy#readProperty'] = (block, generator) => {
    const _propertyName = dfv(generator.valueToCode(block, 'propertyName', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ToolbarProxy#readProperty(${_propertyName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ToolbarProxy#readProperties'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ToolbarProxy#readProperties')
        // Returns data
        this.setOutput(true, '["object"]');

        // Params data
        this.appendValueInput('propertyList') 
            .setCheck('Array')
            .appendField('propertyList');

        this.setColour('#83F6CE');
        this.setTooltip('Gets the values of toolbar properties.');
        this.setHelpUrl('https://apidocs.overte.org/ToolbarProxy#readProperties');
    }
};
javascript.javascriptGenerator.forBlock['ToolbarProxy#readProperties'] = (block, generator) => {
    const _propertyList = dfv(generator.valueToCode(block, 'propertyList', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ToolbarProxy#readProperties(${_propertyList})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Toolbars_getToolbar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Toolbars.getToolbar')
        // Returns data
        this.setOutput(true, '["ToolbarProxy"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#522CE8');
        this.setTooltip('Gets an instance of a toolbar. A new toolbar is created if one with the specified name doesn\'t already exist.');
        this.setHelpUrl('https://apidocs.overte.org/Toolbars.html#.getToolbar');
    }
};
javascript.javascriptGenerator.forBlock['Toolbars_getToolbar'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`Toolbars.getToolbar(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['Toolbars_toolbarVisibleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Toolbars.toolbarVisibleChanged');

        this.appendDummyInput('isVisible')
            .appendField('isVisible:')
            .appendField(new Blockly.FieldVariable('toolbarVisibleChanged_isVisible'), 'isVisible');
        this.appendDummyInput('toolbarName')
            .appendField('toolbarName:')
            .appendField(new Blockly.FieldVariable('toolbarVisibleChanged_toolbarName'), 'toolbarName');

        this.setColour('#522CE8');
        this.setTooltip('Triggered when the visibility of a toolbar changes.');
        this.setHelpUrl('https://apidocs.overte.org/Toolbars.html#.toolbarVisibleChanged');
    }
};
javascript.javascriptGenerator.forBlock['Toolbars_toolbarVisibleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isVisible = generator.getVariableName(block.getFieldValue('isVisible'));
    const toolbarName = generator.getVariableName(block.getFieldValue('toolbarName'));

return `Toolbars.toolbarVisibleChanged.connect((_isVisible,_toolbarName) => { 
  ${isVisible} = _isVisible; 
  ${toolbarName} = _toolbarName;
${innerCode}
});\n`;};

// Blockly typedef
Blockly.Blocks['Controller_Hardware-OculusTouch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hardware-OculusTouch')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Hardware.OculusTouch</code> object has properties representing the Oculus Rift. The property values are integer IDs, uniquely identifying each output. <em>Read-only.</em></p><p>These outputs can be mapped to actions or functions or <code>Controller.Standard</code> items in a {@link RouteObject} mapping.</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Data</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td colspan="4"><strong>Buttons</strong></td></tr>    <tr><td><code>A</code></td><td>number</td><td>number</td><td>"A" button pressed.</td></tr>    <tr><td><code>B</code></td><td>number</td><td>number</td><td>"B" button pressed.</td></tr>    <tr><td><code>X</code></td><td>number</td><td>number</td><td>"X" button pressed.</td></tr>    <tr><td><code>Y</code></td><td>number</td><td>number</td><td>"Y" button pressed.</td></tr>    <tr><td><code>LeftApplicationMenu</code></td><td>number</td><td>number</td><td>Left application menu button pressed.      </td></tr>    <tr><td><code>RightApplicationMenu</code></td><td>number</td><td>number</td><td>Right application menu button pressed.      </td></tr>    <tr><td colspan="4"><strong>Sticks</strong></td></tr>    <tr><td><code>LX</code></td><td>number</td><td>number</td><td>Left stick x-axis scale.</td></tr>    <tr><td><code>LY</code></td><td>number</td><td>number</td><td>Left stick y-axis scale.</td></tr>    <tr><td><code>RX</code></td><td>number</td><td>number</td><td>Right stick x-axis scale.</td></tr>    <tr><td><code>RY</code></td><td>number</td><td>number</td><td>Right stick y-axis scale.</td></tr>    <tr><td><code>LS</code></td><td>number</td><td>number</td><td>Left stick button pressed.</td></tr>    <tr><td><code>RS</code></td><td>number</td><td>number</td><td>Right stick button pressed.</td></tr>    <tr><td><code>LSTouch</code></td><td>number</td><td>number</td><td>Left stick is touched.</td></tr>    <tr><td><code>RSTouch</code></td><td>number</td><td>number</td><td>Right stick is touched.</td></tr>    <tr><td colspan="4"><strong>Triggers</strong></td></tr>    <tr><td><code>LT</code></td><td>number</td><td>number</td><td>Left trigger scale.</td></tr>    <tr><td><code>RT</code></td><td>number</td><td>number</td><td>Right trigger scale.</td></tr>    <tr><td><code>LeftGrip</code></td><td>number</td><td>number</td><td>Left grip scale.</td></tr>    <tr><td><code>RightGrip</code></td><td>number</td><td>number</td><td>Right grip scale.</td></tr>    <tr><td colspan="4"><strong>Finger Abstractions</strong></td></tr>    <tr><td><code>LeftPrimaryThumbTouch</code></td><td>number</td><td>number</td><td>Left thumb touching primary thumb       button.</td></tr>    <tr><td><code>LeftSecondaryThumbTouch</code></td><td>number</td><td>number</td><td>Left thumb touching secondary thumb       button.</td></tr>    <tr><td><code>LeftThumbUp</code></td><td>number</td><td>number</td><td>Left thumb not touching primary or secondary       thumb buttons.</td></tr>    <tr><td><code>RightPrimaryThumbTouch</code></td><td>number</td><td>number</td><td>Right thumb touching primary thumb       button.</td></tr>    <tr><td><code>RightSecondaryThumbTouch</code></td><td>number</td><td>number</td><td>Right thumb touching secondary thumb       button.</td></tr>    <tr><td><code>RightThumbUp</code></td><td>number</td><td>number</td><td>Right thumb not touching primary or secondary       thumb buttons.</td></tr>    <tr><td><code>LeftPrimaryIndexTouch</code></td><td>number</td><td>number</td><td>Left index finger is touching primary       index finger control.</td></tr>    <tr><td><code>LeftIndexPoint</code></td><td>number</td><td>number</td><td>Left index finger is pointing, not touching       primary or secondary index finger controls.</td></tr>    <tr><td><code>RightPrimaryIndexTouch</code></td><td>number</td><td>number</td><td>Right index finger is touching primary       index finger control.</td></tr>    <tr><td><code>RightIndexPoint</code></td><td>number</td><td>number</td><td>Right index finger is pointing, not touching       primary or secondary index finger controls.</td></tr>    <tr><td colspan="4"><strong>Avatar Skeleton</strong></td></tr>    <tr><td><code>Head</code></td><td>number</td><td>{@link Pose}</td><td>Head pose.</td></tr>    <tr><td><code>LeftHand</code></td><td>number</td><td>{@link Pose}</td><td>Left hand pose.</td></tr>    <tr><td><code>RightHand</code></td><td>number</td><td>{@link Pose}</td><td>right hand pose.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hardware-OculusTouch');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hardware-OculusTouch'] = (block, generator) => {

    return [`new Controller.Hardware-OculusTouch()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly typedef
Blockly.Blocks['Controller_Hardware-Vive'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Controller.Hardware-Vive')       
        this.setOutput(true, '');
        // Params data
        this.setColour('#9BBF37');
        this.setTooltip('<p>The <code>Controller.Hardware.Vive</code> object has properties representing the Vive. The property values are integer IDs, uniquely identifying each output. <em>Read-only.</em></p><p>These outputs can be mapped to actions or functions or <code>Controller.Standard</code> items in a {@link RouteObject} mapping.</p><table>  <thead>    <tr><th>Property</th><th>Type</th><th>Data</th><th>Description</th></tr>  </thead>  <tbody>    <tr><td colspan="4"><strong>Buttons</strong></td></tr>    <tr><td><code>LeftApplicationMenu</code></td><td>number</td><td>number</td><td>Left application menu button pressed.      </td></tr>    <tr><td><code>RightApplicationMenu</code></td><td>number</td><td>number</td><td>Right application menu button pressed.      </td></tr>    <tr><td colspan="4"><strong>Touch Pad (Sticks)</strong></td></tr>    <tr><td><code>LX</code></td><td>number</td><td>number</td><td>Left touch pad x-axis scale.</td></tr>    <tr><td><code>LY</code></td><td>number</td><td>number</td><td>Left touch pad y-axis scale.</td></tr>    <tr><td><code>RX</code></td><td>number</td><td>number</td><td>Right stick x-axis scale.</td></tr>    <tr><td><code>RY</code></td><td>number</td><td>number</td><td>Right stick y-axis scale.</td></tr>    <tr><td><code>LS</code></td><td>number</td><td>number</td><td>Left touch pad pressed.</td></tr>    <tr><td><code>LSCenter</code></td><td>number</td><td>number</td><td>Left touch pad center pressed.</td></tr>    <tr><td><code>LSX</code></td><td>number</td><td>number</td><td>Left touch pad pressed x-coordinate.</td></tr>    <tr><td><code>LSY</code></td><td>number</td><td>number</td><td>Left touch pad pressed y-coordinate.</td></tr>    <tr><td><code>RS</code></td><td>number</td><td>number</td><td>Right touch pad pressed.</td></tr>    <tr><td><code>RSCenter</code></td><td>number</td><td>number</td><td>Right touch pad center pressed.</td></tr>    <tr><td><code>RSX</code></td><td>number</td><td>number</td><td>Right touch pad pressed x-coordinate.</td></tr>    <tr><td><code>RSY</code></td><td>number</td><td>number</td><td>Right touch pad pressed y-coordinate.</td></tr>    <tr><td><code>LSTouch</code></td><td>number</td><td>number</td><td>Left touch pad is touched.</td></tr>    <tr><td><code>RSTouch</code></td><td>number</td><td>number</td><td>Right touch pad is touched.</td></tr>    <tr><td colspan="4"><strong>Triggers</strong></td></tr>    <tr><td><code>LT</code></td><td>number</td><td>number</td><td>Left trigger scale.</td></tr>    <tr><td><code>RT</code></td><td>number</td><td>number</td><td>Right trigger scale.</td></tr>    <tr><td><code>LTClick</code></td><td>number</td><td>number</td><td>Left trigger click.</td></tr>    <tr><td><code>RTClick</code></td><td>number</td><td>number</td><td>Right trigger click.</td></tr>    <tr><td><code>LeftGrip</code></td><td>number</td><td>number</td><td>Left grip scale.</td></tr>    <tr><td><code>RightGrip</code></td><td>number</td><td>number</td><td>Right grip scale.</td></tr>    <tr><td colspan="4"><strong>Avatar Skeleton</strong></td></tr>    <tr><td><code>Hips</code></td><td>number</td><td>{@link Pose}</td><td>Hips pose.</td></tr>    <tr><td><code>Spine2</code></td><td>number</td><td>{@link Pose}</td><td>Spine2 pose.</td></tr>    <tr><td><code>Head</code></td><td>number</td><td>{@link Pose}</td><td>Head pose.</td></tr>    <tr><td><code>LeftEye</code></td><td>number</td><td>{@link Pose}</td><td>Left eye pose.</td></tr>    <tr><td><code>RightEye</code></td><td>number</td><td>{@link Pose}</td><td>Right eye pose.</td></tr>    <tr><td><code>EyeBlink_L</code></td><td>number</td><td>number</td><td>Left eyelid blink.</td></tr>    <tr><td><code>EyeBlink_R</code></td><td>number</td><td>number</td><td>Right eyelid blink.</td></tr>    <tr><td><code>LeftArm</code></td><td>number</td><td>{@link Pose}</td><td>Left arm pose.</td></tr>    <tr><td><code>RightArm</code></td><td>number</td><td>{@link Pose}</td><td>Right arm pose</td></tr>    <tr><td><code>LeftHand</code></td><td>number</td><td>{@link Pose}</td><td>Left hand pose.</td></tr>    <tr><td><code>LeftHandThumb1</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandThumb2</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandThumb3</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandThumb4</code></td><td>number</td><td>{@link Pose}</td><td>Left thumb 4 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex1</code></td><td>number</td><td>{@link Pose}</td><td>Left index 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex2</code></td><td>number</td><td>{@link Pose}</td><td>Left index 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex3</code></td><td>number</td><td>{@link Pose}</td><td>Left index 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandIndex4</code></td><td>number</td><td>{@link Pose}</td><td>Left index 4 finger joint pose.</td></tr>    <tr><td><code>LeftHandMiddle1</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 1 finger joint pose.      </td></tr>    <tr><td><code>LeftHandMiddle2</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 2 finger joint pose.      </td></tr>    <tr><td><code>LeftHandMiddle3</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 3 finger joint pose.      </td></tr>    <tr><td><code>LeftHandMiddle4</code></td><td>number</td><td>{@link Pose}</td><td>Left middle 4 finger joint pose.      </td></tr>    <tr><td><code>LeftHandRing1</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandRing2</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandRing3</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandRing4</code></td><td>number</td><td>{@link Pose}</td><td>Left ring 4 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky1</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 1 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky2</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 2 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky3</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 3 finger joint pose.</td></tr>    <tr><td><code>LeftHandPinky4</code></td><td>number</td><td>{@link Pose}</td><td>Left pinky 4 finger joint pose.</td></tr>    <tr><td><code>RightHand</code></td><td>number</td><td>{@link Pose}</td><td>Right hand pose.</td></tr>    <tr><td><code>RightHandThumb1</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandThumb2</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandThumb3</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandThumb4</code></td><td>number</td><td>{@link Pose}</td><td>Right thumb 4 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex1</code></td><td>number</td><td>{@link Pose}</td><td>Right index 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex2</code></td><td>number</td><td>{@link Pose}</td><td>Right index 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex3</code></td><td>number</td><td>{@link Pose}</td><td>Right index 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandIndex4</code></td><td>number</td><td>{@link Pose}</td><td>Right index 4 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle1</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle2</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle3</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandMiddle4</code></td><td>number</td><td>{@link Pose}</td><td>Right middle 4 finger joint pose.      </td></tr>    <tr><td><code>RightHandRing1</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 1 finger joint pose.</td></tr>    <tr><td><code>RightHandRing2</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 2 finger joint pose.</td></tr>    <tr><td><code>RightHandRing3</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 3 finger joint pose.</td></tr>    <tr><td><code>RightHandRing4</code></td><td>number</td><td>{@link Pose}</td><td>Right ring 4 finger joint pose.</td></tr>    <tr><td><code>RightHandPinky1</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 1 finger joint pose.      </td></tr>    <tr><td><code>RightHandPinky2</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 2 finger joint pose.      </td></tr>    <tr><td><code>RightHandPinky3</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 3 finger joint pose.      </td></tr>    <tr><td><code>RightHandPinky4</code></td><td>number</td><td>{@link Pose}</td><td>Right pinky 4 finger joint pose.      </td></tr>    <tr><td colspan="4"><strong>Trackers</strong></td></tr>    <tr><td><code>TrackedObject00</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 0 pose.</td></tr>    <tr><td><code>TrackedObject01</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 1 pose.</td></tr>    <tr><td><code>TrackedObject02</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 2 pose.</td></tr>    <tr><td><code>TrackedObject03</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 3 pose.</td></tr>    <tr><td><code>TrackedObject04</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 4 pose.</td></tr>    <tr><td><code>TrackedObject05</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 5 pose.</td></tr>    <tr><td><code>TrackedObject06</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 6 pose.</td></tr>    <tr><td><code>TrackedObject07</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 7 pose.</td></tr>    <tr><td><code>TrackedObject08</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 8 pose.</td></tr>    <tr><td><code>TrackedObject09</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 9 pose.</td></tr>    <tr><td><code>TrackedObject10</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 10 pose.</td></tr>    <tr><td><code>TrackedObject11</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 11 pose.</td></tr>    <tr><td><code>TrackedObject12</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 12 pose.</td></tr>    <tr><td><code>TrackedObject13</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 13 pose.</td></tr>    <tr><td><code>TrackedObject14</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 14 pose.</td></tr>    <tr><td><code>TrackedObject15</code></td><td>number</td><td>{@link Pose}</td><td>Tracker 15 pose.</td></tr>  </tbody></table>');
        this.setHelpUrl('https://apidocs.overte.org/Controller.html#.Hardware-Vive');
    }
};
javascript.javascriptGenerator.forBlock['Controller_Hardware-Vive'] = (block, generator) => {

    return [`new Controller.Hardware-Vive()`, javascript.javascriptGenerator.ORDER_NONE];

};
// Blockly function
Blockly.Blocks['HifiAbout_openUrl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('HifiAbout.openUrl')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#7D4E40');
        this.setTooltip('Display a web page in an Interface browser window or the tablet.');
        this.setHelpUrl('https://apidocs.overte.org/HifiAbout.html#.openUrl');
    }
};
javascript.javascriptGenerator.forBlock['HifiAbout_openUrl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `HifiAbout.openUrl(${_url});\n`;};


// Blockly function
Blockly.Blocks['AvatarManager_getAvatar'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.getAvatar')
        // Returns data
        this.setOutput(true, '["ScriptAvatar"]');

        // Params data
        this.appendValueInput('avatarID') 
            .setCheck('Uuid')
            .appendField('avatarID');

        this.setColour('#956F41');
        this.setTooltip('Gets information about an avatar.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.getAvatar');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_getAvatar'] = (block, generator) => {
    const _avatarID = dfv(generator.valueToCode(block, 'avatarID', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AvatarManager.getAvatar(${_avatarID})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['AvatarManager_avatarAddedEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarManager.avatarAddedEvent');

        this.appendDummyInput('sessionUUID')
            .appendField('sessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarAddedEvent_sessionUUID'), 'sessionUUID');

        this.setColour('#956F41');
        this.setTooltip('Triggered when an avatar arrives in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.avatarAddedEvent');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_avatarAddedEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sessionUUID = generator.getVariableName(block.getFieldValue('sessionUUID'));

return `AvatarManager.avatarAddedEvent.connect((_sessionUUID) => { 
  ${sessionUUID} = _sessionUUID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarManager_avatarRemovedEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarManager.avatarRemovedEvent');

        this.appendDummyInput('sessionUUID')
            .appendField('sessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarRemovedEvent_sessionUUID'), 'sessionUUID');

        this.setColour('#956F41');
        this.setTooltip('Triggered when an avatar leaves the domain.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.avatarRemovedEvent');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_avatarRemovedEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const sessionUUID = generator.getVariableName(block.getFieldValue('sessionUUID'));

return `AvatarManager.avatarRemovedEvent.connect((_sessionUUID) => { 
  ${sessionUUID} = _sessionUUID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AvatarManager_avatarSessionChangedEvent'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AvatarManager.avatarSessionChangedEvent');

        this.appendDummyInput('newSessionUUID')
            .appendField('newSessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarSessionChangedEvent_newSessionUUID'), 'newSessionUUID');
        this.appendDummyInput('oldSessionUUID')
            .appendField('oldSessionUUID:')
            .appendField(new Blockly.FieldVariable('avatarSessionChangedEvent_oldSessionUUID'), 'oldSessionUUID');

        this.setColour('#956F41');
        this.setTooltip('Triggered when an avatar\'s session ID changes.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.avatarSessionChangedEvent');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_avatarSessionChangedEvent'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const newSessionUUID = generator.getVariableName(block.getFieldValue('newSessionUUID'));
    const oldSessionUUID = generator.getVariableName(block.getFieldValue('oldSessionUUID'));

return `AvatarManager.avatarSessionChangedEvent.connect((_newSessionUUID,_oldSessionUUID) => { 
  ${newSessionUUID} = _newSessionUUID; 
  ${oldSessionUUID} = _oldSessionUUID;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['AvatarManager_isAvatarInRange'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AvatarManager.isAvatarInRange')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('position') 
            .setCheck('String')
            .appendField('position');
        this.appendValueInput('range') 
            .setCheck('String')
            .appendField('range');

        this.setColour('#956F41');
        this.setTooltip('Checks whether there is an avatar within a specified distance from a point.');
        this.setHelpUrl('https://apidocs.overte.org/AvatarManager.html#.isAvatarInRange');
    }
};
javascript.javascriptGenerator.forBlock['AvatarManager_isAvatarInRange'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _range = dfv(generator.valueToCode(block, 'range', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AvatarManager.isAvatarInRange(${_position},${_range})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getDomainMinScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDomainMinScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the minimum scale allowed for this avatar in the current domain.This value can change as the user changes avatars or when changing domains.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDomainMinScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDomainMinScale'] = (block, generator) => {

return [`MyAvatar.getDomainMinScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getDomainMaxScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDomainMaxScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the maximum scale allowed for this avatar in the current domain.This value can change as the user changes avatars or when changing domains.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDomainMaxScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDomainMaxScale'] = (block, generator) => {

return [`MyAvatar.getDomainMaxScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getEyeHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getEyeHeight')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current eye height of the avatar.This height is only an estimate and might be incorrect for avatars that are missing standard joints.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getEyeHeight');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getEyeHeight'] = (block, generator) => {

return [`MyAvatar.getEyeHeight()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getHeight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHeight')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the current height of the avatar.This height is only an estimate and might be incorrect for avatars that are missing standard joints.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHeight');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHeight'] = (block, generator) => {

return [`MyAvatar.getHeight()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setHandState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setHandState')
        // Returns data

        // Params data
        this.appendValueInput('state') 
            .setCheck('HandState')
            .appendField('state');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the pointing state of the hands to control where the laser emanates from. If the right index finger is pointing, thelaser emanates from the tip of that finger, otherwise it emanates from the palm.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setHandState');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setHandState'] = (block, generator) => {
    const _state = dfv(generator.valueToCode(block, 'state', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setHandState(${_state});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getHandState'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getHandState')
        // Returns data
        this.setOutput(true, '["HandState"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the pointing state of the hands to control where the laser emanates from. If the right index finger is pointing, thelaser emanates from the tip of that finger, otherwise it emanates from the palm.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getHandState');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getHandState'] = (block, generator) => {

return [`MyAvatar.getHandState()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setJointData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointData')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets a specific joint\'s rotation and position relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointData'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointData(${_index},${_rotation},${_translation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setJointDatanamerotationtranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointData')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets a specific joint\'s rotation and position relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointDatanamerotationtranslation'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointData(${_name},${_rotation},${_translation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointRotation')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets a specific joint\'s rotation relative to its parent.<p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointRotation(${_index},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setJointRotationnamerotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointRotation')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('rotation') 
            .setCheck('Quat')
            .appendField('rotation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets a specific joint\'s rotation relative to its parent.<p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointRotationnamerotation'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _rotation = dfv(generator.valueToCode(block, 'rotation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointRotation(${_name},${_rotation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointTranslation')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets a specific joint\'s translation relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointTranslation(${_index},${_translation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setJointTranslationnametranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointTranslation')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('translation') 
            .setCheck('Vec3')
            .appendField('translation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets a specific joint\'s translation relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointTranslationnametranslation'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _translation = dfv(generator.valueToCode(block, 'translation', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointTranslation(${_name},${_translation});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_clearJointData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.clearJointData')
        // Returns data

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Clears joint translations and rotations set by script for a specific joint. This restores all motion from the defaultanimation system including inverse kinematics for that joint.<p>Note: This is slightly faster than the function variation that specifies the joint name.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.clearJointData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_clearJointData'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.clearJointData(${_index});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_clearJointDataname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.clearJointData')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Clears joint translations and rotations set by script for a specific joint. This restores all motion from the defaultanimation system including inverse kinematics for that joint.<p>Note: This is slightly slower than the function variation that specifies the joint index.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.clearJointData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_clearJointDataname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.clearJointData(${_name});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_isJointDataValid'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isJointDataValid')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Checks that the data for a joint are valid.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isJointDataValid');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isJointDataValid'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.isJointDataValid(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_isJointDataValidname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.isJointDataValid')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#DC476E');
        this.setTooltip('Checks if the data for a joint are valid.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.isJointDataValid');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_isJointDataValidname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.isJointDataValid(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointRotation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotation of a joint relative to its parent. For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointRotation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getJointRotation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointRotationname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointRotation')
        // Returns data
        this.setOutput(true, '["Quat"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotation of a joint relative to its parent. For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointRotation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointRotationname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.getJointRotation(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointTranslation'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#DC476E');
        this.setTooltip('Gets the translation of a joint relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointTranslation'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getJointTranslation(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointTranslationname'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointTranslation')
        // Returns data
        this.setOutput(true, '["Vec3"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Number')
            .appendField('name');

        this.setColour('#DC476E');
        this.setTooltip('Gets the translation of a joint relative to its parent, in model coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>For information on the joint hierarchy used, see<a href="https://docs.overte.org/create/avatars/avatar-standards.html">Avatar Standards</a>.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointTranslation');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointTranslationname'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`MyAvatar.getJointTranslation(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointRotations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotations of all joints in the current avatar. Each joint\'s rotation is relative to its parent joint.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointRotations');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointRotations'] = (block, generator) => {

return [`MyAvatar.getJointRotations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointTranslations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointTranslations')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the translations of all joints in the current avatar. Each joint\'s translation is relative to its parent joint, inmodel coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointTranslations');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointTranslations'] = (block, generator) => {

return [`MyAvatar.getJointTranslations()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setJointRotations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointRotations')
        // Returns data

        // Params data
        this.appendValueInput('jointRotations') 
            .setCheck('Array')
            .appendField('jointRotations');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the rotations of all joints in the current avatar. Each joint\'s rotation is relative to its parent joint.<p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointRotations');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointRotations'] = (block, generator) => {
    const _jointRotations = dfv(generator.valueToCode(block, 'jointRotations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointRotations(${_jointRotations});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setJointTranslations'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setJointTranslations')
        // Returns data

        // Params data
        this.appendValueInput('translations') 
            .setCheck('Array')
            .appendField('translations');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the translations of all joints in the current avatar. Each joint\'s translation is relative to its parent joint, inmodel coordinates.<p><strong>Warning:</strong> These coordinates are not necessarily in meters.</p><p>Setting joint data completely overrides/replaces all motion from the default animation system including inversekinematics, but just for the specified joint. So for example, if you were to procedurally manipulate the finger joints,the avatar\'s hand and head would still do inverse kinematics properly. However, as soon as you start to manipulatejoints in the inverse kinematics chain, the inverse kinematics might not function as you expect. For example, if you setthe rotation of the elbow, the hand inverse kinematics position won\'t end up in the right place.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setJointTranslations');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setJointTranslations'] = (block, generator) => {
    const _translations = dfv(generator.valueToCode(block, 'translations', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setJointTranslations(${_translations});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_clearJointsData'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.clearJointsData')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Clears all joint translations and rotations that have been set by script. This restores all motion from the defaultanimation system including inverse kinematics for all joints.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.clearJointsData');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_clearJointsData'] = (block, generator) => {


    return `MyAvatar.clearJointsData();\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getJointIndex'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointIndex')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#DC476E');
        this.setTooltip('Gets the joint index for a named joint. The joint index value is the position of the joint in the array returned by{@link MyAvatar.getJointNames}, or {@link Avatar.getJointNames} if using the <code>Avatar</code> API.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointIndex');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointIndex'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MyAvatar.getJointIndex(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getJointNames'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getJointNames')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the names of all the joints in the current avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getJointNames');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getJointNames'] = (block, generator) => {

return [`MyAvatar.getJointNames()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_setBlendshape'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setBlendshape')
        // Returns data

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');
        this.appendValueInput('value') 
            .setCheck('Number')
            .appendField('value');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the value of a blend shape to animate your avatar\'s face. In order for other users to see the resulting animationson your avatar\'s face, set <code>hasScriptedBlendshapes</code> to <code>true</code>. When you are done using this API,set <code>hasScriptedBlendshapes</code> back to <code>false</code> when the animation is complete.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setBlendshape');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setBlendshape'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _value = dfv(generator.valueToCode(block, 'value', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `MyAvatar.setBlendshape(${_name},${_value});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setForceFaceTrackerConnected'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setForceFaceTrackerConnected')
        // Returns data

        // Params data
        this.appendValueInput('connected') 
            .setCheck('Boolean')
            .appendField('connected');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Enables blend shapes set using {@link Avatar.setBlendshape} or {@link MyAvatar.setBlendshape} to be transmitted to otherusers so that they can see the animation of your avatar\'s face.<p class="important">Deprecated: This method is deprecated and will be removed. Use the<code>Avatar.hasScriptedBlendshapes</code> or <code>MyAvatar.hasScriptedBlendshapes</code>  property instead.</p>');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setForceFaceTrackerConnected');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setForceFaceTrackerConnected'] = (block, generator) => {
    const _connected = dfv(generator.valueToCode(block, 'connected', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `MyAvatar.setForceFaceTrackerConnected(${_connected});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_setSkeletonModelURL'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.setSkeletonModelURL')
        // Returns data

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#DC476E');
        this.setTooltip('Sets the avatar\'s skeleton model.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.setSkeletonModelURL');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_setSkeletonModelURL'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `MyAvatar.setSkeletonModelURL(${_url});\n`;};


// Blockly function
Blockly.Blocks['MyAvatar_getSensorToWorldMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getSensorToWorldMatrix')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the transform from the user\'s real world to the avatar\'s size, orientation, and position in the virtual world.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getSensorToWorldMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getSensorToWorldMatrix'] = (block, generator) => {

return [`MyAvatar.getSensorToWorldMatrix()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getSensorToWorldScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getSensorToWorldScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the scale that transforms dimensions in the user\'s real world to the avatar\'s size in the virtual world.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getSensorToWorldScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getSensorToWorldScale'] = (block, generator) => {

return [`MyAvatar.getSensorToWorldScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getControllerLeftHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getControllerLeftHandMatrix')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotation and translation of the left hand controller relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getControllerLeftHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getControllerLeftHandMatrix'] = (block, generator) => {

return [`MyAvatar.getControllerLeftHandMatrix()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getControllerRightHandMatrix'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getControllerRightHandMatrix')
        // Returns data
        this.setOutput(true, '["Mat4"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the rotation and translation of the right hand controller relative to the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getControllerRightHandMatrix');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getControllerRightHandMatrix'] = (block, generator) => {

return [`MyAvatar.getControllerRightHandMatrix()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getDataRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getDataRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('rateName') 
            .setCheck('AvatarDataRate')
            .appendField('rateName');

        this.setColour('#DC476E');
        this.setTooltip('Gets the amount of avatar mixer data being generated by the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getDataRate');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getDataRate'] = (block, generator) => {
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`MyAvatar.getDataRate(${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MyAvatar_getUpdateRate'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getUpdateRate')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('rateName') 
            .setCheck('AvatarUpdateRate')
            .appendField('rateName');

        this.setColour('#DC476E');
        this.setTooltip('Gets the update rate of avatar mixer data being generated by the avatar.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getUpdateRate');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getUpdateRate'] = (block, generator) => {
    const _rateName = dfv(generator.valueToCode(block, 'rateName', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);

return [`MyAvatar.getUpdateRate(${_rateName})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['MyAvatar_displayNameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.displayNameChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s <code>displayName</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.displayNameChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_displayNameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.displayNameChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_sessionDisplayNameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.sessionDisplayNameChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s <code>sessionDisplayName</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sessionDisplayNameChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sessionDisplayNameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.sessionDisplayNameChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_skeletonModelURLChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.skeletonModelURLChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s model (i.e., <code>skeletonModelURL</code> property value) changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.skeletonModelURLChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_skeletonModelURLChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.skeletonModelURLChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_lookAtSnappingChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.lookAtSnappingChanged');

        this.appendDummyInput('enabled')
            .appendField('enabled:')
            .appendField(new Blockly.FieldVariable('lookAtSnappingChanged_enabled'), 'enabled');

        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s <code>lookAtSnappingEnabled</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.lookAtSnappingChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_lookAtSnappingChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const enabled = generator.getVariableName(block.getFieldValue('enabled'));

return `MyAvatar.lookAtSnappingChanged.connect((_enabled) => { 
  ${enabled} = _enabled;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['MyAvatar_sessionUUIDChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MyAvatar.sessionUUIDChanged');


        this.setColour('#DC476E');
        this.setTooltip('Triggered when the avatar\'s <code>sessionUUID</code> property value changes.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.sessionUUIDChanged');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_sessionUUIDChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MyAvatar.sessionUUIDChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['MyAvatar_getTargetScale'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MyAvatar.getTargetScale')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data

        this.setColour('#DC476E');
        this.setTooltip('Gets the target scale of the avatar without any restrictions on permissible values imposed by the domain. In contrast, the<code>scale</code> property\'s value may be limited by the domain\'s settings.');
        this.setHelpUrl('https://apidocs.overte.org/MyAvatar.html#.getTargetScale');
    }
};
javascript.javascriptGenerator.forBlock['MyAvatar_getTargetScale'] = (block, generator) => {

return [`MyAvatar.getTargetScale()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Account_getDownloadInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Account.getDownloadInfo')
        // Returns data
        this.setOutput(true, '["AccountServices.DownloadInfoResult"]');

        // Params data

        this.setColour('#08BD40');
        this.setTooltip('Gets information on the download progress of assets in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.getDownloadInfo');
    }
};
javascript.javascriptGenerator.forBlock['Account_getDownloadInfo'] = (block, generator) => {

return [`Account.getDownloadInfo()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Account_updateDownloadInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Account.updateDownloadInfo')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#08BD40');
        this.setTooltip('Triggers a {@link AccountServices.downloadInfoChanged|downloadInfoChanged} signal with information on the current download progress of the assets in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.updateDownloadInfo');
    }
};
javascript.javascriptGenerator.forBlock['Account_updateDownloadInfo'] = (block, generator) => {


    return `Account.updateDownloadInfo();\n`;};


// Blockly function
Blockly.Blocks['Account_isLoggedIn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Account.isLoggedIn')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#08BD40');
        this.setTooltip('Checks whether the user is logged in.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.isLoggedIn');
    }
};
javascript.javascriptGenerator.forBlock['Account_isLoggedIn'] = (block, generator) => {

return [`Account.isLoggedIn()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Account_checkAndSignalForAccessToken'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Account.checkAndSignalForAccessToken')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#08BD40');
        this.setTooltip('The function returns the login status of the user and prompts the user to log in (with a login dialog) if they\'re not already logged in.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.checkAndSignalForAccessToken');
    }
};
javascript.javascriptGenerator.forBlock['Account_checkAndSignalForAccessToken'] = (block, generator) => {

return [`Account.checkAndSignalForAccessToken()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['Account_logOut'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('Account.logOut')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#08BD40');
        this.setTooltip('Logs the user out.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.logOut');
    }
};
javascript.javascriptGenerator.forBlock['Account_logOut'] = (block, generator) => {


    return `Account.logOut();\n`;};


// Blockly signal
Blockly.Blocks['Account_connected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Account.connected');


        this.setColour('#08BD40');
        this.setTooltip('Not currently used.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.connected');
    }
};
javascript.javascriptGenerator.forBlock['Account_connected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `Account.connected.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Account_disconnected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Account.disconnected');

        this.appendDummyInput('reason')
            .appendField('reason:')
            .appendField(new Blockly.FieldVariable('disconnected_reason'), 'reason');

        this.setColour('#08BD40');
        this.setTooltip('Triggered when the user logs out.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.disconnected');
    }
};
javascript.javascriptGenerator.forBlock['Account_disconnected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const reason = generator.getVariableName(block.getFieldValue('reason'));

return `Account.disconnected.connect((_reason) => { 
  ${reason} = _reason;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Account_myUsernameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Account.myUsernameChanged');

        this.appendDummyInput('username')
            .appendField('username:')
            .appendField(new Blockly.FieldVariable('myUsernameChanged_username'), 'username');

        this.setColour('#08BD40');
        this.setTooltip('Triggered when the username logged in with changes, i.e., when the user logs in or out.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.myUsernameChanged');
    }
};
javascript.javascriptGenerator.forBlock['Account_myUsernameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const username = generator.getVariableName(block.getFieldValue('username'));

return `Account.myUsernameChanged.connect((_username) => { 
  ${username} = _username;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Account_downloadInfoChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Account.downloadInfoChanged');

        this.appendDummyInput('downloadInfo')
            .appendField('downloadInfo:')
            .appendField(new Blockly.FieldVariable('downloadInfoChanged_downloadInfo'), 'downloadInfo');

        this.setColour('#08BD40');
        this.setTooltip('Triggered when the download progress of the assets in the domain changes.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.downloadInfoChanged');
    }
};
javascript.javascriptGenerator.forBlock['Account_downloadInfoChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const downloadInfo = generator.getVariableName(block.getFieldValue('downloadInfo'));

return `Account.downloadInfoChanged.connect((_downloadInfo) => { 
  ${downloadInfo} = _downloadInfo;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Account_findableByChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Account.findableByChanged');

        this.appendDummyInput('findableBy')
            .appendField('findableBy:')
            .appendField(new Blockly.FieldVariable('findableByChanged_findableBy'), 'findableBy');

        this.setColour('#08BD40');
        this.setTooltip('Triggered when the user\'s visibility to others changes.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.findableByChanged');
    }
};
javascript.javascriptGenerator.forBlock['Account_findableByChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const findableBy = generator.getVariableName(block.getFieldValue('findableBy'));

return `Account.findableByChanged.connect((_findableBy) => { 
  ${findableBy} = _findableBy;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['Account_loggedInChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('Account.loggedInChanged');

        this.appendDummyInput('loggedIn')
            .appendField('loggedIn:')
            .appendField(new Blockly.FieldVariable('loggedInChanged_loggedIn'), 'loggedIn');

        this.setColour('#08BD40');
        this.setTooltip('Triggered when the login status of the user changes.');
        this.setHelpUrl('https://apidocs.overte.org/Account.html#.loggedInChanged');
    }
};
javascript.javascriptGenerator.forBlock['Account_loggedInChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const loggedIn = generator.getVariableName(block.getFieldValue('loggedIn'));

return `Account.loggedInChanged.connect((_loggedIn) => { 
  ${loggedIn} = _loggedIn;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['GlobalServices_getDownloadInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GlobalServices.getDownloadInfo')
        // Returns data
        this.setOutput(true, '["AccountServices.DownloadInfoResult"]');

        // Params data

        this.setColour('#BB6327');
        this.setTooltip('Gets information on the download progress of assets in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.getDownloadInfo');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_getDownloadInfo'] = (block, generator) => {

return [`GlobalServices.getDownloadInfo()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GlobalServices_updateDownloadInfo'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GlobalServices.updateDownloadInfo')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BB6327');
        this.setTooltip('Triggers a {@link AccountServices.downloadInfoChanged|downloadInfoChanged} signal with information on the current download progress of the assets in the domain.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.updateDownloadInfo');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_updateDownloadInfo'] = (block, generator) => {


    return `GlobalServices.updateDownloadInfo();\n`;};


// Blockly function
Blockly.Blocks['GlobalServices_isLoggedIn'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GlobalServices.isLoggedIn')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#BB6327');
        this.setTooltip('Checks whether the user is logged in.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.isLoggedIn');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_isLoggedIn'] = (block, generator) => {

return [`GlobalServices.isLoggedIn()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GlobalServices_checkAndSignalForAccessToken'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GlobalServices.checkAndSignalForAccessToken')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#BB6327');
        this.setTooltip('The function returns the login status of the user and prompts the user to log in (with a login dialog) if they\'re not already logged in.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.checkAndSignalForAccessToken');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_checkAndSignalForAccessToken'] = (block, generator) => {

return [`GlobalServices.checkAndSignalForAccessToken()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GlobalServices_logOut'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GlobalServices.logOut')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#BB6327');
        this.setTooltip('Logs the user out.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.logOut');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_logOut'] = (block, generator) => {


    return `GlobalServices.logOut();\n`;};


// Blockly signal
Blockly.Blocks['GlobalServices_connected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('GlobalServices.connected');


        this.setColour('#BB6327');
        this.setTooltip('Not currently used.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.connected');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_connected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `GlobalServices.connected.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['GlobalServices_disconnected'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('GlobalServices.disconnected');

        this.appendDummyInput('reason')
            .appendField('reason:')
            .appendField(new Blockly.FieldVariable('disconnected_reason'), 'reason');

        this.setColour('#BB6327');
        this.setTooltip('Triggered when the user logs out.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.disconnected');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_disconnected'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const reason = generator.getVariableName(block.getFieldValue('reason'));

return `GlobalServices.disconnected.connect((_reason) => { 
  ${reason} = _reason;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['GlobalServices_myUsernameChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('GlobalServices.myUsernameChanged');

        this.appendDummyInput('username')
            .appendField('username:')
            .appendField(new Blockly.FieldVariable('myUsernameChanged_username'), 'username');

        this.setColour('#BB6327');
        this.setTooltip('Triggered when the username logged in with changes, i.e., when the user logs in or out.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.myUsernameChanged');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_myUsernameChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const username = generator.getVariableName(block.getFieldValue('username'));

return `GlobalServices.myUsernameChanged.connect((_username) => { 
  ${username} = _username;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['GlobalServices_downloadInfoChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('GlobalServices.downloadInfoChanged');

        this.appendDummyInput('downloadInfo')
            .appendField('downloadInfo:')
            .appendField(new Blockly.FieldVariable('downloadInfoChanged_downloadInfo'), 'downloadInfo');

        this.setColour('#BB6327');
        this.setTooltip('Triggered when the download progress of the assets in the domain changes.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.downloadInfoChanged');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_downloadInfoChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const downloadInfo = generator.getVariableName(block.getFieldValue('downloadInfo'));

return `GlobalServices.downloadInfoChanged.connect((_downloadInfo) => { 
  ${downloadInfo} = _downloadInfo;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['GlobalServices_findableByChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('GlobalServices.findableByChanged');

        this.appendDummyInput('findableBy')
            .appendField('findableBy:')
            .appendField(new Blockly.FieldVariable('findableByChanged_findableBy'), 'findableBy');

        this.setColour('#BB6327');
        this.setTooltip('Triggered when the user\'s visibility to others changes.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.findableByChanged');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_findableByChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const findableBy = generator.getVariableName(block.getFieldValue('findableBy'));

return `GlobalServices.findableByChanged.connect((_findableBy) => { 
  ${findableBy} = _findableBy;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['GlobalServices_loggedInChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('GlobalServices.loggedInChanged');

        this.appendDummyInput('loggedIn')
            .appendField('loggedIn:')
            .appendField(new Blockly.FieldVariable('loggedInChanged_loggedIn'), 'loggedIn');

        this.setColour('#BB6327');
        this.setTooltip('Triggered when the login status of the user changes.');
        this.setHelpUrl('https://apidocs.overte.org/GlobalServices.html#.loggedInChanged');
    }
};
javascript.javascriptGenerator.forBlock['GlobalServices_loggedInChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const loggedIn = generator.getVariableName(block.getFieldValue('loggedIn'));

return `GlobalServices.loggedInChanged.connect((_loggedIn) => { 
  ${loggedIn} = _loggedIn;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['AnimationCache_getResourceList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.getResourceList')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#4533CE');
        this.setTooltip('Gets the URLs of all resources in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.getResourceList');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_getResourceList'] = (block, generator) => {

return [`AnimationCache.getResourceList()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AnimationCache_prefetch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AnimationCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#4533CE');
        this.setTooltip('Prefetches a resource.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_prefetch'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`AnimationCache.prefetch(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['AnimationCache_dirty'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AnimationCache.dirty');


        this.setColour('#4533CE');
        this.setTooltip('Triggered when the cache content has changed.');
        this.setHelpUrl('https://apidocs.overte.org/AnimationCache.html#.dirty');
    }
};
javascript.javascriptGenerator.forBlock['AnimationCache_dirty'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AnimationCache.dirty.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['SoundCache_getResourceList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.getResourceList')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#DB1159');
        this.setTooltip('Gets the URLs of all resources in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.getResourceList');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_getResourceList'] = (block, generator) => {

return [`SoundCache.getResourceList()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['SoundCache_prefetch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('SoundCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#DB1159');
        this.setTooltip('Prefetches a resource.');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_prefetch'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`SoundCache.prefetch(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['SoundCache_dirty'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('SoundCache.dirty');


        this.setColour('#DB1159');
        this.setTooltip('Triggered when the cache content has changed.');
        this.setHelpUrl('https://apidocs.overte.org/SoundCache.html#.dirty');
    }
};
javascript.javascriptGenerator.forBlock['SoundCache_dirty'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `SoundCache.dirty.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['GraphicsMeshPart_addAttribute'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.addAttribute')
        // Returns data
        this.setOutput(true, '["Number"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('Graphics.BufferTypeName')
            .appendField('name');
        this.appendValueInput('defaultValue') 
            .setCheck('Graphics.BufferType')
            .appendField('defaultValue');

        this.setColour('#8BBD83');
        this.setTooltip('Adds an attribute for all vertices.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.addAttribute');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_addAttribute'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _defaultValue = dfv(generator.valueToCode(block, 'defaultValue', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.addAttribute(${_name},${_defaultValue})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_getVertextAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.getVertextAttributes')
        // Returns data
        this.setOutput(true, '["Object.<Graphics.BufferTypeName, Graphics.BufferType>"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');

        this.setColour('#8BBD83');
        this.setTooltip('Gets the attributes and attribute values of a vertex.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.getVertextAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_getVertextAttributes'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);

return [`GraphicsMeshPart.getVertextAttributes(${_index})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['GraphicsMeshPart_setVertextAttributes'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('GraphicsMeshPart.setVertextAttributes')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data
        this.appendValueInput('index') 
            .setCheck('Number')
            .appendField('index');
        this.appendValueInput('values') 
            .setCheck('Object.<Graphics.BufferTypeNAme, Graphics.BufferType>')
            .appendField('values');

        this.setColour('#8BBD83');
        this.setTooltip('Updates attribute values of a vertex.');
        this.setHelpUrl('https://apidocs.overte.org/GraphicsMeshPart.html#.setVertextAttributes');
    }
};
javascript.javascriptGenerator.forBlock['GraphicsMeshPart_setVertextAttributes'] = (block, generator) => {
    const _index = dfv(generator.valueToCode(block, 'index', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _values = dfv(generator.valueToCode(block, 'values', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`GraphicsMeshPart.setVertextAttributes(${_index},${_values})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TextureCache_getResourceList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.getResourceList')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#CFB8C8');
        this.setTooltip('Gets the URLs of all resources in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.getResourceList');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_getResourceList'] = (block, generator) => {

return [`TextureCache.getResourceList()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['TextureCache_prefetchurl'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('TextureCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#CFB8C8');
        this.setTooltip('Prefetches a resource.');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_prefetchurl'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`TextureCache.prefetch(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['TextureCache_dirty'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('TextureCache.dirty');


        this.setColour('#CFB8C8');
        this.setTooltip('Triggered when the cache content has changed.');
        this.setHelpUrl('https://apidocs.overte.org/TextureCache.html#.dirty');
    }
};
javascript.javascriptGenerator.forBlock['TextureCache_dirty'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `TextureCache.dirty.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['ModelCache_getResourceList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.getResourceList')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#C1E06C');
        this.setTooltip('Gets the URLs of all resources in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.getResourceList');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_getResourceList'] = (block, generator) => {

return [`ModelCache.getResourceList()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['ModelCache_prefetch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('ModelCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#C1E06C');
        this.setTooltip('Prefetches a resource.');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_prefetch'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`ModelCache.prefetch(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['ModelCache_dirty'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('ModelCache.dirty');


        this.setColour('#C1E06C');
        this.setTooltip('Triggered when the cache content has changed.');
        this.setHelpUrl('https://apidocs.overte.org/ModelCache.html#.dirty');
    }
};
javascript.javascriptGenerator.forBlock['ModelCache_dirty'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `ModelCache.dirty.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['AddressManager_handleLookupString'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.handleLookupString')
        // Returns data

        // Params data
        this.appendValueInput('address') 
            .setCheck('String')
            .appendField('address');
        this.appendValueInput('fromSuggestions') 
            .setCheck('Boolean')
            .appendField('fromSuggestions');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you to a specified directory services address.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.handleLookupString');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_handleLookupString'] = (block, generator) => {
    const _address = dfv(generator.valueToCode(block, 'address', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _fromSuggestions = dfv(generator.valueToCode(block, 'fromSuggestions', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `AddressManager.handleLookupString(${_address},${_fromSuggestions});\n`;};


// Blockly function
Blockly.Blocks['AddressManager_goBack'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.goBack')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you back to the previous location in your navigation history, if there is one.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goBack');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goBack'] = (block, generator) => {


    return `AddressManager.goBack();\n`;};


// Blockly function
Blockly.Blocks['AddressManager_goForward'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.goForward')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you forward to the next location in your navigation history, if there is one.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goForward');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goForward'] = (block, generator) => {


    return `AddressManager.goForward();\n`;};


// Blockly function
Blockly.Blocks['AddressManager_goToLocalSandbox'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.goToLocalSandbox')
        // Returns data

        // Params data
        this.appendValueInput('path') 
            .setCheck('String')
            .appendField('path');
        this.appendValueInput('trigger') 
            .setCheck('location.LookupTrigger')
            .appendField('trigger');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you to the local Sandbox server that\'s running on the same PC as Interface.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goToLocalSandbox');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goToLocalSandbox'] = (block, generator) => {
    const _path = dfv(generator.valueToCode(block, 'path', javascript.javascriptGenerator.ORDER_ATOMIC), `""`);
    const _trigger = dfv(generator.valueToCode(block, 'trigger', javascript.javascriptGenerator.ORDER_ATOMIC), `StartupFromSettings`);


    return `AddressManager.goToLocalSandbox(${_path},${_trigger});\n`;};


// Blockly function
Blockly.Blocks['AddressManager_goToEntry'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.goToEntry')
        // Returns data

        // Params data
        this.appendValueInput('trigger') 
            .setCheck('location.LookupTrigger')
            .appendField('trigger');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you to the default "welcome" directory services address.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goToEntry');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goToEntry'] = (block, generator) => {
    const _trigger = dfv(generator.valueToCode(block, 'trigger', javascript.javascriptGenerator.ORDER_ATOMIC), `StartupFromSettings`);


    return `AddressManager.goToEntry(${_trigger});\n`;};


// Blockly function
Blockly.Blocks['AddressManager_goToUser'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.goToUser')
        // Returns data

        // Params data
        this.appendValueInput('username') 
            .setCheck('String')
            .appendField('username');
        this.appendValueInput('matchOrientation') 
            .setCheck('Boolean')
            .appendField('matchOrientation');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you to the specified user\'s location.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goToUser');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goToUser'] = (block, generator) => {
    const _username = dfv(generator.valueToCode(block, 'username', javascript.javascriptGenerator.ORDER_ATOMIC), ``);
    const _matchOrientation = dfv(generator.valueToCode(block, 'matchOrientation', javascript.javascriptGenerator.ORDER_ATOMIC), `true`);


    return `AddressManager.goToUser(${_username},${_matchOrientation});\n`;};


// Blockly function
Blockly.Blocks['AddressManager_goToLastAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.goToLastAddress')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Takes you to the last address tried. This will be the last URL tried from <code>location.handleLookupString</code>.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goToLastAddress');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goToLastAddress'] = (block, generator) => {


    return `AddressManager.goToLastAddress();\n`;};


// Blockly function
Blockly.Blocks['AddressManager_canGoBack'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.canGoBack')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#E1A1D3');
        this.setTooltip('Checks if going back to the previous location is possible.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.canGoBack');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_canGoBack'] = (block, generator) => {

return [`AddressManager.canGoBack()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['AddressManager_storeCurrentAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.storeCurrentAddress')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Updates your current directory services location in Interface\'s {@link Settings} file as your last-known address. This can be usedto ensure that you start up at that address if you exit Interface without a later address automatically being saved.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.storeCurrentAddress');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_storeCurrentAddress'] = (block, generator) => {


    return `AddressManager.storeCurrentAddress();\n`;};


// Blockly function
Blockly.Blocks['AddressManager_copyAddress'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.copyAddress')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Copies your current directory services address (i.e., <code>location.href</code> property value) to the OS clipboard.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.copyAddress');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_copyAddress'] = (block, generator) => {


    return `AddressManager.copyAddress();\n`;};


// Blockly function
Blockly.Blocks['AddressManager_copyPath'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('AddressManager.copyPath')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#E1A1D3');
        this.setTooltip('Copies your current directory services location and orientation (i.e., <code>location.pathname</code> property value) to the OSclipboard.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.copyPath');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_copyPath'] = (block, generator) => {


    return `AddressManager.copyPath();\n`;};


// Blockly signal
Blockly.Blocks['AddressManager_lookupResultsFinished'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.lookupResultsFinished');


        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when looking up the details of a directory services user or location to go to has completed (successfully orunsuccessfully).');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.lookupResultsFinished');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_lookupResultsFinished'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AddressManager.lookupResultsFinished.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_lookupResultIsOffline'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.lookupResultIsOffline');


        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when looking up the details of a directory services user or location to go to has completed and the domain or user isoffline.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.lookupResultIsOffline');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_lookupResultIsOffline'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AddressManager.lookupResultIsOffline.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_lookupResultIsNotFound'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.lookupResultIsNotFound');


        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when looking up the details of a directory services user or location to go to has completed and the domain or user couldnot be found.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.lookupResultIsNotFound');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_lookupResultIsNotFound'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `AddressManager.lookupResultIsNotFound.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_possibleDomainChangeRequired'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.possibleDomainChangeRequired');

        this.appendDummyInput('domainURL')
            .appendField('domainURL:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequired_domainURL'), 'domainURL');
        this.appendDummyInput('domainID')
            .appendField('domainID:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequired_domainID'), 'domainID');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when a request is made to go to a URL or IP address.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.possibleDomainChangeRequired');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_possibleDomainChangeRequired'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const domainURL = generator.getVariableName(block.getFieldValue('domainURL'));
    const domainID = generator.getVariableName(block.getFieldValue('domainID'));

return `AddressManager.possibleDomainChangeRequired.connect((_domainURL,_domainID) => { 
  ${domainURL} = _domainURL; 
  ${domainID} = _domainID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_locationChangeRequired'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.locationChangeRequired');

        this.appendDummyInput('position')
            .appendField('position:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_position'), 'position');
        this.appendDummyInput('hasOrientationChange')
            .appendField('hasOrientationChange:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_hasOrientationChange'), 'hasOrientationChange');
        this.appendDummyInput('orientation')
            .appendField('orientation:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_orientation'), 'orientation');
        this.appendDummyInput('shouldFaceLocation')
            .appendField('shouldFaceLocation:')
            .appendField(new Blockly.FieldVariable('locationChangeRequired_shouldFaceLocation'), 'shouldFaceLocation');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when an attempt is made to send your avatar to a specified position on the current domain. For example, whenyou change domains or enter a position to go to in the "Goto" dialog.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.locationChangeRequired');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_locationChangeRequired'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const position = generator.getVariableName(block.getFieldValue('position'));
    const hasOrientationChange = generator.getVariableName(block.getFieldValue('hasOrientationChange'));
    const orientation = generator.getVariableName(block.getFieldValue('orientation'));
    const shouldFaceLocation = generator.getVariableName(block.getFieldValue('shouldFaceLocation'));

return `AddressManager.locationChangeRequired.connect((_position,_hasOrientationChange,_orientation,_shouldFaceLocation) => { 
  ${position} = _position; 
  ${hasOrientationChange} = _hasOrientationChange; 
  ${orientation} = _orientation; 
  ${shouldFaceLocation} = _shouldFaceLocation;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_possibleDomainChangeRequiredViaICEForID'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.possibleDomainChangeRequiredViaICEForID');

        this.appendDummyInput('iceServerHostName')
            .appendField('iceServerHostName:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequiredViaICEForID_iceServerHostName'), 'iceServerHostName');
        this.appendDummyInput('domainID')
            .appendField('domainID:')
            .appendField(new Blockly.FieldVariable('possibleDomainChangeRequiredViaICEForID_domainID'), 'domainID');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when a request is made to go to a named domain or user.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.possibleDomainChangeRequiredViaICEForID');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_possibleDomainChangeRequiredViaICEForID'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const iceServerHostName = generator.getVariableName(block.getFieldValue('iceServerHostName'));
    const domainID = generator.getVariableName(block.getFieldValue('domainID'));

return `AddressManager.possibleDomainChangeRequiredViaICEForID.connect((_iceServerHostName,_domainID) => { 
  ${iceServerHostName} = _iceServerHostName; 
  ${domainID} = _domainID;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_pathChangeRequired'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.pathChangeRequired');

        this.appendDummyInput('path')
            .appendField('path:')
            .appendField(new Blockly.FieldVariable('pathChangeRequired_path'), 'path');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when an attempt is made to send your avatar to a new named path on the domain (set in the domain server\'ssettings). For example, when you enter a "/" followed by the path\'s name in the "GOTO" dialog.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.pathChangeRequired');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_pathChangeRequired'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const path = generator.getVariableName(block.getFieldValue('path'));

return `AddressManager.pathChangeRequired.connect((_path) => { 
  ${path} = _path;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_hostChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.hostChanged');

        this.appendDummyInput('hostname')
            .appendField('hostname:')
            .appendField(new Blockly.FieldVariable('hostChanged_hostname'), 'hostname');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when you navigate to a new domain.');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.hostChanged');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_hostChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const hostname = generator.getVariableName(block.getFieldValue('hostname'));

return `AddressManager.hostChanged.connect((_hostname) => { 
  ${hostname} = _hostname;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_goBackPossible'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.goBackPossible');

        this.appendDummyInput('isPossible')
            .appendField('isPossible:')
            .appendField(new Blockly.FieldVariable('goBackPossible_isPossible'), 'isPossible');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when there\'s a change in whether or not there\'s a previous location that can be navigated to using{@link location.goBack|goBack}. (Reflects changes in the state of the "Goto" dialog\'s back arrow.)');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goBackPossible');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goBackPossible'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isPossible = generator.getVariableName(block.getFieldValue('isPossible'));

return `AddressManager.goBackPossible.connect((_isPossible) => { 
  ${isPossible} = _isPossible;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['AddressManager_goForwardPossible'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('AddressManager.goForwardPossible');

        this.appendDummyInput('isPossible')
            .appendField('isPossible:')
            .appendField(new Blockly.FieldVariable('goForwardPossible_isPossible'), 'isPossible');

        this.setColour('#E1A1D3');
        this.setTooltip('Triggered when there\'s a change in whether or not there\'s a forward location that can be navigated to using{@link location.goForward|goForward}. (Reflects changes in the state of the "Goto" dialog\'s forward arrow.)');
        this.setHelpUrl('https://apidocs.overte.org/AddressManager.html#.goForwardPossible');
    }
};
javascript.javascriptGenerator.forBlock['AddressManager_goForwardPossible'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const isPossible = generator.getVariableName(block.getFieldValue('isPossible'));

return `AddressManager.goForwardPossible.connect((_isPossible) => { 
  ${isPossible} = _isPossible;
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['MaterialCache_getResourceList'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.getResourceList')
        // Returns data
        this.setOutput(true, '["Array"]');

        // Params data

        this.setColour('#8088DB');
        this.setTooltip('Gets the URLs of all resources in the cache.');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.getResourceList');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_getResourceList'] = (block, generator) => {

return [`MaterialCache.getResourceList()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['MaterialCache_prefetch'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('MaterialCache.prefetch')
        // Returns data
        this.setOutput(true, '["ResourceObject"]');

        // Params data
        this.appendValueInput('url') 
            .setCheck('String')
            .appendField('url');

        this.setColour('#8088DB');
        this.setTooltip('Prefetches a resource.');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.prefetch');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_prefetch'] = (block, generator) => {
    const _url = dfv(generator.valueToCode(block, 'url', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`MaterialCache.prefetch(${_url})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly signal
Blockly.Blocks['MaterialCache_dirty'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('MaterialCache.dirty');


        this.setColour('#8088DB');
        this.setTooltip('Triggered when the cache content has changed.');
        this.setHelpUrl('https://apidocs.overte.org/MaterialCache.html#.dirty');
    }
};
javascript.javascriptGenerator.forBlock['MaterialCache_dirty'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `MaterialCache.dirty.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['OverlayWebWindow_isVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.isVisible')
        // Returns data
        this.setOutput(true, '["Boolean"]');

        // Params data

        this.setColour('#C738B3');
        this.setTooltip('Gets whether the window is shown or hidden.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.isVisible');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_isVisible'] = (block, generator) => {

return [`OverlayWebWindow.isVisible()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setVisible'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setVisible')
        // Returns data

        // Params data
        this.appendValueInput('visible') 
            .setCheck('Boolean')
            .appendField('visible');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Shows or hides the window.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setVisible');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setVisible'] = (block, generator) => {
    const _visible = dfv(generator.valueToCode(block, 'visible', javascript.javascriptGenerator.ORDER_ATOMIC), `false`);


    return `OverlayWebWindow.setVisible(${_visible});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_getPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.getPosition')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#C738B3');
        this.setTooltip('Gets the position of the window.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.getPosition');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_getPosition'] = (block, generator) => {

return [`OverlayWebWindow.getPosition()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setPosition'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('position') 
            .setCheck('Vec2')
            .appendField('position');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Sets the position of the window, from a {@link Vec2}.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setPosition'] = (block, generator) => {
    const _position = dfv(generator.valueToCode(block, 'position', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWebWindow.setPosition(${_position});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setPositionxy'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setPosition')
        // Returns data

        // Params data
        this.appendValueInput('x') 
            .setCheck('Number')
            .appendField('x');
        this.appendValueInput('y') 
            .setCheck('Number')
            .appendField('y');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Sets the position of the window, from a pair of numbers.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setPosition');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setPositionxy'] = (block, generator) => {
    const _x = dfv(generator.valueToCode(block, 'x', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _y = dfv(generator.valueToCode(block, 'y', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `OverlayWebWindow.setPosition(${_x},${_y});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_getSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.getSize')
        // Returns data
        this.setOutput(true, '["Vec2"]');

        // Params data

        this.setColour('#C738B3');
        this.setTooltip('Gets the size of the window interior.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.getSize');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_getSize'] = (block, generator) => {

return [`OverlayWebWindow.getSize()`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setSize'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setSize')
        // Returns data

        // Params data
        this.appendValueInput('size') 
            .setCheck('Vec2')
            .appendField('size');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Sets the size of the window interior, from a {@link Vec2}.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setSize');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setSize'] = (block, generator) => {
    const _size = dfv(generator.valueToCode(block, 'size', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWebWindow.setSize(${_size});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setSizewidthheight'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setSize')
        // Returns data

        // Params data
        this.appendValueInput('width') 
            .setCheck('Number')
            .appendField('width');
        this.appendValueInput('height') 
            .setCheck('Number')
            .appendField('height');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Sets the size of the window interior, from a pair of numbers.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setSize');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setSizewidthheight'] = (block, generator) => {
    const _width = dfv(generator.valueToCode(block, 'width', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);
    const _height = dfv(generator.valueToCode(block, 'height', javascript.javascriptGenerator.ORDER_ATOMIC), `0`);


    return `OverlayWebWindow.setSize(${_width},${_height});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_setTitle'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.setTitle')
        // Returns data

        // Params data
        this.appendValueInput('title') 
            .setCheck('String')
            .appendField('title');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Sets the window title.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.setTitle');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_setTitle'] = (block, generator) => {
    const _title = dfv(generator.valueToCode(block, 'title', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `OverlayWebWindow.setTitle(${_title});\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_raise'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.raise')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Raises the window to the top.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.raise');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_raise'] = (block, generator) => {


    return `OverlayWebWindow.raise();\n`;};


// Blockly function
Blockly.Blocks['OverlayWebWindow_close'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('OverlayWebWindow.close')
        // Returns data

        // Params data

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#C738B3');
        this.setTooltip('Closes the window.<p>Note: The window also closes when the script ends.</p>');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.close');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_close'] = (block, generator) => {


    return `OverlayWebWindow.close();\n`;};


// Blockly signal
Blockly.Blocks['OverlayWebWindow_visibleChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.visibleChanged');


        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window is hidden or shown.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.visibleChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_visibleChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWebWindow.visibleChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWebWindow_positionChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.positionChanged');


        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window changes position.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.positionChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_positionChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWebWindow.positionChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWebWindow_sizeChanged'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.sizeChanged');


        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window changes size.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.sizeChanged');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_sizeChanged'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWebWindow.sizeChanged.connect(() => {
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWebWindow_moved'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.moved');

        this.appendDummyInput('position')
            .appendField('position:')
            .appendField(new Blockly.FieldVariable('moved_position'), 'position');

        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window changes position.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.moved');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_moved'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const position = generator.getVariableName(block.getFieldValue('position'));

return `OverlayWebWindow.moved.connect((_position) => { 
  ${position} = _position;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWebWindow_resized'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.resized');

        this.appendDummyInput('size')
            .appendField('size:')
            .appendField(new Blockly.FieldVariable('resized_size'), 'size');

        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window changes size.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.resized');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_resized'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');
    const size = generator.getVariableName(block.getFieldValue('size'));

return `OverlayWebWindow.resized.connect((_size) => { 
  ${size} = _size;
${innerCode}
});\n`;};

// Blockly signal
Blockly.Blocks['OverlayWebWindow_closed'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('OverlayWebWindow.closed');


        this.setColour('#C738B3');
        this.setTooltip('Triggered when the window is closed.');
        this.setHelpUrl('https://apidocs.overte.org/OverlayWebWindow.html#.closed');
    }
};
javascript.javascriptGenerator.forBlock['OverlayWebWindow_closed'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `OverlayWebWindow.closed.connect(() => {
${innerCode}
});\n`;};

// Blockly function
Blockly.Blocks['tabletInterface_getTablet'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('tabletInterface.getTablet')
        // Returns data
        this.setOutput(true, '["TabletProxy"]');

        // Params data
        this.appendValueInput('name') 
            .setCheck('String')
            .appendField('name');

        this.setColour('#EAF20B');
        this.setTooltip('Gets an instance of a tablet. A new tablet is created if one with the specified name doesn\'t already exist.');
        this.setHelpUrl('https://apidocs.overte.org/tabletInterface.html#.getTablet');
    }
};
javascript.javascriptGenerator.forBlock['tabletInterface_getTablet'] = (block, generator) => {
    const _name = dfv(generator.valueToCode(block, 'name', javascript.javascriptGenerator.ORDER_ATOMIC), ``);

return [`tabletInterface.getTablet(${_name})`, javascript.javascriptGenerator.ORDER_NONE];};


// Blockly function
Blockly.Blocks['tabletInterface_playSound'] = {
    init: function() {
        this.appendDummyInput()
            .appendField('tabletInterface.playSound')
        // Returns data

        // Params data
        this.appendValueInput('sound') 
            .setCheck('Tablet.AudioEvents')
            .appendField('sound');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour('#EAF20B');
        this.setTooltip('Plays a standard tablet sound. The sound is played locally (only the user running the script hears it) without a position.');
        this.setHelpUrl('https://apidocs.overte.org/tabletInterface.html#.playSound');
    }
};
javascript.javascriptGenerator.forBlock['tabletInterface_playSound'] = (block, generator) => {
    const _sound = dfv(generator.valueToCode(block, 'sound', javascript.javascriptGenerator.ORDER_ATOMIC), ``);


    return `tabletInterface.playSound(${_sound});\n`;};


// Blockly signal
Blockly.Blocks['tabletInterface_tabletNotification'] = {
    init: function() {
        this.appendStatementInput('VALUE_INPUT')
            .appendField('tabletInterface.tabletNotification');


        this.setColour('#EAF20B');
        this.setTooltip('Triggered when a tablet message or dialog is displayed on the tablet that needs the user\'s attention.<p><strong>Note:</strong> Only triggered if the script is running in the same script engine as the script that created the tablet. By default, this means in scripts included as part of the default scripts.</p>');
        this.setHelpUrl('https://apidocs.overte.org/tabletInterface.html#.tabletNotification');
    }
};
javascript.javascriptGenerator.forBlock['tabletInterface_tabletNotification'] = (block, generator) => {
    const innerCode = generator.statementToCode(block, 'VALUE_INPUT');


return `tabletInterface.tabletNotification.connect(() => {
${innerCode}
});\n`;};
